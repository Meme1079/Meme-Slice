// Generated by Haxe 4.3.7
#include <hxcpp.h>

#ifndef INCLUDED_funkin_transition_VFDOverlay
#include <funkin/transition/VFDOverlay.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_openfl_display_GraphicsShader
#include <openfl/display/GraphicsShader.h>
#endif
#ifndef INCLUDED_openfl_display_Shader
#include <openfl/display/Shader.h>
#endif
#ifndef INCLUDED_openfl_display_ShaderParameter_Float
#include <openfl/display/ShaderParameter_Float.h>
#endif
#ifndef INCLUDED_openfl_utils_ByteArrayData
#include <openfl/utils/ByteArrayData.h>
#endif
#ifndef INCLUDED_openfl_utils_IDataInput
#include <openfl/utils/IDataInput.h>
#endif
#ifndef INCLUDED_openfl_utils_IDataOutput
#include <openfl/utils/IDataOutput.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_4b7809dfebecb1eb_5_new,"funkin.transition.VFDOverlay","new",0x2aab660a,"funkin.transition.VFDOverlay.new","funkin/transition/VFDOverlay.hx",5,0x80213706)
HX_LOCAL_STACK_FRAME(_hx_pos_4b7809dfebecb1eb_8_set_elapsedTime,"funkin.transition.VFDOverlay","set_elapsedTime",0xaf30ffb6,"funkin.transition.VFDOverlay.set_elapsedTime","funkin/transition/VFDOverlay.hx",8,0x80213706)
HX_LOCAL_STACK_FRAME(_hx_pos_4b7809dfebecb1eb_61_update,"funkin.transition.VFDOverlay","update",0x1a37569f,"funkin.transition.VFDOverlay.update","funkin/transition/VFDOverlay.hx",61,0x80213706)
namespace funkin{
namespace transition{

void VFDOverlay_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_4b7809dfebecb1eb_5_new)
HXLINE(   6)		this->elapsedTime = ((Float)0);
HXLINE( 183)		if (::hx::IsNull( this->_hx___glFragmentSource )) {
HXLINE( 185)			this->_hx___glFragmentSource = HX_("varying float openfl_Alphav;\n\t\tvarying vec4 openfl_ColorMultiplierv;\n\t\tvarying vec4 openfl_ColorOffsetv;\n\t\tvarying vec2 openfl_TextureCoordv;\n\n\t\tuniform bool openfl_HasColorTransform;\n\t\tuniform vec2 openfl_TextureSize;\n\t\tuniform sampler2D bitmap;\n\n          const vec2 s = vec2(1, 1.7320508);\n\n          uniform float u_time;\n\n          float rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\n          float rand(vec2 co)  { return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n\n          void main(void) {\n               vec4 col = texture2D (bitmap, openfl_TextureCoordv);\n               vec2 game_res = vec2(1280.0, 720.0);\n               const float tileAmount = 10.;\n\n               vec2 uv = (2. * openfl_TextureCoordv.xy * -1.);\n               uv *= 50.;\n\n               vec4 hexCenter = floor(vec4(uv, uv - vec2(0.5, 1.0)) / s.xyxy) + 0.5;\n               vec4 offset = vec4(uv - hexCenter.xy * s, uv - (hexCenter.zw + 0.5) * s) + 0.0;\n               vec4 hexInfo = dot(offset.xy, offset.xy) < dot(offset.zw, offset.zw) ? vec4(offset.xy, hexCenter.xy) : vec4(offset.zw, hexCenter.zw);\n\n               // Distance to the nearest edge of a hexagon\n               vec2 p = abs(hexInfo.xy) ;\n               float edgeDist = max(dot(p, normalize(vec2(1.0, sqrt(3.0)))), p.x);\n               float edgeWidth = 0.05 * tileAmount; // Adjust edge width based on tile amount\n               float edgeSharpness = 0.011 * tileAmount;\n\n               float outline = smoothstep(edgeWidth - edgeSharpness, edgeWidth, edgeDist);\n               float color_mix = mix(0.0, 0.3, outline); // Mix black outline with white fill\n\n               float flicker = (sin(u_time) * 0.05) + 1.0;\n               float sinshit = smoothstep(-3.0, 1.0, sin(uv.y * 3.));\n\n               col = vec4(vec3(0.0), color_mix);\n               col = mix(col, vec4(0., 0., 0., sinshit), 0.5 * flicker);\n\n               float specs = rand(uv.xy);\n               vec4 noise = vec4(0., 0., 0., specs);\n               col = mix(col, noise, 0.1);\n\n               gl_FragColor = col;\n\t\t}\n     ",f1,96,fe,3d);
            		}
HXLINE( 175)		if (::hx::IsNull( this->_hx___glVertexSource )) {
HXLINE( 177)			this->_hx___glVertexSource = HX_("attribute float openfl_Alpha;\n\t\tattribute vec4 openfl_ColorMultiplier;\n\t\tattribute vec4 openfl_ColorOffset;\n\t\tattribute vec4 openfl_Position;\n\t\tattribute vec2 openfl_TextureCoord;\n\n\t\tvarying float openfl_Alphav;\n\t\tvarying vec4 openfl_ColorMultiplierv;\n\t\tvarying vec4 openfl_ColorOffsetv;\n\t\tvarying vec2 openfl_TextureCoordv;\n\n\t\tuniform mat4 openfl_Matrix;\n\t\tuniform bool openfl_HasColorTransform;\n\t\tuniform vec2 openfl_TextureSize;\n\n\n\t\tvoid main(void) {\n\n\t\t\topenfl_Alphav = openfl_Alpha;\n\t\topenfl_TextureCoordv = openfl_TextureCoord;\n\n\t\tif (openfl_HasColorTransform) {\n\n\t\t\topenfl_ColorMultiplierv = openfl_ColorMultiplier;\n\t\t\topenfl_ColorOffsetv = openfl_ColorOffset / 255.0;\n\n\t\t}\n\n\t\tgl_Position = openfl_Matrix * openfl_Position;\n\n\n\t\t}",12,4b,6d,f3);
            		}
HXLINE(  56)		super::__construct(null());
HXLINE(  57)		this->set_elapsedTime(( (Float)(0) ));
HXLINE(   5)		this->_hx___isGenerated = true;
HXDLIN(   5)		this->_hx___initGL();
            	}

Dynamic VFDOverlay_obj::__CreateEmpty() { return new VFDOverlay_obj; }

void *VFDOverlay_obj::_hx_vtable = 0;

Dynamic VFDOverlay_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< VFDOverlay_obj > _hx_result = new VFDOverlay_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool VFDOverlay_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x497f668e) {
		if (inClassId<=(int)0x1efca5b6) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x1efca5b6;
		} else {
			return inClassId==(int)0x497f668e;
		}
	} else {
		return inClassId==(int)0x78d8d737;
	}
}

Float VFDOverlay_obj::set_elapsedTime(Float value){
            	HX_STACKFRAME(&_hx_pos_4b7809dfebecb1eb_8_set_elapsedTime)
HXLINE(   9)		this->u_time->value = ::Array_obj< Float >::__new(1)->init(0,value);
HXLINE(  10)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(VFDOverlay_obj,set_elapsedTime,return )

void VFDOverlay_obj::update(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_4b7809dfebecb1eb_61_update)
HXDLIN(  61)		this->set_elapsedTime((this->elapsedTime + elapsed));
            	}


HX_DEFINE_DYNAMIC_FUNC1(VFDOverlay_obj,update,(void))


::hx::ObjectPtr< VFDOverlay_obj > VFDOverlay_obj::__new() {
	::hx::ObjectPtr< VFDOverlay_obj > __this = new VFDOverlay_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< VFDOverlay_obj > VFDOverlay_obj::__alloc(::hx::Ctx *_hx_ctx) {
	VFDOverlay_obj *__this = (VFDOverlay_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(VFDOverlay_obj), true, "funkin.transition.VFDOverlay"));
	*(void **)__this = VFDOverlay_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

VFDOverlay_obj::VFDOverlay_obj()
{
}

void VFDOverlay_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(VFDOverlay);
	HX_MARK_MEMBER_NAME(elapsedTime,"elapsedTime");
	HX_MARK_MEMBER_NAME(u_time,"u_time");
	 ::openfl::display::GraphicsShader_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void VFDOverlay_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(elapsedTime,"elapsedTime");
	HX_VISIT_MEMBER_NAME(u_time,"u_time");
	 ::openfl::display::GraphicsShader_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val VFDOverlay_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		if (HX_FIELD_EQ(inName,"u_time") ) { return ::hx::Val( u_time ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"elapsedTime") ) { return ::hx::Val( elapsedTime ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"set_elapsedTime") ) { return ::hx::Val( set_elapsedTime_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val VFDOverlay_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"u_time") ) { u_time=inValue.Cast<  ::openfl::display::ShaderParameter_Float >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"elapsedTime") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_elapsedTime(inValue.Cast< Float >()) );elapsedTime=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void VFDOverlay_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("elapsedTime",69,5e,cd,c6));
	outFields->push(HX_("u_time",57,1f,cf,c7));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo VFDOverlay_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(VFDOverlay_obj,elapsedTime),HX_("elapsedTime",69,5e,cd,c6)},
	{::hx::fsObject /*  ::openfl::display::ShaderParameter_Float */ ,(int)offsetof(VFDOverlay_obj,u_time),HX_("u_time",57,1f,cf,c7)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *VFDOverlay_obj_sStaticStorageInfo = 0;
#endif

static ::String VFDOverlay_obj_sMemberFields[] = {
	HX_("elapsedTime",69,5e,cd,c6),
	HX_("set_elapsedTime",0c,93,7a,83),
	HX_("update",09,86,05,87),
	HX_("u_time",57,1f,cf,c7),
	::String(null()) };

::hx::Class VFDOverlay_obj::__mClass;

void VFDOverlay_obj::__register()
{
	VFDOverlay_obj _hx_dummy;
	VFDOverlay_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("funkin.transition.VFDOverlay",18,59,31,24);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(VFDOverlay_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< VFDOverlay_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = VFDOverlay_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = VFDOverlay_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace funkin
} // end namespace transition
