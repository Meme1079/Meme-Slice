// Generated by Haxe 4.3.7
#include <hxcpp.h>

#ifndef INCLUDED_flixel_addons_display_FlxRuntimeShader
#include <flixel/addons/display/FlxRuntimeShader.h>
#endif
#ifndef INCLUDED_flixel_graphics_tile_FlxGraphicsShader
#include <flixel/graphics/tile/FlxGraphicsShader.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_GraphicsShader
#include <openfl/display/GraphicsShader.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_Shader
#include <openfl/display/Shader.h>
#endif
#ifndef INCLUDED_openfl_display_ShaderParameter_Float
#include <openfl/display/ShaderParameter_Float.h>
#endif
#ifndef INCLUDED_shaders_experimental_RuntimePostEffectShader
#include <shaders/experimental/RuntimePostEffectShader.h>
#endif
#ifndef INCLUDED_shaders_experimental_RuntimeRainShader
#include <shaders/experimental/RuntimeRainShader.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_34823655358386b4_17_new,"shaders.experimental.RuntimeRainShader","new",0x3e6263dd,"shaders.experimental.RuntimeRainShader.new","shaders/experimental/RuntimeRainShader.hx",17,0xebe6c993)
HX_LOCAL_STACK_FRAME(_hx_pos_34823655358386b4_27_set_time,"shaders.experimental.RuntimeRainShader","set_time",0xfaed886d,"shaders.experimental.RuntimeRainShader.set_time","shaders/experimental/RuntimeRainShader.hx",27,0xebe6c993)
HX_LOCAL_STACK_FRAME(_hx_pos_34823655358386b4_33_set_spriteMode,"shaders.experimental.RuntimeRainShader","set_spriteMode",0x0b210668,"shaders.experimental.RuntimeRainShader.set_spriteMode","shaders/experimental/RuntimeRainShader.hx",33,0xebe6c993)
HX_LOCAL_STACK_FRAME(_hx_pos_34823655358386b4_42_set_scale,"shaders.experimental.RuntimeRainShader","set_scale",0xfd82e62a,"shaders.experimental.RuntimeRainShader.set_scale","shaders/experimental/RuntimeRainShader.hx",42,0xebe6c993)
HX_LOCAL_STACK_FRAME(_hx_pos_34823655358386b4_49_set_intensity,"shaders.experimental.RuntimeRainShader","set_intensity",0x3b062e53,"shaders.experimental.RuntimeRainShader.set_intensity","shaders/experimental/RuntimeRainShader.hx",49,0xebe6c993)
HX_LOCAL_STACK_FRAME(_hx_pos_34823655358386b4_56_set_puddleY,"shaders.experimental.RuntimeRainShader","set_puddleY",0xfb440fbb,"shaders.experimental.RuntimeRainShader.set_puddleY","shaders/experimental/RuntimeRainShader.hx",56,0xebe6c993)
HX_LOCAL_STACK_FRAME(_hx_pos_34823655358386b4_63_set_puddleScaleY,"shaders.experimental.RuntimeRainShader","set_puddleScaleY",0xa8594c0d,"shaders.experimental.RuntimeRainShader.set_puddleScaleY","shaders/experimental/RuntimeRainShader.hx",63,0xebe6c993)
HX_LOCAL_STACK_FRAME(_hx_pos_34823655358386b4_69_set_blurredScreen,"shaders.experimental.RuntimeRainShader","set_blurredScreen",0x120343b6,"shaders.experimental.RuntimeRainShader.set_blurredScreen","shaders/experimental/RuntimeRainShader.hx",69,0xebe6c993)
HX_LOCAL_STACK_FRAME(_hx_pos_34823655358386b4_75_set_mask,"shaders.experimental.RuntimeRainShader","set_mask",0xf646fd4c,"shaders.experimental.RuntimeRainShader.set_mask","shaders/experimental/RuntimeRainShader.hx",75,0xebe6c993)
HX_LOCAL_STACK_FRAME(_hx_pos_34823655358386b4_81_set_rainColor,"shaders.experimental.RuntimeRainShader","set_rainColor",0xc8dfaf0f,"shaders.experimental.RuntimeRainShader.set_rainColor","shaders/experimental/RuntimeRainShader.hx",81,0xebe6c993)
HX_LOCAL_STACK_FRAME(_hx_pos_34823655358386b4_87_set_lightMap,"shaders.experimental.RuntimeRainShader","set_lightMap",0x8e6247c6,"shaders.experimental.RuntimeRainShader.set_lightMap","shaders/experimental/RuntimeRainShader.hx",87,0xebe6c993)
HX_LOCAL_STACK_FRAME(_hx_pos_34823655358386b4_94_set_numLightsSwag,"shaders.experimental.RuntimeRainShader","set_numLightsSwag",0x16c1218d,"shaders.experimental.RuntimeRainShader.set_numLightsSwag","shaders/experimental/RuntimeRainShader.hx",94,0xebe6c993)
HX_LOCAL_STACK_FRAME(_hx_pos_34823655358386b4_105_update,"shaders.experimental.RuntimeRainShader","update",0x82b47eac,"shaders.experimental.RuntimeRainShader.update","shaders/experimental/RuntimeRainShader.hx",105,0xebe6c993)
HX_LOCAL_STACK_FRAME(_hx_pos_34823655358386b4_108___processGLData,"shaders.experimental.RuntimeRainShader","__processGLData",0x2e946a7b,"shaders.experimental.RuntimeRainShader.__processGLData","shaders/experimental/RuntimeRainShader.hx",108,0xebe6c993)
HX_LOCAL_STACK_FRAME(_hx_pos_34823655358386b4_124_addFloatUniform,"shaders.experimental.RuntimeRainShader","addFloatUniform",0x83da95b6,"shaders.experimental.RuntimeRainShader.addFloatUniform","shaders/experimental/RuntimeRainShader.hx",124,0xebe6c993)
HX_LOCAL_STACK_FRAME(_hx_pos_34823655358386b4_18_boot,"shaders.experimental.RuntimeRainShader","boot",0x4fcdfe15,"shaders.experimental.RuntimeRainShader.boot","shaders/experimental/RuntimeRainShader.hx",18,0xebe6c993)
namespace shaders{
namespace experimental{

void RuntimeRainShader_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_34823655358386b4_17_new)
HXLINE(  93)		this->numLightsSwag = 0;
HXLINE(  62)		this->puddleScaleY = ((Float)0);
HXLINE(  55)		this->puddleY = ((Float)0);
HXLINE(  48)		this->intensity = ((Float)0.5);
HXLINE(  41)		this->scale = ((Float)1);
HXLINE(  32)		this->spriteMode = false;
HXLINE(  26)		this->time = ((Float)1);
HXLINE( 183)		if (::hx::IsNull( this->_hx___glFragmentSource )) {
HXLINE( 185)			this->_hx___glFragmentSource = HX_("varying float openfl_Alphav;\n\t\tvarying vec4 openfl_ColorMultiplierv;\n\t\tvarying vec4 openfl_ColorOffsetv;\n\t\tvarying vec2 openfl_TextureCoordv;\n\n\t\tuniform bool openfl_HasColorTransform;\n\t\tuniform vec2 openfl_TextureSize;\n\t\tuniform sampler2D bitmap;\n\n\t\tuniform bool hasTransform;  // TODO: Is this still needed? Apparently, yes!\n\t\tuniform bool hasColorTransform;\n\t\tvec4 flixel_texture2D(sampler2D bitmap, vec2 coord)\n\t\t{\n\t\t\tvec4 color = texture2D(bitmap, coord);\n\t\t\tif (!(hasTransform || openfl_HasColorTransform))\n\t\t\t\treturn color;\n\t\t\t\n\t\t\tif (color.a == 0.0)\n\t\t\t\treturn vec4(0.0, 0.0, 0.0, 0.0);\n\t\t\t\n\t\t\tif (openfl_HasColorTransform || hasColorTransform)\n\t\t\t{\n\t\t\t\tcolor = vec4 (color.rgb / color.a, color.a);\n\t\t\t\tvec4 mult = vec4 (openfl_ColorMultiplierv.rgb, 1.0);\n\t\t\t\tcolor = clamp (openfl_ColorOffsetv + (color * mult), 0.0, 1.0);\n\t\t\t\t\n\t\t\t\tif (color.a == 0.0)\n\t\t\t\t\treturn vec4 (0.0, 0.0, 0.0, 0.0);\n\t\t\t\t\n\t\t\t\treturn vec4 (color.rgb * color.a * openfl_Alphav, color.a * openfl_Alphav);\n\t\t\t}\n\t\t\t\n\t\t\treturn color * openfl_Alphav;\n\t\t}\n\t\n\n\t\t// normalized screen coord\n\t\t//   (0, 0) is the top left of the window\n\t\t//   (1, 1) is the bottom right of the window\n\t\tuniform vec2 screenCoord;\n\n\t\t// equals (FlxG.width, FlxG.height)\n\t\tuniform vec2 uScreenResolution;\n\n\t\t// equals (camera.viewLeft, camera.viewTop, camera.viewRight, camera.viewBottom)\n\t\tuniform vec4 uCameraBounds;\n\n\t\t// equals (frame.left, frame.top, frame.right, frame.bottom)\n\t\tuniform vec4 uFrameBounds;\n\n\t\t// screen coord -> world coord conversion\n\t\t// returns world coord in px\n\t\tvec2 screenToWorld(vec2 screenCoord) {\n\t\t\tfloat left = uCameraBounds.x;\n\t\t\tfloat top = uCameraBounds.y;\n\t\t\tfloat right = uCameraBounds.z;\n\t\t\tfloat bottom = uCameraBounds.w;\n\t\t\tvec2 scale = vec2(right - left, bottom - top);\n\t\t\tvec2 offset = vec2(left, top);\n\t\t\treturn screenCoord * scale + offset;\n\t\t}\n\n\t\t// world coord -> screen coord conversion\n\t\t// returns normalized screen coord\n\t\tvec2 worldToScreen(vec2 worldCoord) {\n\t\t\tfloat left = uCameraBounds.x;\n\t\t\tfloat top = uCameraBounds.y;\n\t\t\tfloat right = uCameraBounds.z;\n\t\t\tfloat bottom = uCameraBounds.w;\n\t\t\tvec2 scale = vec2(right - left, bottom - top);\n\t\t\tvec2 offset = vec2(left, top);\n\t\t\treturn (worldCoord - offset) / scale;\n\t\t}\n\n\t\t// screen coord -> frame coord conversion\n\t\t// returns normalized frame coord\n\t\tvec2 screenToFrame(vec2 screenCoord) {\n\t\t\tfloat left = uFrameBounds.x;\n\t\t\tfloat top = uFrameBounds.y;\n\t\t\tfloat right = uFrameBounds.z;\n\t\t\tfloat bottom = uFrameBounds.w;\n\t\t\tfloat width = right - left;\n\t\t\tfloat height = bottom - top;\n\n\t\t\tfloat clampedX = clamp(screenCoord.x, left, right);\n\t\t\tfloat clampedY = clamp(screenCoord.y, top, bottom);\n\n\t\t\treturn vec2(\n\t\t\t\t(clampedX - left) / (width),\n\t\t\t\t(clampedY - top) / (height)\n\t\t\t);\n\t\t}\n\n\t\t// internally used to get the maximum `openfl_TextureCoordv`\n\t\tvec2 bitmapCoordScale() {\n\t\t\treturn openfl_TextureCoordv / screenCoord;\n\t\t}\n\n\t\t// internally used to compute bitmap coord\n\t\tvec2 screenToBitmap(vec2 screenCoord) {\n\t\t\treturn screenCoord * bitmapCoordScale();\n\t\t}\n\n\t\t// samples the frame buffer using a screen coord\n\t\tvec4 sampleBitmapScreen(vec2 screenCoord) {\n\t\t\treturn texture2D(bitmap, screenToBitmap(screenCoord));\n\t\t}\n\n\t\t// samples the frame buffer using a world coord\n\t\tvec4 sampleBitmapWorld(vec2 worldCoord) {\n\t\t\treturn sampleBitmapScreen(worldToScreen(worldCoord));\n\t\t}\n\t\n\n\n\t\tvoid main(void) {\n\n\t\t\tvec4 color = texture2D (bitmap, openfl_TextureCoordv);\n\n\t\tif (color.a == 0.0) {\n\n\t\t\tgl_FragColor = vec4 (0.0, 0.0, 0.0, 0.0);\n\n\t\t} else if (openfl_HasColorTransform) {\n\n\t\t\tcolor = vec4 (color.rgb / color.a, color.a);\n\n\t\t\tmat4 colorMultiplier = mat4 (0);\n\t\t\tcolorMultiplier[0][0] = openfl_ColorMultiplierv.x;\n\t\t\tcolorMultiplier[1][1] = openfl_ColorMultiplierv.y;\n\t\t\tcolorMultiplier[2][2] = openfl_ColorMultiplierv.z;\n\t\t\tcolorMultiplier[3][3] = 1.0; // openfl_ColorMultiplierv.w;\n\n\t\t\tcolor = clamp (openfl_ColorOffsetv + (color * colorMultiplier), 0.0, 1.0);\n\n\t\t\tif (color.a > 0.0) {\n\n\t\t\t\tgl_FragColor = vec4 (color.rgb * color.a * openfl_Alphav, color.a * openfl_Alphav);\n\n\t\t\t} else {\n\n\t\t\t\tgl_FragColor = vec4 (0.0, 0.0, 0.0, 0.0);\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tgl_FragColor = color * openfl_Alphav;\n\n\t\t}\n\n\t\tgl_FragColor = flixel_texture2D(bitmap, openfl_TextureCoordv);\n\t\n\n\n\t\t}",0c,49,a1,fc);
            		}
HXLINE( 175)		if (::hx::IsNull( this->_hx___glVertexSource )) {
HXLINE( 177)			this->_hx___glVertexSource = HX_("attribute float openfl_Alpha;\n\t\tattribute vec4 openfl_ColorMultiplier;\n\t\tattribute vec4 openfl_ColorOffset;\n\t\tattribute vec4 openfl_Position;\n\t\tattribute vec2 openfl_TextureCoord;\n\n\t\tvarying float openfl_Alphav;\n\t\tvarying vec4 openfl_ColorMultiplierv;\n\t\tvarying vec4 openfl_ColorOffsetv;\n\t\tvarying vec2 openfl_TextureCoordv;\n\n\t\tuniform mat4 openfl_Matrix;\n\t\tuniform bool openfl_HasColorTransform;\n\t\tuniform vec2 openfl_TextureSize;\n\n\t\tattribute float alpha;\n\t\tattribute vec4 colorMultiplier;\n\t\tattribute vec4 colorOffset;\n\t\tuniform bool hasColorTransform;\n\t\n\n\t\t// normalized screen coord\n\t\t//   (0, 0) is the top left of the window\n\t\t//   (1, 1) is the bottom right of the window\n\t\tuniform vec2 screenCoord;\n\t\n\n\n\t\tvoid main(void) {\n\n\t\t\topenfl_Alphav = openfl_Alpha;\n\t\topenfl_TextureCoordv = openfl_TextureCoord;\n\n\t\tif (openfl_HasColorTransform) {\n\n\t\t\topenfl_ColorMultiplierv = openfl_ColorMultiplier;\n\t\t\topenfl_ColorOffsetv = openfl_ColorOffset / 255.0;\n\n\t\t}\n\n\t\tgl_Position = openfl_Matrix * openfl_Position;\n\n\t\topenfl_Alphav = openfl_Alpha * alpha;\n\t\t\n\t\tif (hasColorTransform)\n\t\t{\n\t\t\tif (openfl_HasColorTransform)\n\t\t\t{\n\t\t\t\topenfl_ColorOffsetv = (openfl_ColorOffsetv * colorMultiplier) + (colorOffset / 255.0);\n\t\t\t\topenfl_ColorMultiplierv *= colorMultiplier;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\topenfl_ColorOffsetv = colorOffset / 255.0;\n\t\t\t\topenfl_ColorMultiplierv = colorMultiplier;\n\t\t\t}\n\t\t}\n\t\n\n\t\tscreenCoord = vec2(\n\t\t\topenfl_TextureCoord.x > 0.0 ? 1.0 : 0.0,\n\t\t\topenfl_TextureCoord.y > 0.0 ? 1.0 : 0.0\n\t\t);\n\t\n\n\n\t\t}",9f,18,71,5b);
            		}
HXLINE( 100)		super::__construct(null(),null());
HXLINE( 101)		this->set_rainColor(-10059572);
HXLINE(  17)		this->_hx___isGenerated = true;
HXDLIN(  17)		this->_hx___initGL();
            	}

Dynamic RuntimeRainShader_obj::__CreateEmpty() { return new RuntimeRainShader_obj; }

void *RuntimeRainShader_obj::_hx_vtable = 0;

Dynamic RuntimeRainShader_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< RuntimeRainShader_obj > _hx_result = new RuntimeRainShader_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool RuntimeRainShader_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x14221018) {
		if (inClassId<=(int)0x05d7fa7f) {
			if (inClassId<=(int)0x04f93fcd) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x04f93fcd;
			} else {
				return inClassId==(int)0x05d7fa7f;
			}
		} else {
			return inClassId==(int)0x14221018;
		}
	} else {
		if (inClassId<=(int)0x7517ccbe) {
			return inClassId==(int)0x1efca5b6 || inClassId==(int)0x7517ccbe;
		} else {
			return inClassId==(int)0x78d8d737;
		}
	}
}

Float RuntimeRainShader_obj::set_time(Float value){
            	HX_STACKFRAME(&_hx_pos_34823655358386b4_27_set_time)
HXLINE(  28)		this->setFloat(HX_("uTime",22,d7,b7,95),value);
HXLINE(  29)		return (this->time = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(RuntimeRainShader_obj,set_time,return )

bool RuntimeRainShader_obj::set_spriteMode(bool value){
            	HX_STACKFRAME(&_hx_pos_34823655358386b4_33_set_spriteMode)
HXLINE(  34)		this->setBool(HX_("uSpriteMode",dd,ca,46,ca),value);
HXLINE(  35)		return (this->spriteMode = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(RuntimeRainShader_obj,set_spriteMode,return )

Float RuntimeRainShader_obj::set_scale(Float value){
            	HX_STACKFRAME(&_hx_pos_34823655358386b4_42_set_scale)
HXLINE(  43)		this->setFloat(HX_("uScale",d5,75,bd,d3),value);
HXLINE(  44)		return (this->scale = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(RuntimeRainShader_obj,set_scale,return )

Float RuntimeRainShader_obj::set_intensity(Float value){
            	HX_STACKFRAME(&_hx_pos_34823655358386b4_49_set_intensity)
HXLINE(  50)		this->setFloat(HX_("uIntensity",7e,6f,b9,78),value);
HXLINE(  51)		return (this->intensity = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(RuntimeRainShader_obj,set_intensity,return )

Float RuntimeRainShader_obj::set_puddleY(Float value){
            	HX_STACKFRAME(&_hx_pos_34823655358386b4_56_set_puddleY)
HXLINE(  57)		this->setFloat(HX_("uPuddleY",26,20,02,c1),value);
HXLINE(  58)		return (this->puddleY = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(RuntimeRainShader_obj,set_puddleY,return )

Float RuntimeRainShader_obj::set_puddleScaleY(Float value){
            	HX_STACKFRAME(&_hx_pos_34823655358386b4_63_set_puddleScaleY)
HXLINE(  64)		this->setFloat(HX_("uPuddleScaleY",c2,d7,d0,cf),value);
HXLINE(  65)		return (this->puddleScaleY = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(RuntimeRainShader_obj,set_puddleScaleY,return )

 ::openfl::display::BitmapData RuntimeRainShader_obj::set_blurredScreen( ::openfl::display::BitmapData value){
            	HX_STACKFRAME(&_hx_pos_34823655358386b4_69_set_blurredScreen)
HXLINE(  70)		this->setSampler2D(HX_("uBlurredScreen",61,f6,25,73),value);
HXLINE(  71)		return (this->blurredScreen = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(RuntimeRainShader_obj,set_blurredScreen,return )

 ::openfl::display::BitmapData RuntimeRainShader_obj::set_mask( ::openfl::display::BitmapData value){
            	HX_STACKFRAME(&_hx_pos_34823655358386b4_75_set_mask)
HXLINE(  76)		this->setSampler2D(HX_("uMask",01,4c,11,91),value);
HXLINE(  77)		return (this->mask = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(RuntimeRainShader_obj,set_mask,return )

int RuntimeRainShader_obj::set_rainColor(int color){
            	HX_STACKFRAME(&_hx_pos_34823655358386b4_81_set_rainColor)
HXLINE(  82)		this->setFloatArray(HX_("uRainColor",3a,f0,92,06),::Array_obj< Float >::__new(3)->init(0,(( (Float)(((color >> 16) & 255)) ) / ( (Float)(255) )))->init(1,(( (Float)(((color >> 8) & 255)) ) / ( (Float)(255) )))->init(2,(( (Float)((color & 255)) ) / ( (Float)(255) ))));
HXLINE(  83)		return (this->rainColor = color);
            	}


HX_DEFINE_DYNAMIC_FUNC1(RuntimeRainShader_obj,set_rainColor,return )

 ::openfl::display::BitmapData RuntimeRainShader_obj::set_lightMap( ::openfl::display::BitmapData value){
            	HX_STACKFRAME(&_hx_pos_34823655358386b4_87_set_lightMap)
HXLINE(  88)		this->setSampler2D(HX_("uLightMap",fb,94,f2,ce),value);
HXLINE(  89)		return (this->lightMap = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(RuntimeRainShader_obj,set_lightMap,return )

int RuntimeRainShader_obj::set_numLightsSwag(int value){
            	HX_STACKFRAME(&_hx_pos_34823655358386b4_94_set_numLightsSwag)
HXLINE(  95)		this->setInt(HX_("numLights",c3,75,03,99),value);
HXLINE(  96)		return (this->numLightsSwag = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(RuntimeRainShader_obj,set_numLightsSwag,return )

void RuntimeRainShader_obj::update(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_34823655358386b4_105_update)
HXDLIN( 105)		this->set_time((this->time + elapsed));
            	}


HX_DEFINE_DYNAMIC_FUNC1(RuntimeRainShader_obj,update,(void))

void RuntimeRainShader_obj::_hx___processGLData(::String source,::String storageType){
            	HX_STACKFRAME(&_hx_pos_34823655358386b4_108___processGLData)
HXLINE( 109)		this->super::_hx___processGLData(source,storageType);
HXLINE( 110)		if ((storageType == HX_("uniform",34,41,64,b5))) {
HXLINE( 112)			::Array< ::Dynamic> _g = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 113)			{
HXLINE( 113)				int _g1 = 0;
HXDLIN( 113)				int _g2 = ::shaders::experimental::RuntimeRainShader_obj::MAX_LIGHTS;
HXDLIN( 113)				while((_g1 < _g2)){
HXLINE( 113)					_g1 = (_g1 + 1);
HXDLIN( 113)					int i = (_g1 - 1);
HXLINE( 115)					 ::openfl::display::ShaderParameter_Float _hx_tmp = this->addFloatUniform(((HX_("lights[",de,56,e3,19) + i) + HX_("].position",da,0a,69,8d)),2);
HXLINE( 116)					 ::openfl::display::ShaderParameter_Float _hx_tmp1 = this->addFloatUniform(((HX_("lights[",de,56,e3,19) + i) + HX_("].color",92,2e,13,ca)),3);
HXLINE( 114)					_g->push( ::Dynamic(::hx::Anon_obj::Create(3)
            						->setFixed(0,HX_("radius",52,d0,f6,b0),this->addFloatUniform(((HX_("lights[",de,56,e3,19) + i) + HX_("].radius",43,9c,25,f1)),1))
            						->setFixed(1,HX_("position",a9,a0,fa,ca),_hx_tmp)
            						->setFixed(2,HX_("color",63,71,5c,4a),_hx_tmp1)));
            				}
            			}
HXLINE( 112)			this->lights = _g;
            		}
            	}


 ::openfl::display::ShaderParameter_Float RuntimeRainShader_obj::addFloatUniform(::String name,int length){
            	HX_GC_STACKFRAME(&_hx_pos_34823655358386b4_124_addFloatUniform)
HXLINE( 125)		 ::openfl::display::ShaderParameter_Float res =  ::openfl::display::ShaderParameter_Float_obj::__alloc( HX_CTX );
HXLINE( 126)		res->set_name(name);
HXLINE( 127)		res->type = ::Array_obj< ::Dynamic>::__new(5)->init(0,null())->init(1,4)->init(2,5)->init(3,6)->init(4,7)->__get(length);
HXLINE( 128)		res->_hx___arrayLength = 1;
HXLINE( 129)		res->_hx___isFloat = true;
HXLINE( 130)		res->_hx___isUniform = true;
HXLINE( 131)		res->__length = length;
HXLINE( 132)		this->_hx___paramFloat->push(res);
HXLINE( 133)		return res;
            	}


HX_DEFINE_DYNAMIC_FUNC2(RuntimeRainShader_obj,addFloatUniform,return )

int RuntimeRainShader_obj::MAX_LIGHTS;


::hx::ObjectPtr< RuntimeRainShader_obj > RuntimeRainShader_obj::__new() {
	::hx::ObjectPtr< RuntimeRainShader_obj > __this = new RuntimeRainShader_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< RuntimeRainShader_obj > RuntimeRainShader_obj::__alloc(::hx::Ctx *_hx_ctx) {
	RuntimeRainShader_obj *__this = (RuntimeRainShader_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(RuntimeRainShader_obj), true, "shaders.experimental.RuntimeRainShader"));
	*(void **)__this = RuntimeRainShader_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

RuntimeRainShader_obj::RuntimeRainShader_obj()
{
}

void RuntimeRainShader_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(RuntimeRainShader);
	HX_MARK_MEMBER_NAME(lights,"lights");
	HX_MARK_MEMBER_NAME(time,"time");
	HX_MARK_MEMBER_NAME(spriteMode,"spriteMode");
	HX_MARK_MEMBER_NAME(scale,"scale");
	HX_MARK_MEMBER_NAME(intensity,"intensity");
	HX_MARK_MEMBER_NAME(puddleY,"puddleY");
	HX_MARK_MEMBER_NAME(puddleScaleY,"puddleScaleY");
	HX_MARK_MEMBER_NAME(blurredScreen,"blurredScreen");
	HX_MARK_MEMBER_NAME(mask,"mask");
	HX_MARK_MEMBER_NAME(rainColor,"rainColor");
	HX_MARK_MEMBER_NAME(lightMap,"lightMap");
	HX_MARK_MEMBER_NAME(numLightsSwag,"numLightsSwag");
	 ::shaders::experimental::RuntimePostEffectShader_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void RuntimeRainShader_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(lights,"lights");
	HX_VISIT_MEMBER_NAME(time,"time");
	HX_VISIT_MEMBER_NAME(spriteMode,"spriteMode");
	HX_VISIT_MEMBER_NAME(scale,"scale");
	HX_VISIT_MEMBER_NAME(intensity,"intensity");
	HX_VISIT_MEMBER_NAME(puddleY,"puddleY");
	HX_VISIT_MEMBER_NAME(puddleScaleY,"puddleScaleY");
	HX_VISIT_MEMBER_NAME(blurredScreen,"blurredScreen");
	HX_VISIT_MEMBER_NAME(mask,"mask");
	HX_VISIT_MEMBER_NAME(rainColor,"rainColor");
	HX_VISIT_MEMBER_NAME(lightMap,"lightMap");
	HX_VISIT_MEMBER_NAME(numLightsSwag,"numLightsSwag");
	 ::shaders::experimental::RuntimePostEffectShader_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val RuntimeRainShader_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"time") ) { return ::hx::Val( time ); }
		if (HX_FIELD_EQ(inName,"mask") ) { return ::hx::Val( mask ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"scale") ) { return ::hx::Val( scale ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"lights") ) { return ::hx::Val( lights ); }
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"puddleY") ) { return ::hx::Val( puddleY ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"set_time") ) { return ::hx::Val( set_time_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_mask") ) { return ::hx::Val( set_mask_dyn() ); }
		if (HX_FIELD_EQ(inName,"lightMap") ) { return ::hx::Val( lightMap ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"set_scale") ) { return ::hx::Val( set_scale_dyn() ); }
		if (HX_FIELD_EQ(inName,"intensity") ) { return ::hx::Val( intensity ); }
		if (HX_FIELD_EQ(inName,"rainColor") ) { return ::hx::Val( rainColor ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"spriteMode") ) { return ::hx::Val( spriteMode ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"set_puddleY") ) { return ::hx::Val( set_puddleY_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"puddleScaleY") ) { return ::hx::Val( puddleScaleY ); }
		if (HX_FIELD_EQ(inName,"set_lightMap") ) { return ::hx::Val( set_lightMap_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"set_intensity") ) { return ::hx::Val( set_intensity_dyn() ); }
		if (HX_FIELD_EQ(inName,"blurredScreen") ) { return ::hx::Val( blurredScreen ); }
		if (HX_FIELD_EQ(inName,"set_rainColor") ) { return ::hx::Val( set_rainColor_dyn() ); }
		if (HX_FIELD_EQ(inName,"numLightsSwag") ) { return ::hx::Val( numLightsSwag ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"set_spriteMode") ) { return ::hx::Val( set_spriteMode_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"__processGLData") ) { return ::hx::Val( _hx___processGLData_dyn() ); }
		if (HX_FIELD_EQ(inName,"addFloatUniform") ) { return ::hx::Val( addFloatUniform_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"set_puddleScaleY") ) { return ::hx::Val( set_puddleScaleY_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"set_blurredScreen") ) { return ::hx::Val( set_blurredScreen_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_numLightsSwag") ) { return ::hx::Val( set_numLightsSwag_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool RuntimeRainShader_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 10:
		if (HX_FIELD_EQ(inName,"MAX_LIGHTS") ) { outValue = ( MAX_LIGHTS ); return true; }
	}
	return false;
}

::hx::Val RuntimeRainShader_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"time") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_time(inValue.Cast< Float >()) );time=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"mask") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_mask(inValue.Cast<  ::openfl::display::BitmapData >()) );mask=inValue.Cast<  ::openfl::display::BitmapData >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"scale") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_scale(inValue.Cast< Float >()) );scale=inValue.Cast< Float >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"lights") ) { lights=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"puddleY") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_puddleY(inValue.Cast< Float >()) );puddleY=inValue.Cast< Float >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"lightMap") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_lightMap(inValue.Cast<  ::openfl::display::BitmapData >()) );lightMap=inValue.Cast<  ::openfl::display::BitmapData >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"intensity") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_intensity(inValue.Cast< Float >()) );intensity=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"rainColor") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_rainColor(inValue.Cast< int >()) );rainColor=inValue.Cast< int >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"spriteMode") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_spriteMode(inValue.Cast< bool >()) );spriteMode=inValue.Cast< bool >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"puddleScaleY") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_puddleScaleY(inValue.Cast< Float >()) );puddleScaleY=inValue.Cast< Float >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"blurredScreen") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_blurredScreen(inValue.Cast<  ::openfl::display::BitmapData >()) );blurredScreen=inValue.Cast<  ::openfl::display::BitmapData >(); return inValue; }
		if (HX_FIELD_EQ(inName,"numLightsSwag") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_numLightsSwag(inValue.Cast< int >()) );numLightsSwag=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool RuntimeRainShader_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 10:
		if (HX_FIELD_EQ(inName,"MAX_LIGHTS") ) { MAX_LIGHTS=ioValue.Cast< int >(); return true; }
	}
	return false;
}

void RuntimeRainShader_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("lights",dd,2a,02,e8));
	outFields->push(HX_("time",0d,cc,fc,4c));
	outFields->push(HX_("spriteMode",08,c2,ee,ed));
	outFields->push(HX_("scale",8a,ce,ce,78));
	outFields->push(HX_("intensity",b3,c6,dd,f4));
	outFields->push(HX_("puddleY",1b,d0,a2,cf));
	outFields->push(HX_("puddleScaleY",ad,2f,c5,26));
	outFields->push(HX_("blurredScreen",16,8c,fe,31));
	outFields->push(HX_("mask",ec,40,56,48));
	outFields->push(HX_("rainColor",6f,47,b7,82));
	outFields->push(HX_("lightMap",66,db,eb,8c));
	outFields->push(HX_("numLightsSwag",ed,69,bc,36));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo RuntimeRainShader_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(RuntimeRainShader_obj,lights),HX_("lights",dd,2a,02,e8)},
	{::hx::fsFloat,(int)offsetof(RuntimeRainShader_obj,time),HX_("time",0d,cc,fc,4c)},
	{::hx::fsBool,(int)offsetof(RuntimeRainShader_obj,spriteMode),HX_("spriteMode",08,c2,ee,ed)},
	{::hx::fsFloat,(int)offsetof(RuntimeRainShader_obj,scale),HX_("scale",8a,ce,ce,78)},
	{::hx::fsFloat,(int)offsetof(RuntimeRainShader_obj,intensity),HX_("intensity",b3,c6,dd,f4)},
	{::hx::fsFloat,(int)offsetof(RuntimeRainShader_obj,puddleY),HX_("puddleY",1b,d0,a2,cf)},
	{::hx::fsFloat,(int)offsetof(RuntimeRainShader_obj,puddleScaleY),HX_("puddleScaleY",ad,2f,c5,26)},
	{::hx::fsObject /*  ::openfl::display::BitmapData */ ,(int)offsetof(RuntimeRainShader_obj,blurredScreen),HX_("blurredScreen",16,8c,fe,31)},
	{::hx::fsObject /*  ::openfl::display::BitmapData */ ,(int)offsetof(RuntimeRainShader_obj,mask),HX_("mask",ec,40,56,48)},
	{::hx::fsInt,(int)offsetof(RuntimeRainShader_obj,rainColor),HX_("rainColor",6f,47,b7,82)},
	{::hx::fsObject /*  ::openfl::display::BitmapData */ ,(int)offsetof(RuntimeRainShader_obj,lightMap),HX_("lightMap",66,db,eb,8c)},
	{::hx::fsInt,(int)offsetof(RuntimeRainShader_obj,numLightsSwag),HX_("numLightsSwag",ed,69,bc,36)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo RuntimeRainShader_obj_sStaticStorageInfo[] = {
	{::hx::fsInt,(void *) &RuntimeRainShader_obj::MAX_LIGHTS,HX_("MAX_LIGHTS",78,da,04,18)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String RuntimeRainShader_obj_sMemberFields[] = {
	HX_("lights",dd,2a,02,e8),
	HX_("time",0d,cc,fc,4c),
	HX_("set_time",0a,e1,14,7b),
	HX_("spriteMode",08,c2,ee,ed),
	HX_("set_spriteMode",c5,32,04,84),
	HX_("scale",8a,ce,ce,78),
	HX_("set_scale",ed,16,c9,9f),
	HX_("intensity",b3,c6,dd,f4),
	HX_("set_intensity",96,7c,47,fb),
	HX_("puddleY",1b,d0,a2,cf),
	HX_("set_puddleY",3e,37,0a,60),
	HX_("puddleScaleY",ad,2f,c5,26),
	HX_("set_puddleScaleY",aa,09,a6,81),
	HX_("blurredScreen",16,8c,fe,31),
	HX_("set_blurredScreen",79,6f,dc,5b),
	HX_("mask",ec,40,56,48),
	HX_("set_mask",e9,55,6e,76),
	HX_("rainColor",6f,47,b7,82),
	HX_("set_rainColor",52,fd,20,89),
	HX_("lightMap",66,db,eb,8c),
	HX_("set_lightMap",e3,b2,fe,56),
	HX_("numLightsSwag",ed,69,bc,36),
	HX_("set_numLightsSwag",50,4d,9a,60),
	HX_("update",09,86,05,87),
	HX_("__processGLData",7e,0f,78,7c),
	HX_("addFloatUniform",b9,3a,be,d1),
	::String(null()) };

static void RuntimeRainShader_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(RuntimeRainShader_obj::MAX_LIGHTS,"MAX_LIGHTS");
};

#ifdef HXCPP_VISIT_ALLOCS
static void RuntimeRainShader_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(RuntimeRainShader_obj::MAX_LIGHTS,"MAX_LIGHTS");
};

#endif

::hx::Class RuntimeRainShader_obj::__mClass;

static ::String RuntimeRainShader_obj_sStaticFields[] = {
	HX_("MAX_LIGHTS",78,da,04,18),
	::String(null())
};

void RuntimeRainShader_obj::__register()
{
	RuntimeRainShader_obj _hx_dummy;
	RuntimeRainShader_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("shaders.experimental.RuntimeRainShader",6b,31,5a,ac);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &RuntimeRainShader_obj::__GetStatic;
	__mClass->mSetStaticField = &RuntimeRainShader_obj::__SetStatic;
	__mClass->mMarkFunc = RuntimeRainShader_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(RuntimeRainShader_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(RuntimeRainShader_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< RuntimeRainShader_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = RuntimeRainShader_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = RuntimeRainShader_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = RuntimeRainShader_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void RuntimeRainShader_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_34823655358386b4_18_boot)
HXDLIN(  18)		MAX_LIGHTS = 8;
            	}
}

} // end namespace shaders
} // end namespace experimental
