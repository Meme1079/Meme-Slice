// Generated by Haxe 4.3.7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_backend_ClientPrefs
#include <backend/ClientPrefs.h>
#endif
#ifndef INCLUDED_backend_DiscordClient
#include <backend/DiscordClient.h>
#endif
#ifndef INCLUDED_backend_Mods
#include <backend/Mods.h>
#endif
#ifndef INCLUDED_backend_MusicBeatState
#include <backend/MusicBeatState.h>
#endif
#ifndef INCLUDED_backend_MusicBeatSubstate
#include <backend/MusicBeatSubstate.h>
#endif
#ifndef INCLUDED_backend_Paths
#include <backend/Paths.h>
#endif
#ifndef INCLUDED_backend_PsychCamera
#include <backend/PsychCamera.h>
#endif
#ifndef INCLUDED_backend_SaveVariables
#include <backend/SaveVariables.h>
#endif
#ifndef INCLUDED_backend_ui_PsychUIBox
#include <backend/ui/PsychUIBox.h>
#endif
#ifndef INCLUDED_backend_ui_PsychUIButton
#include <backend/ui/PsychUIButton.h>
#endif
#ifndef INCLUDED_backend_ui_PsychUICheckBox
#include <backend/ui/PsychUICheckBox.h>
#endif
#ifndef INCLUDED_backend_ui_PsychUIDropDownMenu
#include <backend/ui/PsychUIDropDownMenu.h>
#endif
#ifndef INCLUDED_backend_ui_PsychUIEvent
#include <backend/ui/PsychUIEvent.h>
#endif
#ifndef INCLUDED_backend_ui_PsychUIInputText
#include <backend/ui/PsychUIInputText.h>
#endif
#ifndef INCLUDED_backend_ui_PsychUINumericStepper
#include <backend/ui/PsychUINumericStepper.h>
#endif
#ifndef INCLUDED_backend_ui_PsychUISlider
#include <backend/ui/PsychUISlider.h>
#endif
#ifndef INCLUDED_backend_ui_PsychUITab
#include <backend/ui/PsychUITab.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_FlxSubState
#include <flixel/FlxSubState.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxAnimation
#include <flixel/animation/FlxAnimation.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxAnimationController
#include <flixel/animation/FlxAnimationController.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxBaseAnimation
#include <flixel/animation/FlxBaseAnimation.h>
#endif
#ifndef INCLUDED_flixel_graphics_FlxGraphic
#include <flixel/graphics/FlxGraphic.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxAtlasFrames
#include <flixel/graphics/frames/FlxAtlasFrames.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFrame
#include <flixel/graphics/frames/FlxFrame.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFramesCollection
#include <flixel/graphics/frames/FlxFramesCollection.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedContainer
#include <flixel/group/FlxTypedContainer.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedSpriteGroup
#include <flixel/group/FlxTypedSpriteGroup.h>
#endif
#ifndef INCLUDED_flixel_input_FlxBaseKeyList
#include <flixel/input/FlxBaseKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_FlxInput
#include <flixel/input/FlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_FlxKeyManager
#include <flixel/input/FlxKeyManager.h>
#endif
#ifndef INCLUDED_flixel_input_FlxPointer
#include <flixel/input/FlxPointer.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInput
#include <flixel/input/IFlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInputManager
#include <flixel/input/IFlxInputManager.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyList
#include <flixel/input/keyboard/FlxKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyboard
#include <flixel/input/keyboard/FlxKeyboard.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouse
#include <flixel/input/mouse/FlxMouse.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouseButton
#include <flixel/input/mouse/FlxMouseButton.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_math_FlxMath
#include <flixel/math/FlxMath.h>
#endif
#ifndef INCLUDED_flixel_sound_FlxSound
#include <flixel/sound/FlxSound.h>
#endif
#ifndef INCLUDED_flixel_sound_FlxSoundGroup
#include <flixel/sound/FlxSoundGroup.h>
#endif
#ifndef INCLUDED_flixel_system_debug_log_LogStyle
#include <flixel/system/debug/log/LogStyle.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_CameraFrontEnd
#include <flixel/system/frontEnds/CameraFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_LogFrontEnd
#include <flixel/system/frontEnds/LogFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_SoundFrontEnd
#include <flixel/system/frontEnds/SoundFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_text_FlxText
#include <flixel/text/FlxText.h>
#endif
#ifndef INCLUDED_flixel_text_FlxTextBorderStyle
#include <flixel/text/FlxTextBorderStyle.h>
#endif
#ifndef INCLUDED_flixel_text_FlxTextFormat
#include <flixel/text/FlxTextFormat.h>
#endif
#ifndef INCLUDED_flixel_util_FlxDestroyUtil
#include <flixel/util/FlxDestroyUtil.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool
#include <flixel/util/FlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_flixel_util__FlxColor_FlxColor_Impl_
#include <flixel/util/_FlxColor/FlxColor_Impl_.h>
#endif
#ifndef INCLUDED_flxanimate_FlxAnimate
#include <flxanimate/FlxAnimate.h>
#endif
#ifndef INCLUDED_flxanimate_PsychFlxAnimate
#include <flxanimate/PsychFlxAnimate.h>
#endif
#ifndef INCLUDED_flxanimate_animate_FlxAnim
#include <flxanimate/animate/FlxAnim.h>
#endif
#ifndef INCLUDED_flxanimate_animate_FlxElement
#include <flxanimate/animate/FlxElement.h>
#endif
#ifndef INCLUDED_flxanimate_animate_FlxSymbol
#include <flxanimate/animate/FlxSymbol.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_haxe_format_JsonPrinter
#include <haxe/format/JsonPrinter.h>
#endif
#ifndef INCLUDED_objects_BGSprite
#include <objects/BGSprite.h>
#endif
#ifndef INCLUDED_objects_Bar
#include <objects/Bar.h>
#endif
#ifndef INCLUDED_objects_Character
#include <objects/Character.h>
#endif
#ifndef INCLUDED_objects_HealthIcon
#include <objects/HealthIcon.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_events_ErrorEvent
#include <openfl/events/ErrorEvent.h>
#endif
#ifndef INCLUDED_openfl_events_Event
#include <openfl/events/Event.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IOErrorEvent
#include <openfl/events/IOErrorEvent.h>
#endif
#ifndef INCLUDED_openfl_events_TextEvent
#include <openfl/events/TextEvent.h>
#endif
#ifndef INCLUDED_openfl_geom_ColorTransform
#include <openfl/geom/ColorTransform.h>
#endif
#ifndef INCLUDED_openfl_media_Sound
#include <openfl/media/Sound.h>
#endif
#ifndef INCLUDED_openfl_net_FileReference
#include <openfl/net/FileReference.h>
#endif
#ifndef INCLUDED_states_PlayState
#include <states/PlayState.h>
#endif
#ifndef INCLUDED_states_editors_CharacterEditorState
#include <states/editors/CharacterEditorState.h>
#endif
#ifndef INCLUDED_states_editors_MasterEditorMenu
#include <states/editors/MasterEditorMenu.h>
#endif
#ifndef INCLUDED_states_editors_content_BasePrompt
#include <states/editors/content/BasePrompt.h>
#endif
#ifndef INCLUDED_states_editors_content_ExitConfirmationPrompt
#include <states/editors/content/ExitConfirmationPrompt.h>
#endif
#ifndef INCLUDED_states_editors_content_Prompt
#include <states/editors/content/Prompt.h>
#endif
#ifndef INCLUDED_states_editors_content_PsychJsonPrinter
#include <states/editors/content/PsychJsonPrinter.h>
#endif
#ifndef INCLUDED_sys_FileSystem
#include <sys/FileSystem.h>
#endif
#ifndef INCLUDED_sys_io_File
#include <sys/io/File.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_8fcf73527616c70a_19_new,"states.editors.CharacterEditorState","new",0x3d735681,"states.editors.CharacterEditorState.new","states/editors/CharacterEditorState.hx",19,0x7f042b4d)
static const Float _hx_array_data_788c020f_1[] = {
	(Float)0,(Float)0,
};
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_68_create,"states.editors.CharacterEditorState","create",0xa4b7ab7b,"states.editors.CharacterEditorState.create","states/editors/CharacterEditorState.hx",68,0x7f042b4d)
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_169_addHelpScreen,"states.editors.CharacterEditorState","addHelpScreen",0x13150bef,"states.editors.CharacterEditorState.addHelpScreen","states/editors/CharacterEditorState.hx",169,0x7f042b4d)
static const ::String _hx_array_data_788c020f_5[] = {
	HX_("CAMERA",a5,f2,0e,6a),HX_("E/Q - Camera Zoom In/Out",a2,41,5f,1d),HX_("J/K/L/I - Move Camera",be,82,c9,cf),HX_("R - Reset Camera Zoom",fc,06,e0,e9),HX_("",00,00,00,00),HX_("CHARACTER",89,4b,2a,3d),HX_("Ctrl + R - Reset Current Offset",d6,1c,dc,bf),HX_("Ctrl + C - Copy Current Offset",2b,cb,75,2f),HX_("Ctrl + V - Paste Copied Offset on Current Animation",21,71,69,77),HX_("Ctrl + Z - Undo Last Paste or Reset",30,a3,b7,fc),HX_("W/S - Previous/Next Animation",97,59,cc,8a),HX_("Space - Replay Animation",58,ad,06,9d),HX_("Arrow Keys/Mouse & Right Click - Move Offset",7a,08,7f,a7),HX_("A/D - Frame Advance (Back/Forward)",72,40,99,d5),HX_("",00,00,00,00),HX_("OTHER",b0,9e,64,b4),HX_("F12 - Toggle Silhouettes",3b,2d,93,b9),HX_("Hold Shift - Move Offsets 10x faster and Camera 4x faster",46,ee,14,96),HX_("Hold Control - Move camera 4x slower",47,01,f6,33),
};
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_220_addCharacter,"states.editors.CharacterEditorState","addCharacter",0xac7f2b07,"states.editors.CharacterEditorState.addCharacter","states/editors/CharacterEditorState.hx",220,0x7f042b4d)
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_248_makeUIMenu,"states.editors.CharacterEditorState","makeUIMenu",0x5101c680,"states.editors.CharacterEditorState.makeUIMenu","states/editors/CharacterEditorState.hx",248,0x7f042b4d)
static const ::String _hx_array_data_788c020f_9[] = {
	HX_("Ghost",2f,ff,85,26),HX_("Settings",03,39,ef,64),
};
static const ::String _hx_array_data_788c020f_10[] = {
	HX_("Animations",0f,39,cd,79),HX_("Character",89,bb,a4,e3),
};
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_274_addGhostUI,"states.editors.CharacterEditorState","addGhostUI",0xe99ea741,"states.editors.CharacterEditorState.addGhostUI","states/editors/CharacterEditorState.hx",274,0x7f042b4d)
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_344_addGhostUI,"states.editors.CharacterEditorState","addGhostUI",0xe99ea741,"states.editors.CharacterEditorState.addGhostUI","states/editors/CharacterEditorState.hx",344,0x7f042b4d)
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_358_addGhostUI,"states.editors.CharacterEditorState","addGhostUI",0xe99ea741,"states.editors.CharacterEditorState.addGhostUI","states/editors/CharacterEditorState.hx",358,0x7f042b4d)
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_270_addGhostUI,"states.editors.CharacterEditorState","addGhostUI",0xe99ea741,"states.editors.CharacterEditorState.addGhostUI","states/editors/CharacterEditorState.hx",270,0x7f042b4d)
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_381_addSettingsUI,"states.editors.CharacterEditorState","addSettingsUI",0xe03928d9,"states.editors.CharacterEditorState.addSettingsUI","states/editors/CharacterEditorState.hx",381,0x7f042b4d)
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_389_addSettingsUI,"states.editors.CharacterEditorState","addSettingsUI",0xe03928d9,"states.editors.CharacterEditorState.addSettingsUI","states/editors/CharacterEditorState.hx",389,0x7f042b4d)
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_397_addSettingsUI,"states.editors.CharacterEditorState","addSettingsUI",0xe03928d9,"states.editors.CharacterEditorState.addSettingsUI","states/editors/CharacterEditorState.hx",397,0x7f042b4d)
static const int _hx_array_data_788c020f_19[] = {
	(int)0,(int)0,
};
static const int _hx_array_data_788c020f_20[] = {
	(int)0,(int)0,
};
static const int _hx_array_data_788c020f_21[] = {
	(int)0,(int)0,
};
static const int _hx_array_data_788c020f_22[] = {
	(int)0,(int)0,
};
static const int _hx_array_data_788c020f_23[] = {
	(int)0,(int)0,
};
static const Float _hx_array_data_788c020f_24[] = {
	(Float)0,(Float)0,
};
static const int _hx_array_data_788c020f_25[] = {
	(int)161,(int)161,(int)161,
};
static const Float _hx_array_data_788c020f_26[] = {
	(Float)0,(Float)0,
};
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_435_addSettingsUI,"states.editors.CharacterEditorState","addSettingsUI",0xe03928d9,"states.editors.CharacterEditorState.addSettingsUI","states/editors/CharacterEditorState.hx",435,0x7f042b4d)
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_375_addSettingsUI,"states.editors.CharacterEditorState","addSettingsUI",0xe03928d9,"states.editors.CharacterEditorState.addSettingsUI","states/editors/CharacterEditorState.hx",375,0x7f042b4d)
static const ::String _hx_array_data_788c020f_29[] = {
	HX_("",00,00,00,00),
};
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_485_addAnimationsUI,"states.editors.CharacterEditorState","addAnimationsUI",0xdfb6f865,"states.editors.CharacterEditorState.addAnimationsUI","states/editors/CharacterEditorState.hx",485,0x7f042b4d)
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_496_addAnimationsUI,"states.editors.CharacterEditorState","addAnimationsUI",0xdfb6f865,"states.editors.CharacterEditorState.addAnimationsUI","states/editors/CharacterEditorState.hx",496,0x7f042b4d)
static const int _hx_array_data_788c020f_39[] = {
	(int)0,(int)0,
};
static const int _hx_array_data_788c020f_40[] = {
	(int)0,(int)0,
};
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_556_addAnimationsUI,"states.editors.CharacterEditorState","addAnimationsUI",0xdfb6f865,"states.editors.CharacterEditorState.addAnimationsUI","states/editors/CharacterEditorState.hx",556,0x7f042b4d)
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_476_addAnimationsUI,"states.editors.CharacterEditorState","addAnimationsUI",0xdfb6f865,"states.editors.CharacterEditorState.addAnimationsUI","states/editors/CharacterEditorState.hx",476,0x7f042b4d)
static const ::String _hx_array_data_788c020f_43[] = {
	HX_("",00,00,00,00),
};
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_620_addCharacterUI,"states.editors.CharacterEditorState","addCharacterUI",0x2ae5851b,"states.editors.CharacterEditorState.addCharacterUI","states/editors/CharacterEditorState.hx",620,0x7f042b4d)
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_630_addCharacterUI,"states.editors.CharacterEditorState","addCharacterUI",0x2ae5851b,"states.editors.CharacterEditorState.addCharacterUI","states/editors/CharacterEditorState.hx",630,0x7f042b4d)
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_649_addCharacterUI,"states.editors.CharacterEditorState","addCharacterUI",0x2ae5851b,"states.editors.CharacterEditorState.addCharacterUI","states/editors/CharacterEditorState.hx",649,0x7f042b4d)
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_656_addCharacterUI,"states.editors.CharacterEditorState","addCharacterUI",0x2ae5851b,"states.editors.CharacterEditorState.addCharacterUI","states/editors/CharacterEditorState.hx",656,0x7f042b4d)
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_671_addCharacterUI,"states.editors.CharacterEditorState","addCharacterUI",0x2ae5851b,"states.editors.CharacterEditorState.addCharacterUI","states/editors/CharacterEditorState.hx",671,0x7f042b4d)
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_615_addCharacterUI,"states.editors.CharacterEditorState","addCharacterUI",0x2ae5851b,"states.editors.CharacterEditorState.addCharacterUI","states/editors/CharacterEditorState.hx",615,0x7f042b4d)
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_705_UIEvent,"states.editors.CharacterEditorState","UIEvent",0x7233a7c7,"states.editors.CharacterEditorState.UIEvent","states/editors/CharacterEditorState.hx",705,0x7f042b4d)
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_792_reloadCharacterImage,"states.editors.CharacterEditorState","reloadCharacterImage",0xc82104ea,"states.editors.CharacterEditorState.reloadCharacterImage","states/editors/CharacterEditorState.hx",792,0x7f042b4d)
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_836_reloadCharacterOptions,"states.editors.CharacterEditorState","reloadCharacterOptions",0xf4a5daad,"states.editors.CharacterEditorState.reloadCharacterOptions","states/editors/CharacterEditorState.hx",836,0x7f042b4d)
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_861_update,"states.editors.CharacterEditorState","update",0xafadca88,"states.editors.CharacterEditorState.update","states/editors/CharacterEditorState.hx",861,0x7f042b4d)
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_1072_loadBG,"states.editors.CharacterEditorState","loadBG",0x81176dea,"states.editors.CharacterEditorState.loadBG","states/editors/CharacterEditorState.hx",1072,0x7f042b4d)
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_1099_updatePointerPos,"states.editors.CharacterEditorState","updatePointerPos",0x9708f17f,"states.editors.CharacterEditorState.updatePointerPos","states/editors/CharacterEditorState.hx",1099,0x7f042b4d)
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_1124_updateHealthBar,"states.editors.CharacterEditorState","updateHealthBar",0x413e0eef,"states.editors.CharacterEditorState.updateHealthBar","states/editors/CharacterEditorState.hx",1124,0x7f042b4d)
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_1136_updatePresence,"states.editors.CharacterEditorState","updatePresence",0x7250a0e3,"states.editors.CharacterEditorState.updatePresence","states/editors/CharacterEditorState.hx",1136,0x7f042b4d)
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_1141_reloadAnimList,"states.editors.CharacterEditorState","reloadAnimList",0x40e19707,"states.editors.CharacterEditorState.reloadAnimList","states/editors/CharacterEditorState.hx",1141,0x7f042b4d)
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_1151_updateText,"states.editors.CharacterEditorState","updateText",0x01aca755,"states.editors.CharacterEditorState.updateText","states/editors/CharacterEditorState.hx",1151,0x7f042b4d)
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_1171_updateCharacterPositions,"states.editors.CharacterEditorState","updateCharacterPositions",0x6745eb69,"states.editors.CharacterEditorState.updateCharacterPositions","states/editors/CharacterEditorState.hx",1171,0x7f042b4d)
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_1182_predictCharacterIsNotPlayer,"states.editors.CharacterEditorState","predictCharacterIsNotPlayer",0x59a5913b,"states.editors.CharacterEditorState.predictCharacterIsNotPlayer","states/editors/CharacterEditorState.hx",1182,0x7f042b4d)
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_1187_addAnimation,"states.editors.CharacterEditorState","addAnimation",0xb5e23e62,"states.editors.CharacterEditorState.addAnimation","states/editors/CharacterEditorState.hx",1187,0x7f042b4d)
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_1209_newAnim,"states.editors.CharacterEditorState","newAnim",0x5ad1dd32,"states.editors.CharacterEditorState.newAnim","states/editors/CharacterEditorState.hx",1209,0x7f042b4d)
static const int _hx_array_data_788c020f_73[] = {
	(int)0,(int)0,
};
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_1220_reloadCharacterDropDown,"states.editors.CharacterEditorState","reloadCharacterDropDown",0xe6135e02,"states.editors.CharacterEditorState.reloadCharacterDropDown","states/editors/CharacterEditorState.hx",1220,0x7f042b4d)
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_1237_reloadAnimationDropDown,"states.editors.CharacterEditorState","reloadAnimationDropDown",0x7111c45d,"states.editors.CharacterEditorState.reloadAnimationDropDown","states/editors/CharacterEditorState.hx",1237,0x7f042b4d)
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_1248_onSaveComplete,"states.editors.CharacterEditorState","onSaveComplete",0x928f0854,"states.editors.CharacterEditorState.onSaveComplete","states/editors/CharacterEditorState.hx",1248,0x7f042b4d)
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_1261_onSaveCancel,"states.editors.CharacterEditorState","onSaveCancel",0x448a4855,"states.editors.CharacterEditorState.onSaveCancel","states/editors/CharacterEditorState.hx",1261,0x7f042b4d)
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_1273_onSaveError,"states.editors.CharacterEditorState","onSaveError",0xa64dc54d,"states.editors.CharacterEditorState.onSaveError","states/editors/CharacterEditorState.hx",1273,0x7f042b4d)
HX_LOCAL_STACK_FRAME(_hx_pos_8fcf73527616c70a_1282_saveCharacter,"states.editors.CharacterEditorState","saveCharacter",0xe93b3a0d,"states.editors.CharacterEditorState.saveCharacter","states/editors/CharacterEditorState.hx",1282,0x7f042b4d)
static const ::String _hx_array_data_788c020f_88[] = {
	HX_("offsets",80,09,65,d7),HX_("position",a9,a0,fa,ca),HX_("healthbar_colors",78,d9,40,40),HX_("camera_position",c3,d4,4a,56),HX_("indices",27,47,54,e3),
};
namespace states{
namespace editors{

void CharacterEditorState_obj::__construct(::String _hx_char,::hx::Null< bool >  __o_goToPlayState){
            		bool goToPlayState = __o_goToPlayState.Default(true);
            	HX_GC_STACKFRAME(&_hx_pos_8fcf73527616c70a_19_new)
HXLINE(1219)		this->characterList = ::Array_obj< ::String >::__new(0);
HXLINE(1070)		this->assetFolder = HX_("week1",bd,95,be,c7);
HXLINE( 859)		this->undoOffsets = null();
HXLINE( 858)		this->holdingFrameElapsed = ((Float)0);
HXLINE( 857)		this->holdingFrameTime = ((Float)0);
HXLINE( 856)		this->holdingArrowsElapsed = ((Float)0);
HXLINE( 855)		this->holdingArrowsTime = ((Float)0);
HXLINE( 268)		this->ghostAlpha = ((Float)0.6);
HXLINE(  56)		this->selectedFormat =  ::flixel::text::FlxTextFormat_obj::__alloc( HX_CTX ,-16711936,null(),null(),null(),null());
HXLINE(  54)		this->unsavedProgress = false;
HXLINE(  46)		this->curAnim = 0;
HXLINE(  44)		this->anims = null();
HXLINE(  42)		this->_goToPlayState = true;
HXLINE(  41)		this->_char = null();
HXLINE(  40)		this->copiedOffset = ::Array_obj< Float >::fromData( _hx_array_data_788c020f_1,2);
HXLINE(  30)		 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(( (Float)(0) ),( (Float)(0) ));
HXDLIN(  30)		point->_inPool = false;
HXDLIN(  30)		 ::flixel::math::FlxBasePoint point1 = point;
HXDLIN(  30)		point1->_weak = true;
HXDLIN(  30)		this->bfPosition = point1;
HXLINE(  29)		 ::flixel::math::FlxBasePoint point2 = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(( (Float)(0) ),( (Float)(0) ));
HXDLIN(  29)		point2->_inPool = false;
HXDLIN(  29)		 ::flixel::math::FlxBasePoint point11 = point2;
HXDLIN(  29)		point11->_weak = true;
HXDLIN(  29)		this->dadPosition = point11;
HXLINE(  26)		this->isAnimateSprite = false;
HXLINE(  60)		this->_char = _hx_char;
HXLINE(  61)		this->_goToPlayState = goToPlayState;
HXLINE(  62)		if (::hx::IsNull( this->_char )) {
HXLINE(  62)			this->_char = ::objects::Character_obj::DEFAULT_CHARACTER;
            		}
HXLINE(  64)		super::__construct();
            	}

Dynamic CharacterEditorState_obj::__CreateEmpty() { return new CharacterEditorState_obj; }

void *CharacterEditorState_obj::_hx_vtable = 0;

Dynamic CharacterEditorState_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< CharacterEditorState_obj > _hx_result = new CharacterEditorState_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool CharacterEditorState_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x563293a6) {
		if (inClassId<=(int)0x53aaab8a) {
			if (inClassId<=(int)0x1f7e1d37) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x1f7e1d37;
			} else {
				return inClassId==(int)0x53aaab8a;
			}
		} else {
			return inClassId==(int)0x563293a6;
		}
	} else {
		if (inClassId<=(int)0x7c795c9f) {
			return inClassId==(int)0x62817b24 || inClassId==(int)0x7c795c9f;
		} else {
			return inClassId==(int)0x7ccf8994;
		}
	}
}

static ::backend::ui::PsychUIEvent_obj _hx_states_editors_CharacterEditorState__hx_backend_ui_PsychUIEvent= {
	( void (::hx::Object::*)(::String, ::Dynamic))&::states::editors::CharacterEditorState_obj::UIEvent,
};

void *CharacterEditorState_obj::_hx_getInterface(int inHash) {
	switch(inHash) {
		case (int)0x768fb553: return &_hx_states_editors_CharacterEditorState__hx_backend_ui_PsychUIEvent;
	}
	return super::_hx_getInterface(inHash);
}

void CharacterEditorState_obj::create(){
            	HX_GC_STACKFRAME(&_hx_pos_8fcf73527616c70a_68_create)
HXLINE(  69)		::backend::Paths_obj::clearStoredMemory();
HXLINE(  70)		::backend::Paths_obj::clearUnusedMemory();
HXLINE(  72)		{
HXLINE(  72)			 ::flixel::sound::FlxSound _this = ::flixel::FlxG_obj::sound->music;
HXDLIN(  72)			_this->cleanup(_this->autoDestroy,true);
            		}
HXLINE(  73)		this->camEditor = this->initPsychCamera();
HXLINE(  75)		this->camHUD =  ::flixel::FlxCamera_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null());
HXLINE(  76)		{
HXLINE(  76)			 ::flixel::FlxCamera _hx_tmp = this->camHUD;
HXDLIN(  76)			_hx_tmp->bgColor = (_hx_tmp->bgColor & 16777215);
HXDLIN(  76)			 ::flixel::FlxCamera _hx_tmp1 = this->camHUD;
HXDLIN(  76)			_hx_tmp1->bgColor = (_hx_tmp1->bgColor | 0);
            		}
HXLINE(  77)		::flixel::FlxG_obj::cameras->add(this->camHUD,false).StaticCast<  ::flixel::FlxCamera >();
HXLINE(  79)		{
HXLINE(  79)			::String lastLoaded = ::backend::Paths_obj::currentLevel;
HXDLIN(  79)			::backend::Paths_obj::currentLevel = this->assetFolder;
HXDLIN(  79)			 ::objects::BGSprite bg =  ::objects::BGSprite_obj::__alloc( HX_CTX ,HX_("stageback",e5,7b,3b,06),-600,-200,((Float)0.9),((Float)0.9),null(),null());
HXDLIN(  79)			this->add(bg);
HXDLIN(  79)			 ::objects::BGSprite stageFront =  ::objects::BGSprite_obj::__alloc( HX_CTX ,HX_("stagefront",2b,fd,b0,c6),-650,600,((Float)0.9),((Float)0.9),null(),null());
HXDLIN(  79)			stageFront->setGraphicSize(::Std_obj::_hx_int((stageFront->get_width() * ((Float)1.1))),null());
HXDLIN(  79)			stageFront->updateHitbox();
HXDLIN(  79)			this->add(stageFront);
HXDLIN(  79)			{
HXLINE(  79)				 ::flixel::math::FlxBasePoint this1 = this->dadPosition;
HXDLIN(  79)				this1->set_x(( (Float)(100) ));
HXDLIN(  79)				this1->set_y(( (Float)(100) ));
            			}
HXDLIN(  79)			{
HXLINE(  79)				 ::flixel::math::FlxBasePoint this2 = this->bfPosition;
HXDLIN(  79)				this2->set_x(( (Float)(770) ));
HXDLIN(  79)				this2->set_y(( (Float)(100) ));
            			}
HXDLIN(  79)			::backend::Paths_obj::currentLevel = lastLoaded;
            		}
HXLINE(  81)		this->silhouettes =  ::flixel::group::FlxTypedSpriteGroup_obj::__alloc( HX_CTX ,null(),null(),null());
HXLINE(  82)		this->add(this->silhouettes);
HXLINE(  84)		 ::flixel::FlxSprite dad =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,this->dadPosition->x,this->dadPosition->y,null());
HXDLIN(  84)		 ::flixel::FlxSprite dad1 = dad->loadGraphic(::backend::Paths_obj::image(HX_("editors/silhouetteDad",66,2e,37,60),null(),null()),null(),null(),null(),null(),null());
HXLINE(  85)		dad1->set_antialiasing(::backend::ClientPrefs_obj::data->antialiasing);
HXLINE(  86)		dad1->set_active(false);
HXLINE(  87)		{
HXLINE(  87)			 ::flixel::math::FlxBasePoint this3 = dad1->offset;
HXDLIN(  87)			this3->set_x(( (Float)(-4) ));
HXDLIN(  87)			this3->set_y(( (Float)(1) ));
            		}
HXLINE(  88)		this->silhouettes->add(dad1).StaticCast<  ::flixel::FlxSprite >();
HXLINE(  90)		 ::flixel::FlxSprite boyfriend =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,this->bfPosition->x,(this->bfPosition->y + 350),null());
HXDLIN(  90)		 ::flixel::FlxSprite boyfriend1 = boyfriend->loadGraphic(::backend::Paths_obj::image(HX_("editors/silhouetteBF",65,06,d0,b5),null(),null()),null(),null(),null(),null(),null());
HXLINE(  91)		boyfriend1->set_antialiasing(::backend::ClientPrefs_obj::data->antialiasing);
HXLINE(  92)		boyfriend1->set_active(false);
HXLINE(  93)		{
HXLINE(  93)			 ::flixel::math::FlxBasePoint this4 = boyfriend1->offset;
HXDLIN(  93)			this4->set_x(( (Float)(-6) ));
HXDLIN(  93)			this4->set_y(( (Float)(2) ));
            		}
HXLINE(  94)		this->silhouettes->add(boyfriend1).StaticCast<  ::flixel::FlxSprite >();
HXLINE(  96)		this->silhouettes->set_alpha(((Float)0.25));
HXLINE(  98)		this->ghost =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null());
HXLINE(  99)		this->ghost->set_visible(false);
HXLINE( 100)		this->ghost->set_alpha(this->ghostAlpha);
HXLINE( 101)		this->add(this->ghost);
HXLINE( 103)		this->animsTxt =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,10,32,400,HX_("",00,00,00,00),null(),null());
HXLINE( 104)		this->animsTxt->setFormat(null(),16,-1,HX_("left",07,08,b0,47),::flixel::text::FlxTextBorderStyle_obj::OUTLINE_FAST_dyn(),-16777216,null());
HXLINE( 105)		{
HXLINE( 105)			 ::flixel::math::FlxBasePoint this5 = this->animsTxt->scrollFactor;
HXDLIN( 105)			this5->set_x(( (Float)(0) ));
HXDLIN( 105)			this5->set_y(( (Float)(0) ));
            		}
HXLINE( 106)		this->animsTxt->set_borderSize(( (Float)(1) ));
HXLINE( 107)		this->animsTxt->set_cameras(::Array_obj< ::Dynamic>::__new(1)->init(0,this->camHUD));
HXLINE( 109)		this->addCharacter(null());
HXLINE( 111)		this->cameraFollowPointer =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null())->loadGraphic(HX_("",00,00,00,00),null(),null(),null(),null(),null());
HXLINE( 112)		this->cameraFollowPointer->setGraphicSize(40,40);
HXLINE( 113)		this->cameraFollowPointer->updateHitbox();
HXLINE( 115)		this->healthBar =  ::objects::Bar_obj::__alloc( HX_CTX ,( (Float)(30) ),( (Float)((::flixel::FlxG_obj::height - 75)) ),null(),null(),null(),null());
HXLINE( 116)		{
HXLINE( 116)			 ::flixel::math::FlxBasePoint this6 = this->healthBar->scrollFactor;
HXDLIN( 116)			this6->set_x(( (Float)(0) ));
HXDLIN( 116)			this6->set_y(( (Float)(0) ));
            		}
HXLINE( 117)		this->healthBar->set_cameras(::Array_obj< ::Dynamic>::__new(1)->init(0,this->camHUD));
HXLINE( 119)		this->healthIcon =  ::objects::HealthIcon_obj::__alloc( HX_CTX ,this->character->healthIcon,false,false);
HXLINE( 120)		this->healthIcon->set_y(( (Float)((::flixel::FlxG_obj::height - 150)) ));
HXLINE( 121)		this->healthIcon->set_cameras(::Array_obj< ::Dynamic>::__new(1)->init(0,this->camHUD));
HXLINE( 123)		this->add(this->cameraFollowPointer);
HXLINE( 124)		this->add(this->healthBar);
HXLINE( 125)		this->add(this->healthIcon);
HXLINE( 126)		this->add(this->animsTxt);
HXLINE( 128)		 ::flixel::text::FlxText tipText =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,(::flixel::FlxG_obj::width - 300),(::flixel::FlxG_obj::height - 24),300,HX_("Press F1 for Help",b0,ec,b9,d4),20,null());
HXLINE( 129)		tipText->set_cameras(::Array_obj< ::Dynamic>::__new(1)->init(0,this->camHUD));
HXLINE( 130)		tipText->setFormat(null(),16,-1,HX_("right",dc,0b,64,e9),::flixel::text::FlxTextBorderStyle_obj::OUTLINE_FAST_dyn(),-16777216,null());
HXLINE( 131)		tipText->set_borderColor(-16777216);
HXLINE( 132)		{
HXLINE( 132)			 ::flixel::math::FlxBasePoint this7 = tipText->scrollFactor;
HXDLIN( 132)			this7->set_x(( (Float)(0) ));
HXDLIN( 132)			this7->set_y(( (Float)(0) ));
            		}
HXLINE( 133)		tipText->set_borderSize(( (Float)(1) ));
HXLINE( 134)		tipText->set_active(false);
HXLINE( 135)		this->add(tipText);
HXLINE( 137)		this->cameraZoomText =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,0,50,200,HX_("Zoom: 1x",00,b8,43,6e),null(),null());
HXLINE( 138)		this->cameraZoomText->setFormat(null(),16,-1,HX_("center",d5,25,db,05),::flixel::text::FlxTextBorderStyle_obj::OUTLINE_FAST_dyn(),-16777216,null());
HXLINE( 139)		{
HXLINE( 139)			 ::flixel::math::FlxBasePoint this8 = this->cameraZoomText->scrollFactor;
HXDLIN( 139)			this8->set_x(( (Float)(0) ));
HXDLIN( 139)			this8->set_y(( (Float)(0) ));
            		}
HXLINE( 140)		this->cameraZoomText->set_borderSize(( (Float)(1) ));
HXLINE( 141)		{
HXLINE( 141)			 ::flixel::text::FlxText _this1 = this->cameraZoomText;
HXDLIN( 141)			int axes = 1;
HXDLIN( 141)			bool _hx_tmp2;
HXDLIN( 141)			if ((axes != 1)) {
HXLINE( 141)				_hx_tmp2 = (axes == 17);
            			}
            			else {
HXLINE( 141)				_hx_tmp2 = true;
            			}
HXDLIN( 141)			if (_hx_tmp2) {
HXLINE( 141)				int _hx_tmp3 = ::flixel::FlxG_obj::width;
HXDLIN( 141)				_this1->set_x(((( (Float)(_hx_tmp3) ) - _this1->get_width()) / ( (Float)(2) )));
            			}
HXDLIN( 141)			bool _hx_tmp4;
HXDLIN( 141)			if ((axes != 16)) {
HXLINE( 141)				_hx_tmp4 = (axes == 17);
            			}
            			else {
HXLINE( 141)				_hx_tmp4 = true;
            			}
HXDLIN( 141)			if (_hx_tmp4) {
HXLINE( 141)				int _hx_tmp5 = ::flixel::FlxG_obj::height;
HXDLIN( 141)				_this1->set_y(((( (Float)(_hx_tmp5) ) - _this1->get_height()) / ( (Float)(2) )));
            			}
            		}
HXLINE( 142)		this->cameraZoomText->set_cameras(::Array_obj< ::Dynamic>::__new(1)->init(0,this->camHUD));
HXLINE( 143)		this->add(this->cameraZoomText);
HXLINE( 145)		this->frameAdvanceText =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,0,75,350,HX_("",00,00,00,00),null(),null());
HXLINE( 146)		this->frameAdvanceText->setFormat(null(),16,-1,HX_("center",d5,25,db,05),::flixel::text::FlxTextBorderStyle_obj::OUTLINE_FAST_dyn(),-16777216,null());
HXLINE( 147)		{
HXLINE( 147)			 ::flixel::math::FlxBasePoint this9 = this->frameAdvanceText->scrollFactor;
HXDLIN( 147)			this9->set_x(( (Float)(0) ));
HXDLIN( 147)			this9->set_y(( (Float)(0) ));
            		}
HXLINE( 148)		this->frameAdvanceText->set_borderSize(( (Float)(1) ));
HXLINE( 149)		{
HXLINE( 149)			 ::flixel::text::FlxText _this2 = this->frameAdvanceText;
HXDLIN( 149)			int axes1 = 1;
HXDLIN( 149)			bool _hx_tmp6;
HXDLIN( 149)			if ((axes1 != 1)) {
HXLINE( 149)				_hx_tmp6 = (axes1 == 17);
            			}
            			else {
HXLINE( 149)				_hx_tmp6 = true;
            			}
HXDLIN( 149)			if (_hx_tmp6) {
HXLINE( 149)				int _hx_tmp7 = ::flixel::FlxG_obj::width;
HXDLIN( 149)				_this2->set_x(((( (Float)(_hx_tmp7) ) - _this2->get_width()) / ( (Float)(2) )));
            			}
HXDLIN( 149)			bool _hx_tmp8;
HXDLIN( 149)			if ((axes1 != 16)) {
HXLINE( 149)				_hx_tmp8 = (axes1 == 17);
            			}
            			else {
HXLINE( 149)				_hx_tmp8 = true;
            			}
HXDLIN( 149)			if (_hx_tmp8) {
HXLINE( 149)				int _hx_tmp9 = ::flixel::FlxG_obj::height;
HXDLIN( 149)				_this2->set_y(((( (Float)(_hx_tmp9) ) - _this2->get_height()) / ( (Float)(2) )));
            			}
            		}
HXLINE( 150)		this->frameAdvanceText->set_cameras(::Array_obj< ::Dynamic>::__new(1)->init(0,this->camHUD));
HXLINE( 151)		this->add(this->frameAdvanceText);
HXLINE( 153)		this->addHelpScreen();
HXLINE( 154)		::flixel::FlxG_obj::mouse->set_visible(true);
HXLINE( 155)		::flixel::FlxG_obj::camera->set_zoom(( (Float)(1) ));
HXLINE( 157)		this->makeUIMenu();
HXLINE( 159)		bool _hx_tmp10;
HXDLIN( 159)		if (::hx::IsNotNull( this->character )) {
HXLINE( 159)			_hx_tmp10 = ::hx::IsNull( this->cameraFollowPointer );
            		}
            		else {
HXLINE( 159)			_hx_tmp10 = true;
            		}
HXDLIN( 159)		if (!(_hx_tmp10)) {
HXLINE( 159)			Float offX = ( (Float)(0) );
HXDLIN( 159)			Float offY = ( (Float)(0) );
HXDLIN( 159)			if (!(this->character->isPlayer)) {
HXLINE( 159)				Float offX1 = (this->character->getMidpoint(null())->x + 150);
HXDLIN( 159)				offX = (offX1 + this->character->cameraPosition->__get(0));
HXDLIN( 159)				Float offY1 = (this->character->getMidpoint(null())->y - ( (Float)(100) ));
HXDLIN( 159)				offY = (offY1 + this->character->cameraPosition->__get(1));
            			}
            			else {
HXLINE( 159)				Float offX2 = (this->character->getMidpoint(null())->x - ( (Float)(100) ));
HXDLIN( 159)				offX = (offX2 - this->character->cameraPosition->__get(0));
HXDLIN( 159)				Float offY2 = (this->character->getMidpoint(null())->y - ( (Float)(100) ));
HXDLIN( 159)				offY = (offY2 + this->character->cameraPosition->__get(1));
            			}
HXDLIN( 159)			this->cameraFollowPointer->setPosition(offX,offY);
HXDLIN( 159)			{
HXLINE( 159)				{
HXLINE( 159)					 ::flixel::math::FlxBasePoint this10 = ::flixel::FlxG_obj::camera->scroll;
HXDLIN( 159)					Float x = this->cameraFollowPointer->getMidpoint(null())->x;
HXDLIN( 159)					this10->set_x((x - (( (Float)(::flixel::FlxG_obj::width) ) / ( (Float)(2) ))));
            				}
HXDLIN( 159)				{
HXLINE( 159)					 ::flixel::math::FlxBasePoint this11 = ::flixel::FlxG_obj::camera->scroll;
HXDLIN( 159)					Float y = this->cameraFollowPointer->getMidpoint(null())->y;
HXDLIN( 159)					this11->set_y((y - (( (Float)(::flixel::FlxG_obj::height) ) / ( (Float)(2) ))));
            				}
            			}
            		}
HXLINE( 160)		{
HXLINE( 160)			this->healthColorStepperR->set_value(( (Float)(this->character->healthColorArray->__get(0)) ));
HXDLIN( 160)			this->healthColorStepperG->set_value(( (Float)(this->character->healthColorArray->__get(1)) ));
HXDLIN( 160)			this->healthColorStepperB->set_value(( (Float)(this->character->healthColorArray->__get(2)) ));
HXDLIN( 160)			 ::flixel::FlxSprite _hx_tmp11 = this->healthBar->leftBar;
HXDLIN( 160)			 ::flixel::FlxSprite _hx_tmp12 = this->healthBar->rightBar;
HXDLIN( 160)			int Red = this->character->healthColorArray->__get(0);
HXDLIN( 160)			int Green = this->character->healthColorArray->__get(1);
HXDLIN( 160)			int Blue = this->character->healthColorArray->__get(2);
HXDLIN( 160)			int Alpha = 255;
HXDLIN( 160)			int color = ::flixel::util::_FlxColor::FlxColor_Impl__obj::_new(null());
HXDLIN( 160)			{
HXLINE( 160)				color = (color & -16711681);
HXDLIN( 160)				int color1;
HXDLIN( 160)				if ((Red > 255)) {
HXLINE( 160)					color1 = 255;
            				}
            				else {
HXLINE( 160)					if ((Red < 0)) {
HXLINE( 160)						color1 = 0;
            					}
            					else {
HXLINE( 160)						color1 = Red;
            					}
            				}
HXDLIN( 160)				color = (color | (color1 << 16));
            			}
HXDLIN( 160)			{
HXLINE( 160)				color = (color & -65281);
HXDLIN( 160)				int color2;
HXDLIN( 160)				if ((Green > 255)) {
HXLINE( 160)					color2 = 255;
            				}
            				else {
HXLINE( 160)					if ((Green < 0)) {
HXLINE( 160)						color2 = 0;
            					}
            					else {
HXLINE( 160)						color2 = Green;
            					}
            				}
HXDLIN( 160)				color = (color | (color2 << 8));
            			}
HXDLIN( 160)			{
HXLINE( 160)				color = (color & -256);
HXDLIN( 160)				int color3;
HXDLIN( 160)				if ((Blue > 255)) {
HXLINE( 160)					color3 = 255;
            				}
            				else {
HXLINE( 160)					if ((Blue < 0)) {
HXLINE( 160)						color3 = 0;
            					}
            					else {
HXLINE( 160)						color3 = Blue;
            					}
            				}
HXDLIN( 160)				color = (color | color3);
            			}
HXDLIN( 160)			{
HXLINE( 160)				color = (color & 16777215);
HXDLIN( 160)				int color4;
HXDLIN( 160)				if ((Alpha > 255)) {
HXLINE( 160)					color4 = 255;
            				}
            				else {
HXLINE( 160)					if ((Alpha < 0)) {
HXLINE( 160)						color4 = 0;
            					}
            					else {
HXLINE( 160)						color4 = Alpha;
            					}
            				}
HXDLIN( 160)				color = (color | (color4 << 24));
            			}
HXDLIN( 160)			_hx_tmp11->set_color(_hx_tmp12->set_color(color));
HXDLIN( 160)			this->healthIcon->changeIcon(this->character->healthIcon,false);
HXDLIN( 160)			::String _hx_tmp13 = (HX_("Character: ",6f,a2,f1,a2) + this->_char);
HXDLIN( 160)			::backend::DiscordClient_obj::changePresence(HX_("Character Editor",84,45,58,b1),_hx_tmp13,this->healthIcon->getCharacter(),null(),null(),null());
            		}
HXLINE( 161)		this->character->finishAnimation();
HXLINE( 163)		if (::backend::ClientPrefs_obj::data->cacheOnGPU) {
HXLINE( 163)			::backend::Paths_obj::clearUnusedMemory();
            		}
HXLINE( 165)		this->super::create();
            	}


void CharacterEditorState_obj::addHelpScreen(){
            	HX_GC_STACKFRAME(&_hx_pos_8fcf73527616c70a_169_addHelpScreen)
HXLINE( 170)		::Array< ::String > str = ::Array_obj< ::String >::fromData( _hx_array_data_788c020f_5,19);
HXLINE( 190)		this->helpBg =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null())->makeGraphic(1,1,-16777216,null(),null());
HXLINE( 191)		{
HXLINE( 191)			 ::flixel::math::FlxBasePoint this1 = this->helpBg->scale;
HXDLIN( 191)			Float y = ( (Float)(::flixel::FlxG_obj::height) );
HXDLIN( 191)			this1->set_x(( (Float)(::flixel::FlxG_obj::width) ));
HXDLIN( 191)			this1->set_y(y);
            		}
HXLINE( 192)		this->helpBg->updateHitbox();
HXLINE( 193)		this->helpBg->set_alpha(((Float)0.6));
HXLINE( 194)		this->helpBg->set_cameras(::Array_obj< ::Dynamic>::__new(1)->init(0,this->camHUD));
HXLINE( 195)		 ::flixel::FlxSprite _hx_tmp = this->helpBg;
HXDLIN( 195)		_hx_tmp->set_active(this->helpBg->set_visible(false));
HXLINE( 196)		this->add(this->helpBg);
HXLINE( 198)		this->helpTexts =  ::flixel::group::FlxTypedSpriteGroup_obj::__alloc( HX_CTX ,null(),null(),null());
HXLINE( 199)		this->helpTexts->set_cameras(::Array_obj< ::Dynamic>::__new(1)->init(0,this->camHUD));
HXLINE( 200)		{
HXLINE( 200)			int _g_current = 0;
HXDLIN( 200)			::Array< ::String > _g_array = str;
HXDLIN( 200)			while((_g_current < _g_array->length)){
HXLINE( 200)				::String _g_value = _g_array->__get(_g_current);
HXDLIN( 200)				_g_current = (_g_current + 1);
HXDLIN( 200)				int _g_key = (_g_current - 1);
HXDLIN( 200)				int i = _g_key;
HXDLIN( 200)				::String txt = _g_value;
HXLINE( 201)				{
HXLINE( 202)					if ((txt.length < 1)) {
HXLINE( 202)						continue;
            					}
HXLINE( 204)					 ::flixel::text::FlxText helpText =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,0,0,600,txt,16,null());
HXLINE( 205)					helpText->setFormat(null(),16,-1,HX_("center",d5,25,db,05),::flixel::text::FlxTextBorderStyle_obj::OUTLINE_FAST_dyn(),-16777216,null());
HXLINE( 206)					helpText->set_borderColor(-16777216);
HXLINE( 207)					{
HXLINE( 207)						 ::flixel::math::FlxBasePoint this2 = helpText->scrollFactor;
HXDLIN( 207)						this2->set_x(( (Float)(0) ));
HXDLIN( 207)						this2->set_y(( (Float)(0) ));
            					}
HXLINE( 208)					helpText->set_borderSize(( (Float)(1) ));
HXLINE( 209)					{
HXLINE( 209)						int axes = 17;
HXDLIN( 209)						bool _hx_tmp1;
HXDLIN( 209)						if ((axes != 1)) {
HXLINE( 209)							_hx_tmp1 = (axes == 17);
            						}
            						else {
HXLINE( 209)							_hx_tmp1 = true;
            						}
HXDLIN( 209)						if (_hx_tmp1) {
HXLINE( 209)							int _hx_tmp2 = ::flixel::FlxG_obj::width;
HXDLIN( 209)							helpText->set_x(((( (Float)(_hx_tmp2) ) - helpText->get_width()) / ( (Float)(2) )));
            						}
HXDLIN( 209)						bool _hx_tmp3;
HXDLIN( 209)						if ((axes != 16)) {
HXLINE( 209)							_hx_tmp3 = (axes == 17);
            						}
            						else {
HXLINE( 209)							_hx_tmp3 = true;
            						}
HXDLIN( 209)						if (_hx_tmp3) {
HXLINE( 209)							int _hx_tmp4 = ::flixel::FlxG_obj::height;
HXDLIN( 209)							helpText->set_y(((( (Float)(_hx_tmp4) ) - helpText->get_height()) / ( (Float)(2) )));
            						}
            					}
HXLINE( 210)					this->add(helpText);
HXLINE( 211)					helpText->set_y((helpText->y + (((( (Float)(i) ) - (( (Float)(str->length) ) / ( (Float)(2) ))) * ( (Float)(32) )) + 16)));
HXLINE( 212)					helpText->set_active(false);
HXLINE( 213)					this->helpTexts->add(helpText).StaticCast<  ::flixel::FlxSprite >();
            				}
            			}
            		}
HXLINE( 215)		 ::flixel::group::FlxTypedSpriteGroup _hx_tmp5 = this->helpTexts;
HXDLIN( 215)		_hx_tmp5->set_active(this->helpTexts->set_visible(false));
HXLINE( 216)		this->add(this->helpTexts);
            	}


HX_DEFINE_DYNAMIC_FUNC0(CharacterEditorState_obj,addHelpScreen,(void))

void CharacterEditorState_obj::addCharacter(::hx::Null< bool >  __o_reload){
            		bool reload = __o_reload.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_8fcf73527616c70a_220_addCharacter)
HXLINE( 221)		int pos = -1;
HXLINE( 222)		if (::hx::IsNotNull( this->character )) {
HXLINE( 224)			pos = this->members->indexOf(this->character,null());
HXLINE( 225)			this->remove(this->character,null());
HXLINE( 226)			this->character->destroy();
            		}
HXLINE( 229)		bool isPlayer;
HXDLIN( 229)		if (reload) {
HXLINE( 229)			isPlayer = this->character->isPlayer;
            		}
            		else {
HXLINE( 229)			::String name = this->_char;
HXDLIN( 229)			bool isPlayer1;
HXDLIN( 229)			bool isPlayer2;
HXDLIN( 229)			bool isPlayer3;
HXDLIN( 229)			bool isPlayer4;
HXDLIN( 229)			bool isPlayer5;
HXDLIN( 229)			bool isPlayer6;
HXDLIN( 229)			bool isPlayer7;
HXDLIN( 229)			bool isPlayer8;
HXDLIN( 229)			if ((name != HX_("bf",c4,55,00,00))) {
HXLINE( 229)				isPlayer8 = !(::StringTools_obj::startsWith(name,HX_("bf-",e9,b5,4a,00)));
            			}
            			else {
HXLINE( 229)				isPlayer8 = false;
            			}
HXDLIN( 229)			if (isPlayer8) {
HXLINE( 229)				isPlayer7 = !(::StringTools_obj::endsWith(name,HX_("-player",4e,cb,fe,86)));
            			}
            			else {
HXLINE( 229)				isPlayer7 = false;
            			}
HXDLIN( 229)			if (isPlayer7) {
HXLINE( 229)				isPlayer6 = !(::StringTools_obj::endsWith(name,HX_("-playable",bb,1a,12,5a)));
            			}
            			else {
HXLINE( 229)				isPlayer6 = false;
            			}
HXDLIN( 229)			if (isPlayer6) {
HXLINE( 229)				isPlayer5 = !(::StringTools_obj::endsWith(name,HX_("-dead",51,69,6e,2b)));
            			}
            			else {
HXLINE( 229)				isPlayer5 = false;
            			}
HXDLIN( 229)			if (!(isPlayer5)) {
HXLINE( 229)				isPlayer4 = ::StringTools_obj::endsWith(name,HX_("-opponent",ca,2e,28,0d));
            			}
            			else {
HXLINE( 229)				isPlayer4 = true;
            			}
HXDLIN( 229)			if (!(isPlayer4)) {
HXLINE( 229)				isPlayer3 = ::StringTools_obj::startsWith(name,HX_("gf-",2e,81,4e,00));
            			}
            			else {
HXLINE( 229)				isPlayer3 = true;
            			}
HXDLIN( 229)			if (!(isPlayer3)) {
HXLINE( 229)				isPlayer2 = ::StringTools_obj::endsWith(name,HX_("-gf",8c,7f,22,00));
            			}
            			else {
HXLINE( 229)				isPlayer2 = true;
            			}
HXDLIN( 229)			if (!(isPlayer2)) {
HXLINE( 229)				isPlayer1 = (name == HX_("gf",1f,5a,00,00));
            			}
            			else {
HXLINE( 229)				isPlayer1 = true;
            			}
HXDLIN( 229)			isPlayer = !(isPlayer1);
            		}
HXLINE( 230)		this->character =  ::objects::Character_obj::__alloc( HX_CTX ,( (Float)(0) ),( (Float)(0) ),this->_char,isPlayer);
HXLINE( 231)		bool _hx_tmp;
HXDLIN( 231)		bool _hx_tmp1;
HXDLIN( 231)		if (!(reload)) {
HXLINE( 231)			_hx_tmp1 = ::hx::IsNotNull( this->character->editorIsPlayer );
            		}
            		else {
HXLINE( 231)			_hx_tmp1 = false;
            		}
HXDLIN( 231)		if (_hx_tmp1) {
HXLINE( 231)			_hx_tmp = ::hx::IsNotEq( isPlayer,this->character->editorIsPlayer );
            		}
            		else {
HXLINE( 231)			_hx_tmp = false;
            		}
HXDLIN( 231)		if (_hx_tmp) {
HXLINE( 233)			this->character->isPlayer = !(this->character->isPlayer);
HXLINE( 234)			this->character->set_flipX((this->character->originalFlipX != this->character->isPlayer));
HXLINE( 235)			if (::hx::IsNotNull( this->check_player )) {
HXLINE( 235)				this->check_player->set_checked(this->character->isPlayer);
            			}
            		}
HXLINE( 237)		this->character->debugMode = true;
HXLINE( 238)		this->character->missingCharacter = false;
HXLINE( 240)		if ((pos > -1)) {
HXLINE( 240)			this->insert(pos,this->character);
            		}
            		else {
HXLINE( 241)			this->add(this->character);
            		}
HXLINE( 242)		{
HXLINE( 242)			bool _hx_tmp2;
HXDLIN( 242)			bool _hx_tmp3;
HXDLIN( 242)			if (::hx::IsNotNull( this->character )) {
HXLINE( 242)				_hx_tmp3 = !(this->character->isPlayer);
            			}
            			else {
HXLINE( 242)				_hx_tmp3 = false;
            			}
HXDLIN( 242)			if (!(_hx_tmp3)) {
HXLINE( 242)				if (::hx::IsNull( this->character )) {
HXLINE( 242)					::String name1 = this->_char;
HXDLIN( 242)					bool _hx_tmp4;
HXDLIN( 242)					bool _hx_tmp5;
HXDLIN( 242)					bool _hx_tmp6;
HXDLIN( 242)					bool _hx_tmp7;
HXDLIN( 242)					bool _hx_tmp8;
HXDLIN( 242)					bool _hx_tmp9;
HXDLIN( 242)					bool _hx_tmp10;
HXDLIN( 242)					if ((name1 != HX_("bf",c4,55,00,00))) {
HXLINE( 242)						_hx_tmp10 = !(::StringTools_obj::startsWith(name1,HX_("bf-",e9,b5,4a,00)));
            					}
            					else {
HXLINE( 242)						_hx_tmp10 = false;
            					}
HXDLIN( 242)					if (_hx_tmp10) {
HXLINE( 242)						_hx_tmp9 = !(::StringTools_obj::endsWith(name1,HX_("-player",4e,cb,fe,86)));
            					}
            					else {
HXLINE( 242)						_hx_tmp9 = false;
            					}
HXDLIN( 242)					if (_hx_tmp9) {
HXLINE( 242)						_hx_tmp8 = !(::StringTools_obj::endsWith(name1,HX_("-playable",bb,1a,12,5a)));
            					}
            					else {
HXLINE( 242)						_hx_tmp8 = false;
            					}
HXDLIN( 242)					if (_hx_tmp8) {
HXLINE( 242)						_hx_tmp7 = !(::StringTools_obj::endsWith(name1,HX_("-dead",51,69,6e,2b)));
            					}
            					else {
HXLINE( 242)						_hx_tmp7 = false;
            					}
HXDLIN( 242)					if (!(_hx_tmp7)) {
HXLINE( 242)						_hx_tmp6 = ::StringTools_obj::endsWith(name1,HX_("-opponent",ca,2e,28,0d));
            					}
            					else {
HXLINE( 242)						_hx_tmp6 = true;
            					}
HXDLIN( 242)					if (!(_hx_tmp6)) {
HXLINE( 242)						_hx_tmp5 = ::StringTools_obj::startsWith(name1,HX_("gf-",2e,81,4e,00));
            					}
            					else {
HXLINE( 242)						_hx_tmp5 = true;
            					}
HXDLIN( 242)					if (!(_hx_tmp5)) {
HXLINE( 242)						_hx_tmp4 = ::StringTools_obj::endsWith(name1,HX_("-gf",8c,7f,22,00));
            					}
            					else {
HXLINE( 242)						_hx_tmp4 = true;
            					}
HXDLIN( 242)					if (!(_hx_tmp4)) {
HXLINE( 242)						_hx_tmp2 = (name1 == HX_("gf",1f,5a,00,00));
            					}
            					else {
HXLINE( 242)						_hx_tmp2 = true;
            					}
            				}
            				else {
HXLINE( 242)					_hx_tmp2 = false;
            				}
            			}
            			else {
HXLINE( 242)				_hx_tmp2 = true;
            			}
HXDLIN( 242)			if (_hx_tmp2) {
HXLINE( 242)				this->character->setPosition(this->dadPosition->x,this->dadPosition->y);
            			}
            			else {
HXLINE( 242)				this->character->setPosition(this->bfPosition->x,this->bfPosition->y);
            			}
HXDLIN( 242)			 ::objects::Character fh = this->character;
HXDLIN( 242)			fh->set_x((fh->x + this->character->positionArray->__get(0)));
HXDLIN( 242)			 ::objects::Character fh1 = this->character;
HXDLIN( 242)			fh1->set_y((fh1->y + this->character->positionArray->__get(1)));
HXDLIN( 242)			{
HXLINE( 242)				 ::Dynamic snap = false;
HXDLIN( 242)				if (::hx::IsNull( snap )) {
HXLINE(1177)					snap = true;
            				}
HXLINE( 242)				bool _hx_tmp11;
HXDLIN( 242)				if (::hx::IsNotNull( this->character )) {
HXLINE( 242)					_hx_tmp11 = ::hx::IsNull( this->cameraFollowPointer );
            				}
            				else {
HXLINE( 242)					_hx_tmp11 = true;
            				}
HXDLIN( 242)				if (!(_hx_tmp11)) {
HXLINE( 242)					Float offX = ( (Float)(0) );
HXDLIN( 242)					Float offY = ( (Float)(0) );
HXDLIN( 242)					if (!(this->character->isPlayer)) {
HXLINE( 242)						Float offX1 = (this->character->getMidpoint(null())->x + 150);
HXLINE(1106)						offX = (offX1 + this->character->cameraPosition->__get(0));
HXLINE( 242)						Float offY1 = (this->character->getMidpoint(null())->y - ( (Float)(100) ));
HXLINE(1107)						offY = (offY1 + this->character->cameraPosition->__get(1));
            					}
            					else {
HXLINE( 242)						Float offX2 = (this->character->getMidpoint(null())->x - ( (Float)(100) ));
HXLINE(1111)						offX = (offX2 - this->character->cameraPosition->__get(0));
HXLINE( 242)						Float offY2 = (this->character->getMidpoint(null())->y - ( (Float)(100) ));
HXLINE(1112)						offY = (offY2 + this->character->cameraPosition->__get(1));
            					}
HXLINE( 242)					this->cameraFollowPointer->setPosition(offX,offY);
HXDLIN( 242)					if (( (bool)(snap) )) {
HXLINE( 242)						{
HXLINE( 242)							 ::flixel::math::FlxBasePoint this1 = ::flixel::FlxG_obj::camera->scroll;
HXDLIN( 242)							Float x = this->cameraFollowPointer->getMidpoint(null())->x;
HXDLIN( 242)							this1->set_x((x - (( (Float)(::flixel::FlxG_obj::width) ) / ( (Float)(2) ))));
            						}
HXDLIN( 242)						{
HXLINE( 242)							 ::flixel::math::FlxBasePoint this2 = ::flixel::FlxG_obj::camera->scroll;
HXDLIN( 242)							Float y = this->cameraFollowPointer->getMidpoint(null())->y;
HXDLIN( 242)							this2->set_y((y - (( (Float)(::flixel::FlxG_obj::height) ) / ( (Float)(2) ))));
            						}
            					}
            				}
            			}
            		}
HXLINE( 243)		{
HXLINE( 243)			this->anims = this->character->animationsArray;
HXDLIN( 243)			if ((this->anims->length > 0)) {
HXLINE( 243)				this->character->playAnim(( (::String)(this->anims->__get(0)->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)) ),true,null(),null());
            			}
HXDLIN( 243)			this->curAnim = 0;
HXDLIN( 243)			{
HXLINE( 243)				this->animsTxt->removeFormat(this->selectedFormat,null(),null());
HXDLIN( 243)				::String intendText = HX_("",00,00,00,00);
HXDLIN( 243)				{
HXLINE( 243)					int _g_current = 0;
HXDLIN( 243)					::Array< ::Dynamic> _g_array = this->anims;
HXDLIN( 243)					while((_g_current < _g_array->length)){
HXLINE( 243)						 ::Dynamic _g_value = _g_array->__get(_g_current);
HXDLIN( 243)						_g_current = (_g_current + 1);
HXDLIN( 243)						int _g_key = (_g_current - 1);
HXDLIN( 243)						int num = _g_key;
HXDLIN( 243)						 ::Dynamic anim = _g_value;
HXDLIN( 243)						{
HXLINE( 243)							if ((num > 0)) {
HXLINE( 243)								intendText = (intendText + HX_("\n",0a,00,00,00));
            							}
HXDLIN( 243)							if ((num == this->curAnim)) {
HXLINE( 243)								int n = intendText.length;
HXDLIN( 243)								::String intendText1 = ( (::String)((anim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic) + HX_(": ",a6,32,00,00))) );
HXDLIN( 243)								intendText = (intendText + (intendText1 + ::Std_obj::string( ::Dynamic(anim->__Field(HX_("offsets",80,09,65,d7),::hx::paccDynamic)))));
HXDLIN( 243)								this->animsTxt->addFormat(this->selectedFormat,n,intendText.length);
            							}
            							else {
HXLINE( 243)								::String intendText2 = ( (::String)((anim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic) + HX_(": ",a6,32,00,00))) );
HXDLIN( 243)								intendText = (intendText + (intendText2 + ::Std_obj::string( ::Dynamic(anim->__Field(HX_("offsets",80,09,65,d7),::hx::paccDynamic)))));
            							}
            						}
            					}
            				}
HXDLIN( 243)				this->animsTxt->set_text(intendText);
            			}
HXDLIN( 243)			if (::hx::IsNotNull( this->animationDropDown )) {
HXLINE( 243)				this->reloadAnimationDropDown();
            			}
            		}
HXLINE( 244)		bool _hx_tmp12;
HXDLIN( 244)		if (::hx::IsNotNull( this->healthBar )) {
HXLINE( 244)			_hx_tmp12 = ::hx::IsNotNull( this->healthIcon );
            		}
            		else {
HXLINE( 244)			_hx_tmp12 = false;
            		}
HXDLIN( 244)		if (_hx_tmp12) {
HXLINE( 244)			this->healthColorStepperR->set_value(( (Float)(this->character->healthColorArray->__get(0)) ));
HXDLIN( 244)			this->healthColorStepperG->set_value(( (Float)(this->character->healthColorArray->__get(1)) ));
HXDLIN( 244)			this->healthColorStepperB->set_value(( (Float)(this->character->healthColorArray->__get(2)) ));
HXDLIN( 244)			 ::flixel::FlxSprite _hx_tmp13 = this->healthBar->leftBar;
HXDLIN( 244)			 ::flixel::FlxSprite _hx_tmp14 = this->healthBar->rightBar;
HXDLIN( 244)			int Red = this->character->healthColorArray->__get(0);
HXDLIN( 244)			int Green = this->character->healthColorArray->__get(1);
HXDLIN( 244)			int Blue = this->character->healthColorArray->__get(2);
HXDLIN( 244)			int Alpha = 255;
HXDLIN( 244)			int color = ::flixel::util::_FlxColor::FlxColor_Impl__obj::_new(null());
HXDLIN( 244)			{
HXLINE( 244)				color = (color & -16711681);
HXDLIN( 244)				int color1;
HXDLIN( 244)				if ((Red > 255)) {
HXLINE( 244)					color1 = 255;
            				}
            				else {
HXLINE( 244)					if ((Red < 0)) {
HXLINE( 244)						color1 = 0;
            					}
            					else {
HXLINE( 244)						color1 = Red;
            					}
            				}
HXDLIN( 244)				color = (color | (color1 << 16));
            			}
HXDLIN( 244)			{
HXLINE( 244)				color = (color & -65281);
HXDLIN( 244)				int color2;
HXDLIN( 244)				if ((Green > 255)) {
HXLINE( 244)					color2 = 255;
            				}
            				else {
HXLINE( 244)					if ((Green < 0)) {
HXLINE( 244)						color2 = 0;
            					}
            					else {
HXLINE( 244)						color2 = Green;
            					}
            				}
HXDLIN( 244)				color = (color | (color2 << 8));
            			}
HXDLIN( 244)			{
HXLINE( 244)				color = (color & -256);
HXDLIN( 244)				int color3;
HXDLIN( 244)				if ((Blue > 255)) {
HXLINE( 244)					color3 = 255;
            				}
            				else {
HXLINE( 244)					if ((Blue < 0)) {
HXLINE( 244)						color3 = 0;
            					}
            					else {
HXLINE( 244)						color3 = Blue;
            					}
            				}
HXDLIN( 244)				color = (color | color3);
            			}
HXDLIN( 244)			{
HXLINE( 244)				color = (color & 16777215);
HXDLIN( 244)				int color4;
HXDLIN( 244)				if ((Alpha > 255)) {
HXLINE( 244)					color4 = 255;
            				}
            				else {
HXLINE( 244)					if ((Alpha < 0)) {
HXLINE( 244)						color4 = 0;
            					}
            					else {
HXLINE( 244)						color4 = Alpha;
            					}
            				}
HXDLIN( 244)				color = (color | (color4 << 24));
            			}
HXDLIN( 244)			_hx_tmp13->set_color(_hx_tmp14->set_color(color));
HXDLIN( 244)			this->healthIcon->changeIcon(this->character->healthIcon,false);
HXDLIN( 244)			::String _hx_tmp15 = (HX_("Character: ",6f,a2,f1,a2) + this->_char);
HXDLIN( 244)			::backend::DiscordClient_obj::changePresence(HX_("Character Editor",84,45,58,b1),_hx_tmp15,this->healthIcon->getCharacter(),null(),null(),null());
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(CharacterEditorState_obj,addCharacter,(void))

void CharacterEditorState_obj::makeUIMenu(){
            	HX_GC_STACKFRAME(&_hx_pos_8fcf73527616c70a_248_makeUIMenu)
HXLINE( 249)		this->UI_box =  ::backend::ui::PsychUIBox_obj::__alloc( HX_CTX ,( (Float)((::flixel::FlxG_obj::width - 275)) ),( (Float)(25) ),250,120,::Array_obj< ::String >::fromData( _hx_array_data_788c020f_9,2));
HXLINE( 250)		{
HXLINE( 250)			 ::flixel::math::FlxBasePoint this1 = this->UI_box->scrollFactor;
HXDLIN( 250)			this1->set_x(( (Float)(0) ));
HXDLIN( 250)			this1->set_y(( (Float)(0) ));
            		}
HXLINE( 251)		this->UI_box->set_cameras(::Array_obj< ::Dynamic>::__new(1)->init(0,this->camHUD));
HXLINE( 253)		Float _hx_tmp = (this->UI_box->x - ( (Float)(100) ));
HXDLIN( 253)		Float _hx_tmp1 = this->UI_box->y;
HXDLIN( 253)		this->UI_characterbox =  ::backend::ui::PsychUIBox_obj::__alloc( HX_CTX ,_hx_tmp,((_hx_tmp1 + this->UI_box->get_height()) + 10),350,280,::Array_obj< ::String >::fromData( _hx_array_data_788c020f_10,2));
HXLINE( 254)		{
HXLINE( 254)			 ::flixel::math::FlxBasePoint this2 = this->UI_characterbox->scrollFactor;
HXDLIN( 254)			this2->set_x(( (Float)(0) ));
HXDLIN( 254)			this2->set_y(( (Float)(0) ));
            		}
HXLINE( 255)		this->UI_characterbox->set_cameras(::Array_obj< ::Dynamic>::__new(1)->init(0,this->camHUD));
HXLINE( 256)		this->add(this->UI_characterbox);
HXLINE( 257)		this->add(this->UI_box);
HXLINE( 259)		this->addGhostUI();
HXLINE( 260)		this->addSettingsUI();
HXLINE( 261)		this->addAnimationsUI();
HXLINE( 262)		this->addCharacterUI();
HXLINE( 264)		this->UI_box->set_selectedName(HX_("Settings",03,39,ef,64));
HXLINE( 265)		this->UI_characterbox->set_selectedName(HX_("Character",89,bb,a4,e3));
            	}


HX_DEFINE_DYNAMIC_FUNC0(CharacterEditorState_obj,makeUIMenu,(void))

void CharacterEditorState_obj::addGhostUI(){
            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_0, ::states::editors::CharacterEditorState,_gthis) HXARGC(0)
            		void _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_8fcf73527616c70a_274_addGhostUI)
HXLINE( 275)			 ::Dynamic anim = _gthis->anims->__get(_gthis->curAnim);
HXLINE( 276)			 ::objects::Character _this = _gthis->character;
HXDLIN( 276)			bool makeGhostButton;
HXDLIN( 276)			if (!(_this->isAnimateAtlas)) {
HXLINE( 276)				makeGhostButton = ::hx::IsNull( _this->animation->_curAnim );
            			}
            			else {
HXLINE( 276)				if (::hx::IsNotNull( _this->atlas->anim->curInstance )) {
HXLINE( 276)					makeGhostButton = ::hx::IsNull( _this->atlas->anim->get_curSymbol() );
            				}
            				else {
HXLINE( 276)					makeGhostButton = true;
            				}
            			}
HXDLIN( 276)			if (!(makeGhostButton)) {
HXLINE( 278)				 ::Dynamic myAnim = _gthis->anims->__get(_gthis->curAnim);
HXLINE( 279)				if (!(_gthis->character->isAnimateAtlas)) {
HXLINE( 281)					_gthis->ghost->loadGraphic(_gthis->character->graphic,null(),null(),null(),null(),null());
HXLINE( 282)					_gthis->ghost->frames->frames = _gthis->character->frames->frames;
HXLINE( 283)					_gthis->ghost->animation->copyFrom(_gthis->character->animation);
HXLINE( 284)					_gthis->ghost->animation->play(_gthis->character->animation->_curAnim->name,true,false,_gthis->character->animation->_curAnim->curFrame);
HXLINE( 285)					{
HXLINE( 285)						 ::flixel::animation::FlxAnimationController _this1 = _gthis->ghost->animation;
HXDLIN( 285)						if (::hx::IsNotNull( _this1->_curAnim )) {
HXLINE( 285)							_this1->_curAnim->pause();
            						}
            					}
            				}
            				else {
HXLINE( 287)					if (::hx::IsNotNull( myAnim )) {
HXLINE( 289)						if (::hx::IsNull( _gthis->animateGhost )) {
HXLINE( 291)							_gthis->animateGhost =  ::flxanimate::PsychFlxAnimate_obj::__alloc( HX_CTX ,_gthis->ghost->x,_gthis->ghost->y,null(),null());
HXLINE( 292)							_gthis->animateGhost->set_showPivot(false);
HXLINE( 293)							 ::states::editors::CharacterEditorState _gthis1 = _gthis;
HXDLIN( 293)							int makeGhostButton1 = _gthis->members->indexOf(_gthis->ghost,null());
HXDLIN( 293)							_gthis1->insert(makeGhostButton1,_gthis->animateGhost).StaticCast<  ::flixel::FlxBasic >();
HXLINE( 294)							_gthis->animateGhost->set_active(false);
            						}
HXLINE( 297)						bool makeGhostButton2;
HXDLIN( 297)						if (::hx::IsNotNull( _gthis->animateGhost )) {
HXLINE( 297)							makeGhostButton2 = (_gthis->animateGhostImage != _gthis->character->imageFile);
            						}
            						else {
HXLINE( 297)							makeGhostButton2 = true;
            						}
HXDLIN( 297)						if (makeGhostButton2) {
HXLINE( 298)							::backend::Paths_obj::loadAnimateAtlas(_gthis->animateGhost,_gthis->character->imageFile,null(),null());
            						}
HXLINE( 300)						bool makeGhostButton3;
HXDLIN( 300)						if (::hx::IsNotNull( myAnim->__Field(HX_("indices",27,47,54,e3),::hx::paccDynamic) )) {
HXLINE( 300)							makeGhostButton3 = (( (::Array< int >)(myAnim->__Field(HX_("indices",27,47,54,e3),::hx::paccDynamic)) )->length > 0);
            						}
            						else {
HXLINE( 300)							makeGhostButton3 = false;
            						}
HXDLIN( 300)						if (makeGhostButton3) {
HXLINE( 301)							_gthis->animateGhost->anim->addBySymbolIndices(HX_("anim",11,86,71,40),( (::String)(myAnim->__Field(HX_("name",4b,72,ff,48),::hx::paccDynamic)) ),( (::Array< int >)(myAnim->__Field(HX_("indices",27,47,54,e3),::hx::paccDynamic)) ),0,false,null(),null());
            						}
            						else {
HXLINE( 303)							_gthis->animateGhost->anim->addBySymbol(HX_("anim",11,86,71,40),( (::String)(myAnim->__Field(HX_("name",4b,72,ff,48),::hx::paccDynamic)) ),0,false,null(),null());
            						}
HXLINE( 305)						 ::flxanimate::animate::FlxAnim _gthis2 = _gthis->animateGhost->anim;
HXDLIN( 305)						_gthis2->play(HX_("anim",11,86,71,40),true,false,_gthis->character->atlas->anim->get_curFrame());
HXLINE( 306)						_gthis->animateGhost->anim->pause();
HXLINE( 308)						_gthis->animateGhostImage = _gthis->character->imageFile;
            					}
            				}
HXLINE( 311)				 ::flixel::FlxSprite spr;
HXDLIN( 311)				if (!(_gthis->character->isAnimateAtlas)) {
HXLINE( 311)					spr = _gthis->ghost;
            				}
            				else {
HXLINE( 311)					spr = _gthis->animateGhost;
            				}
HXLINE( 312)				if (::hx::IsNotNull( spr )) {
HXLINE( 314)					spr->setPosition(_gthis->character->x,_gthis->character->y);
HXLINE( 315)					spr->set_antialiasing(_gthis->character->antialiasing);
HXLINE( 316)					spr->set_flipX(_gthis->character->flipX);
HXLINE( 317)					spr->set_alpha(_gthis->ghostAlpha);
HXLINE( 319)					{
HXLINE( 319)						 ::flixel::math::FlxBasePoint this1 = spr->scale;
HXDLIN( 319)						Float y = _gthis->character->scale->y;
HXDLIN( 319)						this1->set_x(_gthis->character->scale->x);
HXDLIN( 319)						this1->set_y(y);
            					}
HXLINE( 320)					spr->updateHitbox();
HXLINE( 322)					{
HXLINE( 322)						 ::flixel::math::FlxBasePoint this2 = spr->offset;
HXDLIN( 322)						Float y1 = _gthis->character->offset->y;
HXDLIN( 322)						this2->set_x(_gthis->character->offset->x);
HXDLIN( 322)						this2->set_y(y1);
            					}
HXLINE( 323)					spr->set_visible(true);
HXLINE( 325)					 ::flixel::FlxSprite otherSpr;
HXDLIN( 325)					if (::hx::IsInstanceEq( spr,_gthis->animateGhost )) {
HXLINE( 325)						otherSpr = _gthis->ghost;
            					}
            					else {
HXLINE( 325)						otherSpr = _gthis->animateGhost;
            					}
HXLINE( 326)					if (::hx::IsNotNull( otherSpr )) {
HXLINE( 326)						otherSpr->set_visible(false);
            					}
            				}
HXLINE( 330)				::haxe::Log_obj::trace(HX_("created ghost image",92,c5,27,90),::hx::SourceInfo(HX_("source/states/editors/CharacterEditorState.hx",41,39,ad,0d),330,HX_("states.editors.CharacterEditorState",0f,02,8c,78),HX_("addGhostUI",42,b7,a0,ed)));
            			}
            		}
            		HX_END_LOCAL_FUNC0((void))

            		HX_BEGIN_LOCAL_FUNC_S2(::hx::LocalFunc,_hx_Closure_1, ::states::editors::CharacterEditorState,_gthis, ::backend::ui::PsychUICheckBox,highlightGhost2) HXARGC(0)
            		void _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_8fcf73527616c70a_344_addGhostUI)
HXLINE( 345)			int value;
HXDLIN( 345)			if (highlightGhost2->checked) {
HXLINE( 345)				value = 125;
            			}
            			else {
HXLINE( 345)				value = 0;
            			}
HXLINE( 346)			_gthis->ghost->colorTransform->redOffset = ( (Float)(value) );
HXLINE( 347)			_gthis->ghost->colorTransform->greenOffset = ( (Float)(value) );
HXLINE( 348)			_gthis->ghost->colorTransform->blueOffset = ( (Float)(value) );
HXLINE( 349)			if (::hx::IsNotNull( _gthis->animateGhost )) {
HXLINE( 351)				_gthis->animateGhost->colorTransform->redOffset = ( (Float)(value) );
HXLINE( 352)				_gthis->animateGhost->colorTransform->greenOffset = ( (Float)(value) );
HXLINE( 353)				_gthis->animateGhost->colorTransform->blueOffset = ( (Float)(value) );
            			}
            		}
            		HX_END_LOCAL_FUNC0((void))

            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_2, ::states::editors::CharacterEditorState,_gthis) HXARGC(1)
            		void _hx_run(Float v){
            			HX_GC_STACKFRAME(&_hx_pos_8fcf73527616c70a_358_addGhostUI)
HXLINE( 359)			_gthis->ghostAlpha = v;
HXLINE( 360)			_gthis->ghost->set_alpha(_gthis->ghostAlpha);
HXLINE( 361)			if (::hx::IsNotNull( _gthis->animateGhost )) {
HXLINE( 361)				_gthis->animateGhost->set_alpha(_gthis->ghostAlpha);
            			}
            		}
            		HX_END_LOCAL_FUNC1((void))

            	HX_GC_STACKFRAME(&_hx_pos_8fcf73527616c70a_270_addGhostUI)
HXDLIN( 270)		 ::states::editors::CharacterEditorState _gthis = ::hx::ObjectPtr<OBJ_>(this);
HXLINE( 271)		 ::flixel::group::FlxTypedSpriteGroup tab_group = this->UI_box->getTab(HX_("Ghost",2f,ff,85,26))->menu;
HXLINE( 274)		 ::backend::ui::PsychUIButton makeGhostButton =  ::backend::ui::PsychUIButton_obj::__alloc( HX_CTX ,25,15,HX_("Make Ghost",9d,ef,dd,05), ::Dynamic(new _hx_Closure_0(_gthis)),null(),null());
HXLINE( 342)		Float highlightGhost = (20 + makeGhostButton->x);
HXDLIN( 342)		Float highlightGhost1 = (highlightGhost + makeGhostButton->get_width());
HXDLIN( 342)		 ::backend::ui::PsychUICheckBox highlightGhost2 =  ::backend::ui::PsychUICheckBox_obj::__alloc( HX_CTX ,highlightGhost1,makeGhostButton->y,HX_("Highlight Ghost",23,88,be,a7),100,null());
HXLINE( 343)		highlightGhost2->onClick =  ::Dynamic(new _hx_Closure_1(_gthis,highlightGhost2));
HXLINE( 357)		 ::backend::ui::PsychUISlider ghostAlphaSlider =  ::backend::ui::PsychUISlider_obj::__alloc( HX_CTX ,15,(makeGhostButton->y + 25), ::Dynamic(new _hx_Closure_2(_gthis)),this->ghostAlpha,0,1,null(),null(),null());
HXLINE( 364)		ghostAlphaSlider->set_label(HX_("Opacity:",2f,70,fe,e6));
HXLINE( 366)		tab_group->add(makeGhostButton).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 368)		tab_group->add(highlightGhost2).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 369)		tab_group->add(ghostAlphaSlider).StaticCast<  ::flixel::FlxSprite >();
            	}


HX_DEFINE_DYNAMIC_FUNC0(CharacterEditorState_obj,addGhostUI,(void))

void CharacterEditorState_obj::addSettingsUI(){
            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_0, ::states::editors::CharacterEditorState,_gthis) HXARGC(0)
            		void _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_8fcf73527616c70a_381_addSettingsUI)
HXLINE( 382)			_gthis->character->isPlayer = !(_gthis->character->isPlayer);
HXLINE( 383)			_gthis->character->set_flipX(!(_gthis->character->flipX));
HXLINE( 384)			{
HXLINE( 384)				bool _hx_tmp;
HXDLIN( 384)				bool _hx_tmp1;
HXDLIN( 384)				if (::hx::IsNotNull( _gthis->character )) {
HXLINE( 384)					_hx_tmp1 = !(_gthis->character->isPlayer);
            				}
            				else {
HXLINE( 384)					_hx_tmp1 = false;
            				}
HXDLIN( 384)				if (!(_hx_tmp1)) {
HXLINE( 384)					if (::hx::IsNull( _gthis->character )) {
HXLINE( 384)						::String name = _gthis->_char;
HXDLIN( 384)						bool _hx_tmp2;
HXDLIN( 384)						bool _hx_tmp3;
HXDLIN( 384)						bool _hx_tmp4;
HXDLIN( 384)						bool _hx_tmp5;
HXDLIN( 384)						bool _hx_tmp6;
HXDLIN( 384)						bool _hx_tmp7;
HXDLIN( 384)						bool _hx_tmp8;
HXDLIN( 384)						if ((name != HX_("bf",c4,55,00,00))) {
HXLINE( 384)							_hx_tmp8 = !(::StringTools_obj::startsWith(name,HX_("bf-",e9,b5,4a,00)));
            						}
            						else {
HXLINE( 384)							_hx_tmp8 = false;
            						}
HXDLIN( 384)						if (_hx_tmp8) {
HXLINE( 384)							_hx_tmp7 = !(::StringTools_obj::endsWith(name,HX_("-player",4e,cb,fe,86)));
            						}
            						else {
HXLINE( 384)							_hx_tmp7 = false;
            						}
HXDLIN( 384)						if (_hx_tmp7) {
HXLINE( 384)							_hx_tmp6 = !(::StringTools_obj::endsWith(name,HX_("-playable",bb,1a,12,5a)));
            						}
            						else {
HXLINE( 384)							_hx_tmp6 = false;
            						}
HXDLIN( 384)						if (_hx_tmp6) {
HXLINE( 384)							_hx_tmp5 = !(::StringTools_obj::endsWith(name,HX_("-dead",51,69,6e,2b)));
            						}
            						else {
HXLINE( 384)							_hx_tmp5 = false;
            						}
HXDLIN( 384)						if (!(_hx_tmp5)) {
HXLINE( 384)							_hx_tmp4 = ::StringTools_obj::endsWith(name,HX_("-opponent",ca,2e,28,0d));
            						}
            						else {
HXLINE( 384)							_hx_tmp4 = true;
            						}
HXDLIN( 384)						if (!(_hx_tmp4)) {
HXLINE( 384)							_hx_tmp3 = ::StringTools_obj::startsWith(name,HX_("gf-",2e,81,4e,00));
            						}
            						else {
HXLINE( 384)							_hx_tmp3 = true;
            						}
HXDLIN( 384)						if (!(_hx_tmp3)) {
HXLINE( 384)							_hx_tmp2 = ::StringTools_obj::endsWith(name,HX_("-gf",8c,7f,22,00));
            						}
            						else {
HXLINE( 384)							_hx_tmp2 = true;
            						}
HXDLIN( 384)						if (!(_hx_tmp2)) {
HXLINE( 384)							_hx_tmp = (name == HX_("gf",1f,5a,00,00));
            						}
            						else {
HXLINE( 384)							_hx_tmp = true;
            						}
            					}
            					else {
HXLINE( 384)						_hx_tmp = false;
            					}
            				}
            				else {
HXLINE( 384)					_hx_tmp = true;
            				}
HXDLIN( 384)				if (_hx_tmp) {
HXLINE( 384)					_gthis->character->setPosition(_gthis->dadPosition->x,_gthis->dadPosition->y);
            				}
            				else {
HXLINE( 384)					_gthis->character->setPosition(_gthis->bfPosition->x,_gthis->bfPosition->y);
            				}
HXDLIN( 384)				 ::objects::Character fh = _gthis->character;
HXDLIN( 384)				fh->set_x((fh->x + _gthis->character->positionArray->__get(0)));
HXDLIN( 384)				 ::objects::Character fh1 = _gthis->character;
HXDLIN( 384)				fh1->set_y((fh1->y + _gthis->character->positionArray->__get(1)));
HXDLIN( 384)				{
HXLINE( 384)					 ::Dynamic snap = false;
HXDLIN( 384)					if (::hx::IsNull( snap )) {
HXLINE(1177)						snap = true;
            					}
HXLINE( 384)					bool _hx_tmp9;
HXDLIN( 384)					if (::hx::IsNotNull( _gthis->character )) {
HXLINE( 384)						_hx_tmp9 = ::hx::IsNull( _gthis->cameraFollowPointer );
            					}
            					else {
HXLINE( 384)						_hx_tmp9 = true;
            					}
HXDLIN( 384)					if (!(_hx_tmp9)) {
HXLINE( 384)						Float offX = ( (Float)(0) );
HXDLIN( 384)						Float offY = ( (Float)(0) );
HXDLIN( 384)						if (!(_gthis->character->isPlayer)) {
HXLINE( 384)							Float offX1 = (_gthis->character->getMidpoint(null())->x + 150);
HXLINE(1106)							offX = (offX1 + _gthis->character->cameraPosition->__get(0));
HXLINE( 384)							Float offY1 = (_gthis->character->getMidpoint(null())->y - ( (Float)(100) ));
HXLINE(1107)							offY = (offY1 + _gthis->character->cameraPosition->__get(1));
            						}
            						else {
HXLINE( 384)							Float offX2 = (_gthis->character->getMidpoint(null())->x - ( (Float)(100) ));
HXLINE(1111)							offX = (offX2 - _gthis->character->cameraPosition->__get(0));
HXLINE( 384)							Float offY2 = (_gthis->character->getMidpoint(null())->y - ( (Float)(100) ));
HXLINE(1112)							offY = (offY2 + _gthis->character->cameraPosition->__get(1));
            						}
HXLINE( 384)						_gthis->cameraFollowPointer->setPosition(offX,offY);
HXDLIN( 384)						if (( (bool)(snap) )) {
HXLINE( 384)							{
HXLINE( 384)								 ::flixel::math::FlxBasePoint this1 = ::flixel::FlxG_obj::camera->scroll;
HXDLIN( 384)								Float x = _gthis->cameraFollowPointer->getMidpoint(null())->x;
HXDLIN( 384)								this1->set_x((x - (( (Float)(::flixel::FlxG_obj::width) ) / ( (Float)(2) ))));
            							}
HXDLIN( 384)							{
HXLINE( 384)								 ::flixel::math::FlxBasePoint this2 = ::flixel::FlxG_obj::camera->scroll;
HXDLIN( 384)								Float y = _gthis->cameraFollowPointer->getMidpoint(null())->y;
HXDLIN( 384)								this2->set_y((y - (( (Float)(::flixel::FlxG_obj::height) ) / ( (Float)(2) ))));
            							}
            						}
            					}
            				}
            			}
HXLINE( 385)			{
HXLINE( 385)				 ::Dynamic snap1 = false;
HXDLIN( 385)				if (::hx::IsNull( snap1 )) {
HXLINE( 385)					snap1 = true;
            				}
HXDLIN( 385)				bool _hx_tmp10;
HXDLIN( 385)				if (::hx::IsNotNull( _gthis->character )) {
HXLINE( 385)					_hx_tmp10 = ::hx::IsNull( _gthis->cameraFollowPointer );
            				}
            				else {
HXLINE( 385)					_hx_tmp10 = true;
            				}
HXDLIN( 385)				if (!(_hx_tmp10)) {
HXLINE( 385)					Float offX3 = ( (Float)(0) );
HXDLIN( 385)					Float offY3 = ( (Float)(0) );
HXDLIN( 385)					if (!(_gthis->character->isPlayer)) {
HXLINE( 385)						Float offX4 = (_gthis->character->getMidpoint(null())->x + 150);
HXLINE(1106)						offX3 = (offX4 + _gthis->character->cameraPosition->__get(0));
HXLINE( 385)						Float offY4 = (_gthis->character->getMidpoint(null())->y - ( (Float)(100) ));
HXLINE(1107)						offY3 = (offY4 + _gthis->character->cameraPosition->__get(1));
            					}
            					else {
HXLINE( 385)						Float offX5 = (_gthis->character->getMidpoint(null())->x - ( (Float)(100) ));
HXLINE(1111)						offX3 = (offX5 - _gthis->character->cameraPosition->__get(0));
HXLINE( 385)						Float offY5 = (_gthis->character->getMidpoint(null())->y - ( (Float)(100) ));
HXLINE(1112)						offY3 = (offY5 + _gthis->character->cameraPosition->__get(1));
            					}
HXLINE( 385)					_gthis->cameraFollowPointer->setPosition(offX3,offY3);
HXDLIN( 385)					if (( (bool)(snap1) )) {
HXLINE( 385)						{
HXLINE( 385)							 ::flixel::math::FlxBasePoint this3 = ::flixel::FlxG_obj::camera->scroll;
HXDLIN( 385)							Float x1 = _gthis->cameraFollowPointer->getMidpoint(null())->x;
HXDLIN( 385)							this3->set_x((x1 - (( (Float)(::flixel::FlxG_obj::width) ) / ( (Float)(2) ))));
            						}
HXDLIN( 385)						{
HXLINE( 385)							 ::flixel::math::FlxBasePoint this4 = ::flixel::FlxG_obj::camera->scroll;
HXDLIN( 385)							Float y1 = _gthis->cameraFollowPointer->getMidpoint(null())->y;
HXDLIN( 385)							this4->set_y((y1 - (( (Float)(::flixel::FlxG_obj::height) ) / ( (Float)(2) ))));
            						}
            					}
            				}
            			}
            		}
            		HX_END_LOCAL_FUNC0((void))

            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_1, ::states::editors::CharacterEditorState,_gthis) HXARGC(0)
            		void _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_8fcf73527616c70a_389_addSettingsUI)
HXLINE( 390)			_gthis->addCharacter(true);
HXLINE( 391)			bool reloadCharacter;
HXDLIN( 391)			if (::hx::IsNotNull( _gthis->character )) {
HXLINE( 391)				reloadCharacter = ::hx::IsNull( _gthis->cameraFollowPointer );
            			}
            			else {
HXLINE( 391)				reloadCharacter = true;
            			}
HXDLIN( 391)			if (!(reloadCharacter)) {
HXLINE( 391)				Float offX = ( (Float)(0) );
HXDLIN( 391)				Float offY = ( (Float)(0) );
HXDLIN( 391)				if (!(_gthis->character->isPlayer)) {
HXLINE( 391)					Float offX1 = (_gthis->character->getMidpoint(null())->x + 150);
HXLINE(1106)					offX = (offX1 + _gthis->character->cameraPosition->__get(0));
HXLINE( 391)					Float offY1 = (_gthis->character->getMidpoint(null())->y - ( (Float)(100) ));
HXLINE(1107)					offY = (offY1 + _gthis->character->cameraPosition->__get(1));
            				}
            				else {
HXLINE( 391)					Float offX2 = (_gthis->character->getMidpoint(null())->x - ( (Float)(100) ));
HXLINE(1111)					offX = (offX2 - _gthis->character->cameraPosition->__get(0));
HXLINE( 391)					Float offY2 = (_gthis->character->getMidpoint(null())->y - ( (Float)(100) ));
HXLINE(1112)					offY = (offY2 + _gthis->character->cameraPosition->__get(1));
            				}
HXLINE( 391)				_gthis->cameraFollowPointer->setPosition(offX,offY);
HXDLIN( 391)				{
HXLINE( 391)					{
HXLINE( 391)						 ::flixel::math::FlxBasePoint this1 = ::flixel::FlxG_obj::camera->scroll;
HXDLIN( 391)						Float x = _gthis->cameraFollowPointer->getMidpoint(null())->x;
HXDLIN( 391)						this1->set_x((x - (( (Float)(::flixel::FlxG_obj::width) ) / ( (Float)(2) ))));
            					}
HXDLIN( 391)					{
HXLINE( 391)						 ::flixel::math::FlxBasePoint this2 = ::flixel::FlxG_obj::camera->scroll;
HXDLIN( 391)						Float y = _gthis->cameraFollowPointer->getMidpoint(null())->y;
HXDLIN( 391)						this2->set_y((y - (( (Float)(::flixel::FlxG_obj::height) ) / ( (Float)(2) ))));
            					}
            				}
            			}
HXLINE( 392)			_gthis->reloadCharacterOptions();
HXLINE( 393)			_gthis->reloadCharacterDropDown();
            		}
            		HX_END_LOCAL_FUNC0((void))

            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_2, ::states::editors::CharacterEditorState,_gthis) HXARGC(0)
            		void _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_8fcf73527616c70a_397_addSettingsUI)
HXLINE( 398)			 ::Dynamic _template =  ::Dynamic(::hx::Anon_obj::Create(11)
            				->setFixed(0,HX_("animations",ef,34,1c,83),::Array_obj< ::Dynamic>::__new(5)->init(0, ::Dynamic(::hx::Anon_obj::Create(6)
            					->setFixed(0,HX_("offsets",80,09,65,d7),::Array_obj< int >::fromData( _hx_array_data_788c020f_19,2))
            					->setFixed(1,HX_("indices",27,47,54,e3),::Array_obj< int >::__new(0))
            					->setFixed(2,HX_("fps",e9,c7,4d,00),24)
            					->setFixed(3,HX_("anim",11,86,71,40),HX_("idle",14,a7,b3,45))
            					->setFixed(4,HX_("loop",64,a6,b7,47),false)
            					->setFixed(5,HX_("name",4b,72,ff,48),HX_("BF idle dance",03,fa,cc,7f))))->init(1, ::Dynamic(::hx::Anon_obj::Create(6)
            					->setFixed(0,HX_("offsets",80,09,65,d7),::Array_obj< int >::fromData( _hx_array_data_788c020f_20,2))
            					->setFixed(1,HX_("indices",27,47,54,e3),::Array_obj< int >::__new(0))
            					->setFixed(2,HX_("fps",e9,c7,4d,00),24)
            					->setFixed(3,HX_("anim",11,86,71,40),HX_("singLEFT",d6,39,ef,3b))
            					->setFixed(4,HX_("loop",64,a6,b7,47),false)
            					->setFixed(5,HX_("name",4b,72,ff,48),HX_("BF NOTE LEFT0",77,e0,7c,76))))->init(2, ::Dynamic(::hx::Anon_obj::Create(6)
            					->setFixed(0,HX_("offsets",80,09,65,d7),::Array_obj< int >::fromData( _hx_array_data_788c020f_21,2))
            					->setFixed(1,HX_("indices",27,47,54,e3),::Array_obj< int >::__new(0))
            					->setFixed(2,HX_("fps",e9,c7,4d,00),24)
            					->setFixed(3,HX_("anim",11,86,71,40),HX_("singDOWN",31,2a,ad,36))
            					->setFixed(4,HX_("loop",64,a6,b7,47),false)
            					->setFixed(5,HX_("name",4b,72,ff,48),HX_("BF NOTE DOWN0",bc,3f,f1,e1))))->init(3, ::Dynamic(::hx::Anon_obj::Create(6)
            					->setFixed(0,HX_("offsets",80,09,65,d7),::Array_obj< int >::fromData( _hx_array_data_788c020f_22,2))
            					->setFixed(1,HX_("indices",27,47,54,e3),::Array_obj< int >::__new(0))
            					->setFixed(2,HX_("fps",e9,c7,4d,00),24)
            					->setFixed(3,HX_("anim",11,86,71,40),HX_("singUP",6a,52,21,b9))
            					->setFixed(4,HX_("loop",64,a6,b7,47),false)
            					->setFixed(5,HX_("name",4b,72,ff,48),HX_("BF NOTE UP0",23,e8,67,d4))))->init(4, ::Dynamic(::hx::Anon_obj::Create(6)
            					->setFixed(0,HX_("offsets",80,09,65,d7),::Array_obj< int >::fromData( _hx_array_data_788c020f_23,2))
            					->setFixed(1,HX_("indices",27,47,54,e3),::Array_obj< int >::__new(0))
            					->setFixed(2,HX_("fps",e9,c7,4d,00),24)
            					->setFixed(3,HX_("anim",11,86,71,40),HX_("singRIGHT",0d,6f,70,ac))
            					->setFixed(4,HX_("loop",64,a6,b7,47),false)
            					->setFixed(5,HX_("name",4b,72,ff,48),HX_("BF NOTE RIGHT0",06,3f,26,eb)))))
            				->setFixed(1,HX_("vocals_file",3d,c5,2d,83),null())
            				->setFixed(2,HX_("no_antialiasing",f2,74,67,98),false)
            				->setFixed(3,HX_("image",5b,1f,69,bd),HX_("characters/BOYFRIEND",65,2c,9c,1b))
            				->setFixed(4,HX_("position",a9,a0,fa,ca),::Array_obj< Float >::fromData( _hx_array_data_788c020f_24,2))
            				->setFixed(5,HX_("healthicon",15,8e,6f,17),HX_("face",9d,b4,b5,43))
            				->setFixed(6,HX_("flip_x",26,2b,6a,3d),false)
            				->setFixed(7,HX_("healthbar_colors",78,d9,40,40),::Array_obj< int >::fromData( _hx_array_data_788c020f_25,3))
            				->setFixed(8,HX_("camera_position",c3,d4,4a,56),::Array_obj< Float >::fromData( _hx_array_data_788c020f_26,2))
            				->setFixed(9,HX_("sing_duration",84,ae,a8,66),( (Float)(4) ))
            				->setFixed(10,HX_("scale",8a,ce,ce,78),( (Float)(1) )));
HXLINE( 419)			_gthis->character->loadCharacterFile(_template);
HXLINE( 420)			_gthis->character->missingCharacter = false;
HXLINE( 421)			_gthis->character->set_color(-1);
HXLINE( 422)			_gthis->character->set_alpha(( (Float)(1) ));
HXLINE( 423)			{
HXLINE( 423)				_gthis->anims = _gthis->character->animationsArray;
HXDLIN( 423)				if ((_gthis->anims->length > 0)) {
HXLINE( 423)					_gthis->character->playAnim(( (::String)(_gthis->anims->__get(0)->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)) ),true,null(),null());
            				}
HXDLIN( 423)				_gthis->curAnim = 0;
HXDLIN( 423)				{
HXLINE( 423)					_gthis->animsTxt->removeFormat(_gthis->selectedFormat,null(),null());
HXDLIN( 423)					::String intendText = HX_("",00,00,00,00);
HXDLIN( 423)					{
HXLINE( 423)						int _g_current = 0;
HXDLIN( 423)						::Array< ::Dynamic> _g_array = _gthis->anims;
HXDLIN( 423)						while((_g_current < _g_array->length)){
HXLINE( 423)							 ::Dynamic _g_value = _g_array->__get(_g_current);
HXDLIN( 423)							_g_current = (_g_current + 1);
HXDLIN( 423)							int _g_key = (_g_current - 1);
HXDLIN( 423)							int num = _g_key;
HXDLIN( 423)							 ::Dynamic anim = _g_value;
HXDLIN( 423)							{
HXLINE( 423)								if ((num > 0)) {
HXLINE( 423)									intendText = (intendText + HX_("\n",0a,00,00,00));
            								}
HXDLIN( 423)								if ((num == _gthis->curAnim)) {
HXLINE( 423)									int n = intendText.length;
HXDLIN( 423)									::String intendText1 = ( (::String)((anim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic) + HX_(": ",a6,32,00,00))) );
HXDLIN( 423)									intendText = (intendText + (intendText1 + ::Std_obj::string( ::Dynamic(anim->__Field(HX_("offsets",80,09,65,d7),::hx::paccDynamic)))));
HXDLIN( 423)									_gthis->animsTxt->addFormat(_gthis->selectedFormat,n,intendText.length);
            								}
            								else {
HXLINE( 423)									::String intendText2 = ( (::String)((anim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic) + HX_(": ",a6,32,00,00))) );
HXDLIN( 423)									intendText = (intendText + (intendText2 + ::Std_obj::string( ::Dynamic(anim->__Field(HX_("offsets",80,09,65,d7),::hx::paccDynamic)))));
            								}
            							}
            						}
            					}
HXDLIN( 423)					_gthis->animsTxt->set_text(intendText);
            				}
HXDLIN( 423)				if (::hx::IsNotNull( _gthis->animationDropDown )) {
HXLINE( 423)					_gthis->reloadAnimationDropDown();
            				}
            			}
HXLINE( 424)			_gthis->reloadCharacterOptions();
HXLINE( 425)			{
HXLINE( 425)				bool templateCharacter;
HXDLIN( 425)				bool templateCharacter1;
HXDLIN( 425)				if (::hx::IsNotNull( _gthis->character )) {
HXLINE( 425)					templateCharacter1 = !(_gthis->character->isPlayer);
            				}
            				else {
HXLINE( 425)					templateCharacter1 = false;
            				}
HXDLIN( 425)				if (!(templateCharacter1)) {
HXLINE( 425)					if (::hx::IsNull( _gthis->character )) {
HXLINE( 425)						::String name = _gthis->_char;
HXDLIN( 425)						bool templateCharacter2;
HXDLIN( 425)						bool templateCharacter3;
HXDLIN( 425)						bool templateCharacter4;
HXDLIN( 425)						bool templateCharacter5;
HXDLIN( 425)						bool templateCharacter6;
HXDLIN( 425)						bool templateCharacter7;
HXDLIN( 425)						bool templateCharacter8;
HXDLIN( 425)						if ((name != HX_("bf",c4,55,00,00))) {
HXLINE( 425)							templateCharacter8 = !(::StringTools_obj::startsWith(name,HX_("bf-",e9,b5,4a,00)));
            						}
            						else {
HXLINE( 425)							templateCharacter8 = false;
            						}
HXDLIN( 425)						if (templateCharacter8) {
HXLINE( 425)							templateCharacter7 = !(::StringTools_obj::endsWith(name,HX_("-player",4e,cb,fe,86)));
            						}
            						else {
HXLINE( 425)							templateCharacter7 = false;
            						}
HXDLIN( 425)						if (templateCharacter7) {
HXLINE( 425)							templateCharacter6 = !(::StringTools_obj::endsWith(name,HX_("-playable",bb,1a,12,5a)));
            						}
            						else {
HXLINE( 425)							templateCharacter6 = false;
            						}
HXDLIN( 425)						if (templateCharacter6) {
HXLINE( 425)							templateCharacter5 = !(::StringTools_obj::endsWith(name,HX_("-dead",51,69,6e,2b)));
            						}
            						else {
HXLINE( 425)							templateCharacter5 = false;
            						}
HXDLIN( 425)						if (!(templateCharacter5)) {
HXLINE( 425)							templateCharacter4 = ::StringTools_obj::endsWith(name,HX_("-opponent",ca,2e,28,0d));
            						}
            						else {
HXLINE( 425)							templateCharacter4 = true;
            						}
HXDLIN( 425)						if (!(templateCharacter4)) {
HXLINE( 425)							templateCharacter3 = ::StringTools_obj::startsWith(name,HX_("gf-",2e,81,4e,00));
            						}
            						else {
HXLINE( 425)							templateCharacter3 = true;
            						}
HXDLIN( 425)						if (!(templateCharacter3)) {
HXLINE( 425)							templateCharacter2 = ::StringTools_obj::endsWith(name,HX_("-gf",8c,7f,22,00));
            						}
            						else {
HXLINE( 425)							templateCharacter2 = true;
            						}
HXDLIN( 425)						if (!(templateCharacter2)) {
HXLINE( 425)							templateCharacter = (name == HX_("gf",1f,5a,00,00));
            						}
            						else {
HXLINE( 425)							templateCharacter = true;
            						}
            					}
            					else {
HXLINE( 425)						templateCharacter = false;
            					}
            				}
            				else {
HXLINE( 425)					templateCharacter = true;
            				}
HXDLIN( 425)				if (templateCharacter) {
HXLINE( 425)					_gthis->character->setPosition(_gthis->dadPosition->x,_gthis->dadPosition->y);
            				}
            				else {
HXLINE( 425)					_gthis->character->setPosition(_gthis->bfPosition->x,_gthis->bfPosition->y);
            				}
HXDLIN( 425)				 ::objects::Character fh = _gthis->character;
HXDLIN( 425)				fh->set_x((fh->x + _gthis->character->positionArray->__get(0)));
HXDLIN( 425)				 ::objects::Character fh1 = _gthis->character;
HXDLIN( 425)				fh1->set_y((fh1->y + _gthis->character->positionArray->__get(1)));
HXDLIN( 425)				{
HXLINE( 425)					 ::Dynamic snap = false;
HXDLIN( 425)					if (::hx::IsNull( snap )) {
HXLINE(1177)						snap = true;
            					}
HXLINE( 425)					bool templateCharacter9;
HXDLIN( 425)					if (::hx::IsNotNull( _gthis->character )) {
HXLINE( 425)						templateCharacter9 = ::hx::IsNull( _gthis->cameraFollowPointer );
            					}
            					else {
HXLINE( 425)						templateCharacter9 = true;
            					}
HXDLIN( 425)					if (!(templateCharacter9)) {
HXLINE( 425)						Float offX = ( (Float)(0) );
HXDLIN( 425)						Float offY = ( (Float)(0) );
HXDLIN( 425)						if (!(_gthis->character->isPlayer)) {
HXLINE( 425)							Float offX1 = (_gthis->character->getMidpoint(null())->x + 150);
HXLINE(1106)							offX = (offX1 + _gthis->character->cameraPosition->__get(0));
HXLINE( 425)							Float offY1 = (_gthis->character->getMidpoint(null())->y - ( (Float)(100) ));
HXLINE(1107)							offY = (offY1 + _gthis->character->cameraPosition->__get(1));
            						}
            						else {
HXLINE( 425)							Float offX2 = (_gthis->character->getMidpoint(null())->x - ( (Float)(100) ));
HXLINE(1111)							offX = (offX2 - _gthis->character->cameraPosition->__get(0));
HXLINE( 425)							Float offY2 = (_gthis->character->getMidpoint(null())->y - ( (Float)(100) ));
HXLINE(1112)							offY = (offY2 + _gthis->character->cameraPosition->__get(1));
            						}
HXLINE( 425)						_gthis->cameraFollowPointer->setPosition(offX,offY);
HXDLIN( 425)						if (( (bool)(snap) )) {
HXLINE( 425)							{
HXLINE( 425)								 ::flixel::math::FlxBasePoint this1 = ::flixel::FlxG_obj::camera->scroll;
HXDLIN( 425)								Float x = _gthis->cameraFollowPointer->getMidpoint(null())->x;
HXDLIN( 425)								this1->set_x((x - (( (Float)(::flixel::FlxG_obj::width) ) / ( (Float)(2) ))));
            							}
HXDLIN( 425)							{
HXLINE( 425)								 ::flixel::math::FlxBasePoint this2 = ::flixel::FlxG_obj::camera->scroll;
HXDLIN( 425)								Float y = _gthis->cameraFollowPointer->getMidpoint(null())->y;
HXDLIN( 425)								this2->set_y((y - (( (Float)(::flixel::FlxG_obj::height) ) / ( (Float)(2) ))));
            							}
            						}
            					}
            				}
            			}
HXLINE( 426)			bool templateCharacter10;
HXDLIN( 426)			if (::hx::IsNotNull( _gthis->character )) {
HXLINE( 426)				templateCharacter10 = ::hx::IsNull( _gthis->cameraFollowPointer );
            			}
            			else {
HXLINE( 426)				templateCharacter10 = true;
            			}
HXDLIN( 426)			if (!(templateCharacter10)) {
HXLINE( 426)				Float offX3 = ( (Float)(0) );
HXDLIN( 426)				Float offY3 = ( (Float)(0) );
HXDLIN( 426)				if (!(_gthis->character->isPlayer)) {
HXLINE( 426)					Float offX4 = (_gthis->character->getMidpoint(null())->x + 150);
HXLINE(1106)					offX3 = (offX4 + _gthis->character->cameraPosition->__get(0));
HXLINE( 426)					Float offY4 = (_gthis->character->getMidpoint(null())->y - ( (Float)(100) ));
HXLINE(1107)					offY3 = (offY4 + _gthis->character->cameraPosition->__get(1));
            				}
            				else {
HXLINE( 426)					Float offX5 = (_gthis->character->getMidpoint(null())->x - ( (Float)(100) ));
HXLINE(1111)					offX3 = (offX5 - _gthis->character->cameraPosition->__get(0));
HXLINE( 426)					Float offY5 = (_gthis->character->getMidpoint(null())->y - ( (Float)(100) ));
HXLINE(1112)					offY3 = (offY5 + _gthis->character->cameraPosition->__get(1));
            				}
HXLINE( 426)				_gthis->cameraFollowPointer->setPosition(offX3,offY3);
HXDLIN( 426)				{
HXLINE( 426)					{
HXLINE( 426)						 ::flixel::math::FlxBasePoint this3 = ::flixel::FlxG_obj::camera->scroll;
HXDLIN( 426)						Float x1 = _gthis->cameraFollowPointer->getMidpoint(null())->x;
HXDLIN( 426)						this3->set_x((x1 - (( (Float)(::flixel::FlxG_obj::width) ) / ( (Float)(2) ))));
            					}
HXDLIN( 426)					{
HXLINE( 426)						 ::flixel::math::FlxBasePoint this4 = ::flixel::FlxG_obj::camera->scroll;
HXDLIN( 426)						Float y1 = _gthis->cameraFollowPointer->getMidpoint(null())->y;
HXDLIN( 426)						this4->set_y((y1 - (( (Float)(::flixel::FlxG_obj::height) ) / ( (Float)(2) ))));
            					}
            				}
            			}
HXLINE( 427)			_gthis->reloadCharacterDropDown();
HXLINE( 428)			{
HXLINE( 428)				_gthis->healthColorStepperR->set_value(( (Float)(_gthis->character->healthColorArray->__get(0)) ));
HXDLIN( 428)				_gthis->healthColorStepperG->set_value(( (Float)(_gthis->character->healthColorArray->__get(1)) ));
HXDLIN( 428)				_gthis->healthColorStepperB->set_value(( (Float)(_gthis->character->healthColorArray->__get(2)) ));
HXDLIN( 428)				 ::flixel::FlxSprite _gthis1 = _gthis->healthBar->leftBar;
HXDLIN( 428)				 ::flixel::FlxSprite _gthis2 = _gthis->healthBar->rightBar;
HXDLIN( 428)				int Red = _gthis->character->healthColorArray->__get(0);
HXDLIN( 428)				int Green = _gthis->character->healthColorArray->__get(1);
HXDLIN( 428)				int Blue = _gthis->character->healthColorArray->__get(2);
HXDLIN( 428)				int Alpha = 255;
HXDLIN( 428)				int color = ::flixel::util::_FlxColor::FlxColor_Impl__obj::_new(null());
HXDLIN( 428)				{
HXLINE( 428)					color = (color & -16711681);
HXDLIN( 428)					int color1;
HXDLIN( 428)					if ((Red > 255)) {
HXLINE( 428)						color1 = 255;
            					}
            					else {
HXLINE( 428)						if ((Red < 0)) {
HXLINE( 428)							color1 = 0;
            						}
            						else {
HXLINE( 428)							color1 = Red;
            						}
            					}
HXDLIN( 428)					color = (color | (color1 << 16));
            				}
HXDLIN( 428)				{
HXLINE( 428)					color = (color & -65281);
HXDLIN( 428)					int color2;
HXDLIN( 428)					if ((Green > 255)) {
HXLINE( 428)						color2 = 255;
            					}
            					else {
HXLINE( 428)						if ((Green < 0)) {
HXLINE( 428)							color2 = 0;
            						}
            						else {
HXLINE( 428)							color2 = Green;
            						}
            					}
HXDLIN( 428)					color = (color | (color2 << 8));
            				}
HXDLIN( 428)				{
HXLINE( 428)					color = (color & -256);
HXDLIN( 428)					int color3;
HXDLIN( 428)					if ((Blue > 255)) {
HXLINE( 428)						color3 = 255;
            					}
            					else {
HXLINE( 428)						if ((Blue < 0)) {
HXLINE( 428)							color3 = 0;
            						}
            						else {
HXLINE( 428)							color3 = Blue;
            						}
            					}
HXDLIN( 428)					color = (color | color3);
            				}
HXDLIN( 428)				{
HXLINE( 428)					color = (color & 16777215);
HXDLIN( 428)					int color4;
HXDLIN( 428)					if ((Alpha > 255)) {
HXLINE( 428)						color4 = 255;
            					}
            					else {
HXLINE( 428)						if ((Alpha < 0)) {
HXLINE( 428)							color4 = 0;
            						}
            						else {
HXLINE( 428)							color4 = Alpha;
            						}
            					}
HXDLIN( 428)					color = (color | (color4 << 24));
            				}
HXDLIN( 428)				_gthis1->set_color(_gthis2->set_color(color));
HXDLIN( 428)				_gthis->healthIcon->changeIcon(_gthis->character->healthIcon,false);
HXDLIN( 428)				::String templateCharacter11 = (HX_("Character: ",6f,a2,f1,a2) + _gthis->_char);
HXDLIN( 428)				::backend::DiscordClient_obj::changePresence(HX_("Character Editor",84,45,58,b1),templateCharacter11,_gthis->healthIcon->getCharacter(),null(),null(),null());
            			}
            		}
            		HX_END_LOCAL_FUNC0((void))

            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_3, ::states::editors::CharacterEditorState,_gthis) HXARGC(2)
            		void _hx_run(int index,::String intended){
            			HX_GC_STACKFRAME(&_hx_pos_8fcf73527616c70a_435_addSettingsUI)
HXLINE( 436)			bool _hx_tmp;
HXDLIN( 436)			if (::hx::IsNotNull( intended )) {
HXLINE( 436)				_hx_tmp = (intended.length < 1);
            			}
            			else {
HXLINE( 436)				_hx_tmp = true;
            			}
HXDLIN( 436)			if (_hx_tmp) {
HXLINE( 436)				return;
            			}
HXLINE( 438)			::String characterPath = ((HX_("characters/",45,3c,bf,be) + intended) + HX_(".json",56,f1,d6,c2));
HXLINE( 439)			::String path = ::backend::Paths_obj::getPath(characterPath,HX_("TEXT",ad,94,ba,37),null(),true);
HXLINE( 441)			if (::sys::FileSystem_obj::exists(path)) {
HXLINE( 446)				_gthis->_char = intended;
HXLINE( 447)				_gthis->check_player->set_checked(_gthis->character->isPlayer);
HXLINE( 448)				_gthis->addCharacter(null());
HXLINE( 449)				_gthis->reloadCharacterOptions();
HXLINE( 450)				_gthis->reloadCharacterDropDown();
HXLINE( 451)				bool _hx_tmp1;
HXDLIN( 451)				if (::hx::IsNotNull( _gthis->character )) {
HXLINE( 451)					_hx_tmp1 = ::hx::IsNull( _gthis->cameraFollowPointer );
            				}
            				else {
HXLINE( 451)					_hx_tmp1 = true;
            				}
HXDLIN( 451)				if (!(_hx_tmp1)) {
HXLINE( 451)					Float offX = ( (Float)(0) );
HXDLIN( 451)					Float offY = ( (Float)(0) );
HXDLIN( 451)					if (!(_gthis->character->isPlayer)) {
HXLINE( 451)						Float offX1 = (_gthis->character->getMidpoint(null())->x + 150);
HXLINE(1106)						offX = (offX1 + _gthis->character->cameraPosition->__get(0));
HXLINE( 451)						Float offY1 = (_gthis->character->getMidpoint(null())->y - ( (Float)(100) ));
HXLINE(1107)						offY = (offY1 + _gthis->character->cameraPosition->__get(1));
            					}
            					else {
HXLINE( 451)						Float offX2 = (_gthis->character->getMidpoint(null())->x - ( (Float)(100) ));
HXLINE(1111)						offX = (offX2 - _gthis->character->cameraPosition->__get(0));
HXLINE( 451)						Float offY2 = (_gthis->character->getMidpoint(null())->y - ( (Float)(100) ));
HXLINE(1112)						offY = (offY2 + _gthis->character->cameraPosition->__get(1));
            					}
HXLINE( 451)					_gthis->cameraFollowPointer->setPosition(offX,offY);
HXDLIN( 451)					{
HXLINE( 451)						{
HXLINE( 451)							 ::flixel::math::FlxBasePoint this1 = ::flixel::FlxG_obj::camera->scroll;
HXDLIN( 451)							Float x = _gthis->cameraFollowPointer->getMidpoint(null())->x;
HXDLIN( 451)							this1->set_x((x - (( (Float)(::flixel::FlxG_obj::width) ) / ( (Float)(2) ))));
            						}
HXDLIN( 451)						{
HXLINE( 451)							 ::flixel::math::FlxBasePoint this2 = ::flixel::FlxG_obj::camera->scroll;
HXDLIN( 451)							Float y = _gthis->cameraFollowPointer->getMidpoint(null())->y;
HXDLIN( 451)							this2->set_y((y - (( (Float)(::flixel::FlxG_obj::height) ) / ( (Float)(2) ))));
            						}
            					}
            				}
            			}
            			else {
HXLINE( 455)				_gthis->reloadCharacterDropDown();
HXLINE( 456)				 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp2 = ::flixel::FlxG_obj::sound;
HXDLIN( 456)				_hx_tmp2->play(::backend::Paths_obj::returnSound((HX_("sounds/",eb,02,a5,b6) + HX_("cancelMenu",39,a4,43,b7)),null(),true,null()),null(),null(),null(),null(),null());
            			}
            		}
            		HX_END_LOCAL_FUNC2((void))

            	HX_GC_STACKFRAME(&_hx_pos_8fcf73527616c70a_375_addSettingsUI)
HXDLIN( 375)		 ::states::editors::CharacterEditorState _gthis = ::hx::ObjectPtr<OBJ_>(this);
HXLINE( 376)		 ::flixel::group::FlxTypedSpriteGroup tab_group = this->UI_box->getTab(HX_("Settings",03,39,ef,64))->menu;
HXLINE( 378)		this->check_player =  ::backend::ui::PsychUICheckBox_obj::__alloc( HX_CTX ,( (Float)(10) ),( (Float)(60) ),HX_("Playable Character",97,3e,18,db),100,null());
HXLINE( 379)		this->check_player->set_checked(this->character->isPlayer);
HXLINE( 380)		this->check_player->onClick =  ::Dynamic(new _hx_Closure_0(_gthis));
HXLINE( 388)		 ::backend::ui::PsychUIButton reloadCharacter =  ::backend::ui::PsychUIButton_obj::__alloc( HX_CTX ,140,20,HX_("Reload Char",fd,9c,14,46), ::Dynamic(new _hx_Closure_1(_gthis)),null(),null());
HXLINE( 396)		 ::backend::ui::PsychUIButton templateCharacter =  ::backend::ui::PsychUIButton_obj::__alloc( HX_CTX ,140,50,HX_("Load Template",74,05,aa,0c), ::Dynamic(new _hx_Closure_2(_gthis)),null(),null());
HXLINE( 430)		templateCharacter->normalStyle->__SetField(HX_("bgColor",5e,81,83,f7),-65536,::hx::paccDynamic);
HXLINE( 431)		templateCharacter->normalStyle->__SetField(HX_("textColor",76,01,4a,e3),-1,::hx::paccDynamic);
HXLINE( 434)		this->charDropDown =  ::backend::ui::PsychUIDropDownMenu_obj::__alloc( HX_CTX ,( (Float)(10) ),( (Float)(30) ),::Array_obj< ::String >::fromData( _hx_array_data_788c020f_29,1), ::Dynamic(new _hx_Closure_3(_gthis)),null());
HXLINE( 459)		this->reloadCharacterDropDown();
HXLINE( 460)		this->charDropDown->set_selectedLabel(this->_char);
HXLINE( 462)		tab_group->add( ::flixel::text::FlxText_obj::__alloc( HX_CTX ,this->charDropDown->x,(this->charDropDown->y - ( (Float)(18) )),80,HX_("Character:",91,5c,7f,4c),null(),null())).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 463)		tab_group->add(this->check_player).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 464)		tab_group->add(reloadCharacter).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 465)		tab_group->add(templateCharacter).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 466)		tab_group->add(this->charDropDown).StaticCast<  ::flixel::FlxSprite >();
            	}


HX_DEFINE_DYNAMIC_FUNC0(CharacterEditorState_obj,addSettingsUI,(void))

void CharacterEditorState_obj::addAnimationsUI(){
            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_0, ::states::editors::CharacterEditorState,_gthis) HXARGC(2)
            		void _hx_run(int selectedAnimation,::String pressed){
            			HX_GC_STACKFRAME(&_hx_pos_8fcf73527616c70a_485_addAnimationsUI)
HXLINE( 486)			 ::Dynamic anim = _gthis->character->animationsArray->__get(selectedAnimation);
HXLINE( 487)			_gthis->animationInputText->set_text(( (::String)(anim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)) ));
HXLINE( 488)			_gthis->animationNameInputText->set_text(( (::String)(anim->__Field(HX_("name",4b,72,ff,48),::hx::paccDynamic)) ));
HXLINE( 489)			_gthis->animationLoopCheckBox->set_checked( ::Dynamic(anim->__Field(HX_("loop",64,a6,b7,47),::hx::paccDynamic)));
HXLINE( 490)			_gthis->animationFramerate->set_value(( (Float)(anim->__Field(HX_("fps",e9,c7,4d,00),::hx::paccDynamic)) ));
HXLINE( 492)			::String indicesStr = ( (::Array< int >)(anim->__Field(HX_("indices",27,47,54,e3),::hx::paccDynamic)) )->toString();
HXLINE( 493)			 ::backend::ui::PsychUIInputText _gthis1 = _gthis->animationIndicesInputText;
HXDLIN( 493)			_gthis1->set_text(indicesStr.substr(1,(indicesStr.length - 2)));
            		}
            		HX_END_LOCAL_FUNC2((void))

            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_1, ::states::editors::CharacterEditorState,_gthis) HXARGC(0)
            		void _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_8fcf73527616c70a_496_addAnimationsUI)
HXLINE( 497)			::String indicesText = ::StringTools_obj::trim(_gthis->animationIndicesInputText->text);
HXLINE( 498)			::Array< int > indices = ::Array_obj< int >::__new(0);
HXLINE( 499)			if ((indicesText.length > 0)) {
HXLINE( 501)				::Array< ::String > indicesStr = ::StringTools_obj::trim(_gthis->animationIndicesInputText->text).split(HX_(",",2c,00,00,00));
HXLINE( 502)				if ((indicesStr->length > 0)) {
HXLINE( 504)					int _g = 0;
HXDLIN( 504)					while((_g < indicesStr->length)){
HXLINE( 504)						::String ind = indicesStr->__get(_g);
HXDLIN( 504)						_g = (_g + 1);
HXLINE( 506)						if ((ind.indexOf(HX_("-",2d,00,00,00),null()) != -1)) {
HXLINE( 508)							::Array< ::String > splitIndices = ind.split(HX_("-",2d,00,00,00));
HXLINE( 509)							int indexStart = ( (int)(::Std_obj::parseInt(splitIndices->__get(0))) );
HXLINE( 510)							bool addUpdateButton;
HXDLIN( 510)							if (!(::Math_obj::isNaN(( (Float)(indexStart) )))) {
HXLINE( 510)								addUpdateButton = (indexStart < 0);
            							}
            							else {
HXLINE( 510)								addUpdateButton = true;
            							}
HXDLIN( 510)							if (addUpdateButton) {
HXLINE( 510)								indexStart = 0;
            							}
HXLINE( 512)							int indexEnd = ( (int)(::Std_obj::parseInt(splitIndices->__get(1))) );
HXLINE( 513)							bool addUpdateButton1;
HXDLIN( 513)							if (!(::Math_obj::isNaN(( (Float)(indexEnd) )))) {
HXLINE( 513)								addUpdateButton1 = (indexEnd < indexStart);
            							}
            							else {
HXLINE( 513)								addUpdateButton1 = true;
            							}
HXDLIN( 513)							if (addUpdateButton1) {
HXLINE( 513)								indexEnd = indexStart;
            							}
HXLINE( 515)							{
HXLINE( 515)								int _g1 = indexStart;
HXDLIN( 515)								int _g2 = (indexEnd + 1);
HXDLIN( 515)								while((_g1 < _g2)){
HXLINE( 515)									_g1 = (_g1 + 1);
HXDLIN( 515)									int index = (_g1 - 1);
HXLINE( 516)									indices->push(index);
            								}
            							}
            						}
            						else {
HXLINE( 520)							int index1 = ( (int)(::Std_obj::parseInt(ind)) );
HXLINE( 521)							bool addUpdateButton2;
HXDLIN( 521)							if (!(::Math_obj::isNaN(( (Float)(index1) )))) {
HXLINE( 521)								addUpdateButton2 = (index1 > -1);
            							}
            							else {
HXLINE( 521)								addUpdateButton2 = false;
            							}
HXDLIN( 521)							if (addUpdateButton2) {
HXLINE( 522)								indices->push(index1);
            							}
            						}
            					}
            				}
            			}
HXLINE( 528)			::String lastAnim;
HXDLIN( 528)			if (::hx::IsNotNull( _gthis->character->animationsArray->__get(_gthis->curAnim) )) {
HXLINE( 528)				lastAnim = ( (::String)(_gthis->character->animationsArray->__get(_gthis->curAnim)->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)) );
            			}
            			else {
HXLINE( 528)				lastAnim = HX_("",00,00,00,00);
            			}
HXLINE( 529)			::Array< int > lastOffsets = ::Array_obj< int >::fromData( _hx_array_data_788c020f_39,2);
HXLINE( 530)			{
HXLINE( 530)				int _g3 = 0;
HXDLIN( 530)				::Array< ::Dynamic> _g4 = _gthis->character->animationsArray;
HXDLIN( 530)				while((_g3 < _g4->length)){
HXLINE( 530)					 ::Dynamic anim = _g4->__get(_g3);
HXDLIN( 530)					_g3 = (_g3 + 1);
HXLINE( 531)					if (::hx::IsEq( _gthis->animationInputText->text,anim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic) )) {
HXLINE( 532)						lastOffsets = ( (::Array< int >)(anim->__Field(HX_("offsets",80,09,65,d7),::hx::paccDynamic)) );
HXLINE( 533)						if (_gthis->character->hasAnimation(_gthis->animationInputText->text)) {
HXLINE( 535)							if (!(_gthis->character->isAnimateAtlas)) {
HXLINE( 535)								_gthis->character->animation->remove(_gthis->animationInputText->text);
            							}
            							else {
HXLINE( 536)								_gthis->character->atlas->anim->animsMap->remove(_gthis->animationInputText->text);
            							}
            						}
HXLINE( 538)						_gthis->character->animationsArray->remove(anim);
            					}
            				}
            			}
HXLINE( 541)			 ::Dynamic addedAnim =  ::Dynamic(::hx::Anon_obj::Create(6)
            				->setFixed(0,HX_("offsets",80,09,65,d7),::Array_obj< int >::fromData( _hx_array_data_788c020f_40,2))
            				->setFixed(1,HX_("indices",27,47,54,e3),::Array_obj< int >::__new(0))
            				->setFixed(2,HX_("fps",e9,c7,4d,00),24)
            				->setFixed(3,HX_("anim",11,86,71,40),_gthis->animationInputText->text)
            				->setFixed(4,HX_("loop",64,a6,b7,47),false)
            				->setFixed(5,HX_("name",4b,72,ff,48),_gthis->animationNameInputText->text));
HXLINE( 542)			addedAnim->__SetField(HX_("fps",e9,c7,4d,00),::Math_obj::round(_gthis->animationFramerate->value),::hx::paccDynamic);
HXLINE( 543)			addedAnim->__SetField(HX_("loop",64,a6,b7,47),_gthis->animationLoopCheckBox->checked,::hx::paccDynamic);
HXLINE( 544)			addedAnim->__SetField(HX_("indices",27,47,54,e3),indices,::hx::paccDynamic);
HXLINE( 545)			addedAnim->__SetField(HX_("offsets",80,09,65,d7),lastOffsets,::hx::paccDynamic);
HXLINE( 546)			_gthis->addAnimation(( (::String)(addedAnim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)) ),( (::String)(addedAnim->__Field(HX_("name",4b,72,ff,48),::hx::paccDynamic)) ),( (Float)(addedAnim->__Field(HX_("fps",e9,c7,4d,00),::hx::paccDynamic)) ),( (bool)(addedAnim->__Field(HX_("loop",64,a6,b7,47),::hx::paccDynamic)) ),( (::Array< int >)(addedAnim->__Field(HX_("indices",27,47,54,e3),::hx::paccDynamic)) ));
HXLINE( 547)			_gthis->character->animationsArray->push(addedAnim);
HXLINE( 549)			{
HXLINE( 549)				_gthis->anims = _gthis->character->animationsArray;
HXDLIN( 549)				if ((_gthis->anims->length > 0)) {
HXLINE( 549)					_gthis->character->playAnim(( (::String)(_gthis->anims->__get(0)->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)) ),true,null(),null());
            				}
HXDLIN( 549)				_gthis->curAnim = 0;
HXDLIN( 549)				{
HXLINE( 549)					_gthis->animsTxt->removeFormat(_gthis->selectedFormat,null(),null());
HXDLIN( 549)					::String intendText = HX_("",00,00,00,00);
HXDLIN( 549)					{
HXLINE( 549)						int _g_current = 0;
HXDLIN( 549)						::Array< ::Dynamic> _g_array = _gthis->anims;
HXDLIN( 549)						while((_g_current < _g_array->length)){
HXLINE( 549)							 ::Dynamic _g_value = _g_array->__get(_g_current);
HXDLIN( 549)							_g_current = (_g_current + 1);
HXDLIN( 549)							int _g_key = (_g_current - 1);
HXDLIN( 549)							int num = _g_key;
HXDLIN( 549)							 ::Dynamic anim1 = _g_value;
HXDLIN( 549)							{
HXLINE( 549)								if ((num > 0)) {
HXLINE( 549)									intendText = (intendText + HX_("\n",0a,00,00,00));
            								}
HXDLIN( 549)								if ((num == _gthis->curAnim)) {
HXLINE( 549)									int n = intendText.length;
HXDLIN( 549)									::String intendText1 = ( (::String)((anim1->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic) + HX_(": ",a6,32,00,00))) );
HXDLIN( 549)									intendText = (intendText + (intendText1 + ::Std_obj::string( ::Dynamic(anim1->__Field(HX_("offsets",80,09,65,d7),::hx::paccDynamic)))));
HXDLIN( 549)									_gthis->animsTxt->addFormat(_gthis->selectedFormat,n,intendText.length);
            								}
            								else {
HXLINE( 549)									::String intendText2 = ( (::String)((anim1->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic) + HX_(": ",a6,32,00,00))) );
HXDLIN( 549)									intendText = (intendText + (intendText2 + ::Std_obj::string( ::Dynamic(anim1->__Field(HX_("offsets",80,09,65,d7),::hx::paccDynamic)))));
            								}
            							}
            						}
            					}
HXDLIN( 549)					_gthis->animsTxt->set_text(intendText);
            				}
HXDLIN( 549)				if (::hx::IsNotNull( _gthis->animationDropDown )) {
HXLINE( 549)					_gthis->reloadAnimationDropDown();
            				}
            			}
HXLINE( 550)			Float addUpdateButton3 = ::Math_obj::max(( (Float)(0) ),( (Float)(_gthis->character->animationsArray->indexOf(addedAnim,null())) ));
HXDLIN( 550)			_gthis->curAnim = ::Std_obj::_hx_int(addUpdateButton3);
HXLINE( 551)			_gthis->character->playAnim(( (::String)(addedAnim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)) ),true,null(),null());
HXLINE( 552)			::haxe::Log_obj::trace((HX_("Added/Updated animation: ",f6,52,6a,23) + _gthis->animationInputText->text),::hx::SourceInfo(HX_("source/states/editors/CharacterEditorState.hx",41,39,ad,0d),552,HX_("states.editors.CharacterEditorState",0f,02,8c,78),HX_("addAnimationsUI",c4,44,96,30)));
            		}
            		HX_END_LOCAL_FUNC0((void))

            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_2, ::states::editors::CharacterEditorState,_gthis) HXARGC(0)
            		void _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_8fcf73527616c70a_556_addAnimationsUI)
HXLINE( 556)			int _g = 0;
HXDLIN( 556)			::Array< ::Dynamic> _g1 = _gthis->character->animationsArray;
HXDLIN( 556)			while((_g < _g1->length)){
HXLINE( 556)				 ::Dynamic anim = _g1->__get(_g);
HXDLIN( 556)				_g = (_g + 1);
HXLINE( 557)				if (::hx::IsEq( _gthis->animationInputText->text,anim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic) )) {
HXLINE( 559)					bool resetAnim = false;
HXLINE( 560)					if (::hx::IsEq( anim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic),_gthis->character->_lastPlayedAnimation )) {
HXLINE( 560)						resetAnim = true;
            					}
HXLINE( 561)					if (_gthis->character->hasAnimation(( (::String)(anim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)) ))) {
HXLINE( 563)						if (!(_gthis->character->isAnimateAtlas)) {
HXLINE( 563)							_gthis->character->animation->remove(( (::String)(anim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)) ));
            						}
            						else {
HXLINE( 564)							_gthis->character->atlas->anim->animsMap->remove(( (::String)(anim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)) ));
            						}
HXLINE( 565)						_gthis->character->animOffsets->remove(( (::String)(anim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)) ));
HXLINE( 566)						_gthis->character->animationsArray->remove(anim);
            					}
HXLINE( 569)					bool removeButton;
HXDLIN( 569)					if (resetAnim) {
HXLINE( 569)						removeButton = (_gthis->character->animationsArray->length > 0);
            					}
            					else {
HXLINE( 569)						removeButton = false;
            					}
HXDLIN( 569)					if (removeButton) {
HXLINE( 570)						_gthis->curAnim = ::flixel::math::FlxMath_obj::wrap(_gthis->curAnim,0,(_gthis->anims->length - 1));
HXLINE( 571)						_gthis->character->playAnim(( (::String)(_gthis->anims->__get(_gthis->curAnim)->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)) ),true,null(),null());
            					}
HXLINE( 573)					{
HXLINE( 573)						_gthis->anims = _gthis->character->animationsArray;
HXDLIN( 573)						if ((_gthis->anims->length > 0)) {
HXLINE( 573)							_gthis->character->playAnim(( (::String)(_gthis->anims->__get(0)->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)) ),true,null(),null());
            						}
HXDLIN( 573)						_gthis->curAnim = 0;
HXDLIN( 573)						{
HXLINE( 573)							_gthis->animsTxt->removeFormat(_gthis->selectedFormat,null(),null());
HXDLIN( 573)							::String intendText = HX_("",00,00,00,00);
HXDLIN( 573)							{
HXLINE( 573)								int _g_current = 0;
HXDLIN( 573)								::Array< ::Dynamic> _g_array = _gthis->anims;
HXDLIN( 573)								while((_g_current < _g_array->length)){
HXLINE( 573)									 ::Dynamic _g_value = _g_array->__get(_g_current);
HXDLIN( 573)									_g_current = (_g_current + 1);
HXDLIN( 573)									int _g_key = (_g_current - 1);
HXDLIN( 573)									int num = _g_key;
HXDLIN( 573)									 ::Dynamic anim1 = _g_value;
HXDLIN( 573)									{
HXLINE( 573)										if ((num > 0)) {
HXLINE( 573)											intendText = (intendText + HX_("\n",0a,00,00,00));
            										}
HXDLIN( 573)										if ((num == _gthis->curAnim)) {
HXLINE( 573)											int n = intendText.length;
HXDLIN( 573)											::String intendText1 = ( (::String)((anim1->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic) + HX_(": ",a6,32,00,00))) );
HXDLIN( 573)											intendText = (intendText + (intendText1 + ::Std_obj::string( ::Dynamic(anim1->__Field(HX_("offsets",80,09,65,d7),::hx::paccDynamic)))));
HXDLIN( 573)											_gthis->animsTxt->addFormat(_gthis->selectedFormat,n,intendText.length);
            										}
            										else {
HXLINE( 573)											::String intendText2 = ( (::String)((anim1->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic) + HX_(": ",a6,32,00,00))) );
HXDLIN( 573)											intendText = (intendText + (intendText2 + ::Std_obj::string( ::Dynamic(anim1->__Field(HX_("offsets",80,09,65,d7),::hx::paccDynamic)))));
            										}
            									}
            								}
            							}
HXDLIN( 573)							_gthis->animsTxt->set_text(intendText);
            						}
HXDLIN( 573)						if (::hx::IsNotNull( _gthis->animationDropDown )) {
HXLINE( 573)							_gthis->reloadAnimationDropDown();
            						}
            					}
HXLINE( 574)					::haxe::Log_obj::trace((HX_("Removed animation: ",0a,26,5e,26) + _gthis->animationInputText->text),::hx::SourceInfo(HX_("source/states/editors/CharacterEditorState.hx",41,39,ad,0d),574,HX_("states.editors.CharacterEditorState",0f,02,8c,78),HX_("addAnimationsUI",c4,44,96,30)));
HXLINE( 575)					goto _hx_goto_34;
            				}
            			}
            			_hx_goto_34:;
            		}
            		HX_END_LOCAL_FUNC0((void))

            	HX_GC_STACKFRAME(&_hx_pos_8fcf73527616c70a_476_addAnimationsUI)
HXDLIN( 476)		 ::states::editors::CharacterEditorState _gthis = ::hx::ObjectPtr<OBJ_>(this);
HXLINE( 477)		 ::flixel::group::FlxTypedSpriteGroup tab_group = this->UI_characterbox->getTab(HX_("Animations",0f,39,cd,79))->menu;
HXLINE( 479)		this->animationInputText =  ::backend::ui::PsychUIInputText_obj::__alloc( HX_CTX ,15,85,80,HX_("",00,00,00,00),8);
HXLINE( 480)		this->animationNameInputText =  ::backend::ui::PsychUIInputText_obj::__alloc( HX_CTX ,this->animationInputText->x,(this->animationInputText->y + 35),150,HX_("",00,00,00,00),8);
HXLINE( 481)		this->animationIndicesInputText =  ::backend::ui::PsychUIInputText_obj::__alloc( HX_CTX ,this->animationNameInputText->x,(this->animationNameInputText->y + 40),250,HX_("",00,00,00,00),8);
HXLINE( 482)		this->animationFramerate =  ::backend::ui::PsychUINumericStepper_obj::__alloc( HX_CTX ,(this->animationInputText->x + 170),this->animationInputText->y,1,24,0,240,0,null(),null());
HXLINE( 483)		this->animationLoopCheckBox =  ::backend::ui::PsychUICheckBox_obj::__alloc( HX_CTX ,(this->animationNameInputText->x + 170),(this->animationNameInputText->y - ( (Float)(1) )),HX_("Should it Loop?",b3,ec,08,ad),100,null());
HXLINE( 485)		this->animationDropDown =  ::backend::ui::PsychUIDropDownMenu_obj::__alloc( HX_CTX ,( (Float)(15) ),(this->animationInputText->y - ( (Float)(55) )),::Array_obj< ::String >::fromData( _hx_array_data_788c020f_43,1), ::Dynamic(new _hx_Closure_0(_gthis)),null());
HXLINE( 496)		 ::backend::ui::PsychUIButton addUpdateButton =  ::backend::ui::PsychUIButton_obj::__alloc( HX_CTX ,70,(this->animationIndicesInputText->y + 60),HX_("Add/Update",b7,cf,f4,ee), ::Dynamic(new _hx_Closure_1(_gthis)),null(),null());
HXLINE( 555)		 ::backend::ui::PsychUIButton removeButton =  ::backend::ui::PsychUIButton_obj::__alloc( HX_CTX ,180,(this->animationIndicesInputText->y + 60),HX_("Remove",64,10,1d,39), ::Dynamic(new _hx_Closure_2(_gthis)),null(),null());
HXLINE( 578)		{
HXLINE( 578)			this->anims = this->character->animationsArray;
HXDLIN( 578)			if ((this->anims->length > 0)) {
HXLINE( 578)				this->character->playAnim(( (::String)(this->anims->__get(0)->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)) ),true,null(),null());
            			}
HXDLIN( 578)			this->curAnim = 0;
HXDLIN( 578)			{
HXLINE( 578)				this->animsTxt->removeFormat(this->selectedFormat,null(),null());
HXDLIN( 578)				::String intendText = HX_("",00,00,00,00);
HXDLIN( 578)				{
HXLINE( 578)					int _g_current = 0;
HXDLIN( 578)					::Array< ::Dynamic> _g_array = this->anims;
HXDLIN( 578)					while((_g_current < _g_array->length)){
HXLINE( 578)						 ::Dynamic _g_value = _g_array->__get(_g_current);
HXDLIN( 578)						_g_current = (_g_current + 1);
HXDLIN( 578)						int _g_key = (_g_current - 1);
HXDLIN( 578)						int num = _g_key;
HXDLIN( 578)						 ::Dynamic anim = _g_value;
HXDLIN( 578)						{
HXLINE( 578)							if ((num > 0)) {
HXLINE( 578)								intendText = (intendText + HX_("\n",0a,00,00,00));
            							}
HXDLIN( 578)							if ((num == this->curAnim)) {
HXLINE( 578)								int n = intendText.length;
HXDLIN( 578)								::String intendText1 = ( (::String)((anim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic) + HX_(": ",a6,32,00,00))) );
HXDLIN( 578)								intendText = (intendText + (intendText1 + ::Std_obj::string( ::Dynamic(anim->__Field(HX_("offsets",80,09,65,d7),::hx::paccDynamic)))));
HXDLIN( 578)								this->animsTxt->addFormat(this->selectedFormat,n,intendText.length);
            							}
            							else {
HXLINE( 578)								::String intendText2 = ( (::String)((anim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic) + HX_(": ",a6,32,00,00))) );
HXDLIN( 578)								intendText = (intendText + (intendText2 + ::Std_obj::string( ::Dynamic(anim->__Field(HX_("offsets",80,09,65,d7),::hx::paccDynamic)))));
            							}
            						}
            					}
            				}
HXDLIN( 578)				this->animsTxt->set_text(intendText);
            			}
HXDLIN( 578)			if (::hx::IsNotNull( this->animationDropDown )) {
HXLINE( 578)				this->reloadAnimationDropDown();
            			}
            		}
HXLINE( 579)		::String _hx_tmp;
HXDLIN( 579)		if (::hx::IsNotNull( this->anims->__get(0) )) {
HXLINE( 579)			_hx_tmp = ( (::String)(this->anims->__get(0)->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)) );
            		}
            		else {
HXLINE( 579)			_hx_tmp = HX_("",00,00,00,00);
            		}
HXDLIN( 579)		this->animationDropDown->set_selectedLabel(_hx_tmp);
HXLINE( 581)		tab_group->add( ::flixel::text::FlxText_obj::__alloc( HX_CTX ,this->animationDropDown->x,(this->animationDropDown->y - ( (Float)(18) )),100,HX_("Animations:",4b,b4,c4,19),null(),null())).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 582)		tab_group->add( ::flixel::text::FlxText_obj::__alloc( HX_CTX ,this->animationInputText->x,(this->animationInputText->y - ( (Float)(18) )),100,HX_("Animation name:",53,2d,e4,9c),null(),null())).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 583)		tab_group->add( ::flixel::text::FlxText_obj::__alloc( HX_CTX ,this->animationFramerate->x,(this->animationFramerate->y - ( (Float)(18) )),100,HX_("Framerate:",2d,fa,cd,2a),null(),null())).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 584)		tab_group->add( ::flixel::text::FlxText_obj::__alloc( HX_CTX ,this->animationNameInputText->x,(this->animationNameInputText->y - ( (Float)(18) )),150,HX_("Animation Symbol Name/Tag:",38,f8,f7,f4),null(),null())).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 585)		tab_group->add( ::flixel::text::FlxText_obj::__alloc( HX_CTX ,this->animationIndicesInputText->x,(this->animationIndicesInputText->y - ( (Float)(18) )),170,HX_("ADVANCED - Animation Indices:",60,cb,cb,a8),null(),null())).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 587)		tab_group->add(this->animationInputText).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 588)		tab_group->add(this->animationNameInputText).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 589)		tab_group->add(this->animationIndicesInputText).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 590)		tab_group->add(this->animationFramerate).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 591)		tab_group->add(this->animationLoopCheckBox).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 592)		tab_group->add(addUpdateButton).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 593)		tab_group->add(removeButton).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 594)		tab_group->add(this->animationDropDown).StaticCast<  ::flixel::FlxSprite >();
            	}


HX_DEFINE_DYNAMIC_FUNC0(CharacterEditorState_obj,addAnimationsUI,(void))

void CharacterEditorState_obj::addCharacterUI(){
            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_0, ::states::editors::CharacterEditorState,_gthis) HXARGC(0)
            		void _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_8fcf73527616c70a_620_addCharacterUI)
HXLINE( 621)			::String lastAnim = _gthis->character->_lastPlayedAnimation;
HXLINE( 622)			_gthis->character->imageFile = _gthis->imageInputText->text;
HXLINE( 623)			_gthis->reloadCharacterImage();
HXLINE( 624)			 ::objects::Character _this = _gthis->character;
HXDLIN( 624)			bool reloadImage;
HXDLIN( 624)			if (!(_this->isAnimateAtlas)) {
HXLINE( 624)				reloadImage = ::hx::IsNull( _this->animation->_curAnim );
            			}
            			else {
HXLINE( 624)				if (::hx::IsNotNull( _this->atlas->anim->curInstance )) {
HXLINE( 624)					reloadImage = ::hx::IsNull( _this->atlas->anim->get_curSymbol() );
            				}
            				else {
HXLINE( 624)					reloadImage = true;
            				}
            			}
HXDLIN( 624)			if (!(reloadImage)) {
HXLINE( 625)				_gthis->character->playAnim(lastAnim,true,null(),null());
            			}
            		}
            		HX_END_LOCAL_FUNC0((void))

            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_1, ::states::editors::CharacterEditorState,_gthis) HXARGC(0)
            		void _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_8fcf73527616c70a_630_addCharacterUI)
HXLINE( 631)			 ::flixel::FlxSprite sprite = _gthis->healthIcon;
HXDLIN( 631)			 ::haxe::ds::IntMap countByColor =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXDLIN( 631)			{
HXLINE( 631)				int _g = 0;
HXDLIN( 631)				int _g1 = sprite->frameWidth;
HXDLIN( 631)				while((_g < _g1)){
HXLINE( 631)					_g = (_g + 1);
HXDLIN( 631)					int col = (_g - 1);
HXDLIN( 631)					{
HXLINE( 631)						int _g2 = 0;
HXDLIN( 631)						int _g3 = sprite->frameHeight;
HXDLIN( 631)						while((_g2 < _g3)){
HXLINE( 631)							_g2 = (_g2 + 1);
HXDLIN( 631)							int row = (_g2 - 1);
HXDLIN( 631)							int colorOfThisPixel = sprite->get_pixels()->getPixel32(col,row);
HXDLIN( 631)							if (((( (Float)(((colorOfThisPixel >> 24) & 255)) ) / ( (Float)(255) )) > ((Float)0.05))) {
HXLINE( 631)								int Red = ((colorOfThisPixel >> 16) & 255);
HXDLIN( 631)								int Green = ((colorOfThisPixel >> 8) & 255);
HXDLIN( 631)								int Blue = (colorOfThisPixel & 255);
HXDLIN( 631)								int color = ::flixel::util::_FlxColor::FlxColor_Impl__obj::_new(null());
HXDLIN( 631)								{
HXLINE( 631)									color = (color & -16711681);
HXDLIN( 631)									int color1;
HXDLIN( 631)									if ((Red > 255)) {
HXLINE( 631)										color1 = 255;
            									}
            									else {
HXLINE( 631)										if ((Red < 0)) {
HXLINE( 631)											color1 = 0;
            										}
            										else {
HXLINE( 631)											color1 = Red;
            										}
            									}
HXDLIN( 631)									color = (color | (color1 << 16));
            								}
HXDLIN( 631)								{
HXLINE( 631)									color = (color & -65281);
HXDLIN( 631)									int color2;
HXDLIN( 631)									if ((Green > 255)) {
HXLINE( 631)										color2 = 255;
            									}
            									else {
HXLINE( 631)										if ((Green < 0)) {
HXLINE( 631)											color2 = 0;
            										}
            										else {
HXLINE( 631)											color2 = Green;
            										}
            									}
HXDLIN( 631)									color = (color | (color2 << 8));
            								}
HXDLIN( 631)								{
HXLINE( 631)									color = (color & -256);
HXDLIN( 631)									int color3;
HXDLIN( 631)									if ((Blue > 255)) {
HXLINE( 631)										color3 = 255;
            									}
            									else {
HXLINE( 631)										if ((Blue < 0)) {
HXLINE( 631)											color3 = 0;
            										}
            										else {
HXLINE( 631)											color3 = Blue;
            										}
            									}
HXDLIN( 631)									color = (color | color3);
            								}
HXDLIN( 631)								{
HXLINE( 631)									color = (color & 16777215);
HXDLIN( 631)									color = (color | -16777216);
            								}
HXDLIN( 631)								colorOfThisPixel = color;
HXDLIN( 631)								int count;
HXDLIN( 631)								if (countByColor->exists(colorOfThisPixel)) {
HXLINE( 631)									count = ( (int)(countByColor->get(colorOfThisPixel)) );
            								}
            								else {
HXLINE( 631)									count = 0;
            								}
HXDLIN( 631)								{
HXLINE( 631)									int v = (count + 1);
HXDLIN( 631)									countByColor->set(colorOfThisPixel,v);
            								}
            							}
            						}
            					}
            				}
            			}
HXDLIN( 631)			int maxCount = 0;
HXDLIN( 631)			int maxKey = 0;
HXDLIN( 631)			countByColor->set(-16777216,0);
HXDLIN( 631)			{
HXLINE( 631)				::Dynamic map = countByColor;
HXDLIN( 631)				::Dynamic _g_map = map;
HXDLIN( 631)				 ::Dynamic _g_keys = ::haxe::IMap_obj::keys(map);
HXDLIN( 631)				while(( (bool)(_g_keys->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 631)					int key = ( (int)(_g_keys->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 631)					int _g_value = ( (int)(::haxe::IMap_obj::get(_g_map,key)) );
HXDLIN( 631)					int _g_key = key;
HXDLIN( 631)					int key1 = _g_key;
HXDLIN( 631)					int count1 = _g_value;
HXDLIN( 631)					if ((count1 >= maxCount)) {
HXLINE( 109)						maxCount = count1;
HXLINE( 110)						maxKey = key1;
            					}
            				}
            			}
HXLINE( 113)			countByColor =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXLINE( 631)			int coolColor = ::flixel::util::_FlxColor::FlxColor_Impl__obj::_new(maxKey);
HXLINE( 632)			_gthis->character->healthColorArray[0] = ((coolColor >> 16) & 255);
HXLINE( 633)			_gthis->character->healthColorArray[1] = ((coolColor >> 8) & 255);
HXLINE( 634)			_gthis->character->healthColorArray[2] = (coolColor & 255);
HXLINE( 635)			{
HXLINE( 635)				_gthis->healthColorStepperR->set_value(( (Float)(_gthis->character->healthColorArray->__get(0)) ));
HXDLIN( 635)				_gthis->healthColorStepperG->set_value(( (Float)(_gthis->character->healthColorArray->__get(1)) ));
HXDLIN( 635)				_gthis->healthColorStepperB->set_value(( (Float)(_gthis->character->healthColorArray->__get(2)) ));
HXDLIN( 635)				 ::flixel::FlxSprite _gthis1 = _gthis->healthBar->leftBar;
HXDLIN( 635)				 ::flixel::FlxSprite _gthis2 = _gthis->healthBar->rightBar;
HXDLIN( 635)				int Red1 = _gthis->character->healthColorArray->__get(0);
HXDLIN( 635)				int Green1 = _gthis->character->healthColorArray->__get(1);
HXDLIN( 635)				int Blue1 = _gthis->character->healthColorArray->__get(2);
HXDLIN( 635)				int Alpha = 255;
HXDLIN( 635)				int color4 = ::flixel::util::_FlxColor::FlxColor_Impl__obj::_new(null());
HXDLIN( 635)				{
HXLINE( 635)					color4 = (color4 & -16711681);
HXDLIN( 635)					int color5;
HXDLIN( 635)					if ((Red1 > 255)) {
HXLINE( 635)						color5 = 255;
            					}
            					else {
HXLINE( 635)						if ((Red1 < 0)) {
HXLINE( 635)							color5 = 0;
            						}
            						else {
HXLINE( 635)							color5 = Red1;
            						}
            					}
HXDLIN( 635)					color4 = (color4 | (color5 << 16));
            				}
HXDLIN( 635)				{
HXLINE( 635)					color4 = (color4 & -65281);
HXDLIN( 635)					int color6;
HXDLIN( 635)					if ((Green1 > 255)) {
HXLINE( 635)						color6 = 255;
            					}
            					else {
HXLINE( 635)						if ((Green1 < 0)) {
HXLINE( 635)							color6 = 0;
            						}
            						else {
HXLINE( 635)							color6 = Green1;
            						}
            					}
HXDLIN( 635)					color4 = (color4 | (color6 << 8));
            				}
HXDLIN( 635)				{
HXLINE( 635)					color4 = (color4 & -256);
HXDLIN( 635)					int color7;
HXDLIN( 635)					if ((Blue1 > 255)) {
HXLINE( 635)						color7 = 255;
            					}
            					else {
HXLINE( 635)						if ((Blue1 < 0)) {
HXLINE( 635)							color7 = 0;
            						}
            						else {
HXLINE( 635)							color7 = Blue1;
            						}
            					}
HXDLIN( 635)					color4 = (color4 | color7);
            				}
HXDLIN( 635)				{
HXLINE( 635)					color4 = (color4 & 16777215);
HXDLIN( 635)					int color8;
HXDLIN( 635)					if ((Alpha > 255)) {
HXLINE( 635)						color8 = 255;
            					}
            					else {
HXLINE( 635)						if ((Alpha < 0)) {
HXLINE( 635)							color8 = 0;
            						}
            						else {
HXLINE( 635)							color8 = Alpha;
            						}
            					}
HXDLIN( 635)					color4 = (color4 | (color8 << 24));
            				}
HXDLIN( 635)				_gthis1->set_color(_gthis2->set_color(color4));
HXDLIN( 635)				_gthis->healthIcon->changeIcon(_gthis->character->healthIcon,false);
HXDLIN( 635)				::String decideIconColor = (HX_("Character: ",6f,a2,f1,a2) + _gthis->_char);
HXDLIN( 635)				::backend::DiscordClient_obj::changePresence(HX_("Character Editor",84,45,58,b1),decideIconColor,_gthis->healthIcon->getCharacter(),null(),null(),null());
            			}
            		}
            		HX_END_LOCAL_FUNC0((void))

            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_2, ::states::editors::CharacterEditorState,_gthis) HXARGC(0)
            		void _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_8fcf73527616c70a_649_addCharacterUI)
HXLINE( 650)			_gthis->character->originalFlipX = !(_gthis->character->originalFlipX);
HXLINE( 651)			_gthis->character->set_flipX((_gthis->character->originalFlipX != _gthis->character->isPlayer));
            		}
            		HX_END_LOCAL_FUNC0((void))

            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_3, ::states::editors::CharacterEditorState,_gthis) HXARGC(0)
            		void _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_8fcf73527616c70a_656_addCharacterUI)
HXLINE( 657)			_gthis->character->set_antialiasing(false);
HXLINE( 658)			bool _hx_tmp;
HXDLIN( 658)			if (!(_gthis->noAntialiasingCheckBox->checked)) {
HXLINE( 658)				_hx_tmp = ::backend::ClientPrefs_obj::data->antialiasing;
            			}
            			else {
HXLINE( 658)				_hx_tmp = false;
            			}
HXDLIN( 658)			if (_hx_tmp) {
HXLINE( 659)				_gthis->character->set_antialiasing(true);
            			}
HXLINE( 661)			_gthis->character->noAntialiasing = _gthis->noAntialiasingCheckBox->checked;
            		}
            		HX_END_LOCAL_FUNC0((void))

            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_4, ::states::editors::CharacterEditorState,_gthis) HXARGC(0)
            		void _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_8fcf73527616c70a_671_addCharacterUI)
HXLINE( 671)			_gthis->saveCharacter();
            		}
            		HX_END_LOCAL_FUNC0((void))

            	HX_GC_STACKFRAME(&_hx_pos_8fcf73527616c70a_615_addCharacterUI)
HXDLIN( 615)		 ::states::editors::CharacterEditorState _gthis = ::hx::ObjectPtr<OBJ_>(this);
HXLINE( 616)		 ::flixel::group::FlxTypedSpriteGroup tab_group = this->UI_characterbox->getTab(HX_("Character",89,bb,a4,e3))->menu;
HXLINE( 618)		this->imageInputText =  ::backend::ui::PsychUIInputText_obj::__alloc( HX_CTX ,15,30,200,this->character->imageFile,8);
HXLINE( 619)		 ::backend::ui::PsychUIButton reloadImage =  ::backend::ui::PsychUIButton_obj::__alloc( HX_CTX ,(this->imageInputText->x + 210),(this->imageInputText->y - ( (Float)(3) )),HX_("Reload Image",54,43,aa,83), ::Dynamic(new _hx_Closure_0(_gthis)),null(),null());
HXLINE( 629)		 ::backend::ui::PsychUIButton decideIconColor =  ::backend::ui::PsychUIButton_obj::__alloc( HX_CTX ,reloadImage->x,(reloadImage->y + 30),HX_("Get Icon Color",e6,70,34,26), ::Dynamic(new _hx_Closure_1(_gthis)),null(),null());
HXLINE( 638)		Float _hx_tmp = (this->imageInputText->y + 35);
HXDLIN( 638)		this->healthIconInputText =  ::backend::ui::PsychUIInputText_obj::__alloc( HX_CTX ,15,_hx_tmp,75,this->healthIcon->getCharacter(),8);
HXLINE( 640)		::String _hx_tmp1;
HXDLIN( 640)		if (::hx::IsNotNull( this->character->vocalsFile )) {
HXLINE( 640)			_hx_tmp1 = this->character->vocalsFile;
            		}
            		else {
HXLINE( 640)			_hx_tmp1 = HX_("",00,00,00,00);
            		}
HXDLIN( 640)		this->vocalsInputText =  ::backend::ui::PsychUIInputText_obj::__alloc( HX_CTX ,15,(this->healthIconInputText->y + 35),75,_hx_tmp1,8);
HXLINE( 642)		this->singDurationStepper =  ::backend::ui::PsychUINumericStepper_obj::__alloc( HX_CTX ,15,(this->vocalsInputText->y + 45),((Float)0.1),4,0,999,1,null(),null());
HXLINE( 644)		this->scaleStepper =  ::backend::ui::PsychUINumericStepper_obj::__alloc( HX_CTX ,15,(this->singDurationStepper->y + 40),((Float)0.1),1,((Float)0.05),10,2,null(),null());
HXLINE( 646)		this->flipXCheckBox =  ::backend::ui::PsychUICheckBox_obj::__alloc( HX_CTX ,(this->singDurationStepper->x + 80),this->singDurationStepper->y,HX_("Flip X",45,68,fe,71),50,null());
HXLINE( 647)		this->flipXCheckBox->set_checked(this->character->flipX);
HXLINE( 648)		if (this->character->isPlayer) {
HXLINE( 648)			this->flipXCheckBox->set_checked(!(this->flipXCheckBox->checked));
            		}
HXLINE( 649)		this->flipXCheckBox->onClick =  ::Dynamic(new _hx_Closure_2(_gthis));
HXLINE( 654)		this->noAntialiasingCheckBox =  ::backend::ui::PsychUICheckBox_obj::__alloc( HX_CTX ,this->flipXCheckBox->x,(this->flipXCheckBox->y + 40),HX_("No Antialiasing",33,e6,a6,96),80,null());
HXLINE( 655)		this->noAntialiasingCheckBox->set_checked(this->character->noAntialiasing);
HXLINE( 656)		this->noAntialiasingCheckBox->onClick =  ::Dynamic(new _hx_Closure_3(_gthis));
HXLINE( 664)		this->positionXStepper =  ::backend::ui::PsychUINumericStepper_obj::__alloc( HX_CTX ,(this->flipXCheckBox->x + 110),this->flipXCheckBox->y,10,this->character->positionArray->__get(0),-9000,9000,0,null(),null());
HXLINE( 665)		this->positionYStepper =  ::backend::ui::PsychUINumericStepper_obj::__alloc( HX_CTX ,(this->positionXStepper->x + 70),this->positionXStepper->y,10,this->character->positionArray->__get(1),-9000,9000,0,null(),null());
HXLINE( 667)		this->positionCameraXStepper =  ::backend::ui::PsychUINumericStepper_obj::__alloc( HX_CTX ,this->positionXStepper->x,(this->positionXStepper->y + 40),10,this->character->cameraPosition->__get(0),-9000,9000,0,null(),null());
HXLINE( 668)		this->positionCameraYStepper =  ::backend::ui::PsychUINumericStepper_obj::__alloc( HX_CTX ,this->positionYStepper->x,(this->positionYStepper->y + 40),10,this->character->cameraPosition->__get(1),-9000,9000,0,null(),null());
HXLINE( 670)		 ::backend::ui::PsychUIButton saveCharacterButton =  ::backend::ui::PsychUIButton_obj::__alloc( HX_CTX ,reloadImage->x,(this->noAntialiasingCheckBox->y + 40),HX_("Save Character",06,25,12,9f), ::Dynamic(new _hx_Closure_4(_gthis)),null(),null());
HXLINE( 674)		this->healthColorStepperR =  ::backend::ui::PsychUINumericStepper_obj::__alloc( HX_CTX ,this->singDurationStepper->x,saveCharacterButton->y,20,this->character->healthColorArray->__get(0),0,255,0,null(),null());
HXLINE( 675)		this->healthColorStepperG =  ::backend::ui::PsychUINumericStepper_obj::__alloc( HX_CTX ,(this->singDurationStepper->x + 65),saveCharacterButton->y,20,this->character->healthColorArray->__get(1),0,255,0,null(),null());
HXLINE( 676)		this->healthColorStepperB =  ::backend::ui::PsychUINumericStepper_obj::__alloc( HX_CTX ,(this->singDurationStepper->x + 130),saveCharacterButton->y,20,this->character->healthColorArray->__get(2),0,255,0,null(),null());
HXLINE( 678)		tab_group->add( ::flixel::text::FlxText_obj::__alloc( HX_CTX ,15,(this->imageInputText->y - ( (Float)(18) )),100,HX_("Image file name:",b0,6b,31,2a),null(),null())).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 679)		tab_group->add( ::flixel::text::FlxText_obj::__alloc( HX_CTX ,15,(this->healthIconInputText->y - ( (Float)(18) )),100,HX_("Health icon name:",8c,30,c4,ea),null(),null())).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 680)		tab_group->add( ::flixel::text::FlxText_obj::__alloc( HX_CTX ,15,(this->vocalsInputText->y - ( (Float)(18) )),100,HX_("Vocals File Postfix:",27,4c,e5,30),null(),null())).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 681)		tab_group->add( ::flixel::text::FlxText_obj::__alloc( HX_CTX ,15,(this->singDurationStepper->y - ( (Float)(18) )),120,HX_("Sing Animation length:",67,31,1f,74),null(),null())).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 682)		tab_group->add( ::flixel::text::FlxText_obj::__alloc( HX_CTX ,15,(this->scaleStepper->y - ( (Float)(18) )),100,HX_("Scale:",90,5e,ba,70),null(),null())).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 683)		tab_group->add( ::flixel::text::FlxText_obj::__alloc( HX_CTX ,this->positionXStepper->x,(this->positionXStepper->y - ( (Float)(18) )),100,HX_("Character X/Y:",4f,22,5b,94),null(),null())).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 684)		tab_group->add( ::flixel::text::FlxText_obj::__alloc( HX_CTX ,this->positionCameraXStepper->x,(this->positionCameraXStepper->y - ( (Float)(18) )),100,HX_("Camera X/Y:",93,69,6c,ec),null(),null())).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 685)		tab_group->add( ::flixel::text::FlxText_obj::__alloc( HX_CTX ,this->healthColorStepperR->x,(this->healthColorStepperR->y - ( (Float)(18) )),100,HX_("Health Bar R/G/B:",8e,0b,d1,9f),null(),null())).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 686)		tab_group->add(this->imageInputText).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 687)		tab_group->add(reloadImage).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 688)		tab_group->add(decideIconColor).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 689)		tab_group->add(this->healthIconInputText).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 690)		tab_group->add(this->vocalsInputText).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 691)		tab_group->add(this->singDurationStepper).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 692)		tab_group->add(this->scaleStepper).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 693)		tab_group->add(this->flipXCheckBox).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 694)		tab_group->add(this->noAntialiasingCheckBox).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 695)		tab_group->add(this->positionXStepper).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 696)		tab_group->add(this->positionYStepper).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 697)		tab_group->add(this->positionCameraXStepper).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 698)		tab_group->add(this->positionCameraYStepper).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 699)		tab_group->add(this->healthColorStepperR).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 700)		tab_group->add(this->healthColorStepperG).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 701)		tab_group->add(this->healthColorStepperB).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 702)		tab_group->add(saveCharacterButton).StaticCast<  ::flixel::FlxSprite >();
            	}


HX_DEFINE_DYNAMIC_FUNC0(CharacterEditorState_obj,addCharacterUI,(void))

void CharacterEditorState_obj::UIEvent(::String id, ::Dynamic sender){
            	HX_STACKFRAME(&_hx_pos_8fcf73527616c70a_705_UIEvent)
HXLINE( 707)		if ((id == ::backend::ui::PsychUICheckBox_obj::CLICK_EVENT)) {
HXLINE( 708)			this->unsavedProgress = true;
            		}
HXLINE( 710)		if ((id == ::backend::ui::PsychUIInputText_obj::CHANGE_EVENT)) {
HXLINE( 712)			if (::hx::IsInstanceEq( sender,this->healthIconInputText )) {
HXLINE( 713)				::String lastIcon = this->healthIcon->getCharacter();
HXLINE( 714)				this->healthIcon->changeIcon(this->healthIconInputText->text,false);
HXLINE( 715)				this->character->healthIcon = this->healthIconInputText->text;
HXLINE( 716)				if ((lastIcon != this->healthIcon->getCharacter())) {
HXLINE( 716)					::String _hx_tmp = (HX_("Character: ",6f,a2,f1,a2) + this->_char);
HXDLIN( 716)					::backend::DiscordClient_obj::changePresence(HX_("Character Editor",84,45,58,b1),_hx_tmp,this->healthIcon->getCharacter(),null(),null(),null());
            				}
HXLINE( 717)				this->unsavedProgress = true;
            			}
            			else {
HXLINE( 719)				if (::hx::IsInstanceEq( sender,this->vocalsInputText )) {
HXLINE( 721)					this->character->vocalsFile = this->vocalsInputText->text;
HXLINE( 722)					this->unsavedProgress = true;
            				}
            				else {
HXLINE( 724)					if (::hx::IsInstanceEq( sender,this->imageInputText )) {
HXLINE( 726)						this->character->imageFile = this->imageInputText->text;
HXLINE( 727)						this->unsavedProgress = true;
            					}
            				}
            			}
            		}
            		else {
HXLINE( 730)			if ((id == ::backend::ui::PsychUINumericStepper_obj::CHANGE_EVENT)) {
HXLINE( 732)				if (::hx::IsInstanceEq( sender,this->scaleStepper )) {
HXLINE( 734)					this->reloadCharacterImage();
HXLINE( 735)					this->character->jsonScale = ( (Float)(sender->__Field(HX_("value",71,7f,b8,31),::hx::paccDynamic)) );
HXLINE( 736)					{
HXLINE( 736)						 ::flixel::math::FlxBasePoint this1 = this->character->scale;
HXDLIN( 736)						Float y = this->character->jsonScale;
HXDLIN( 736)						this1->set_x(this->character->jsonScale);
HXDLIN( 736)						this1->set_y(y);
            					}
HXLINE( 737)					this->character->updateHitbox();
HXLINE( 738)					{
HXLINE( 738)						 ::Dynamic snap = false;
HXDLIN( 738)						if (::hx::IsNull( snap )) {
HXLINE( 738)							snap = true;
            						}
HXDLIN( 738)						bool _hx_tmp1;
HXDLIN( 738)						if (::hx::IsNotNull( this->character )) {
HXLINE( 738)							_hx_tmp1 = ::hx::IsNull( this->cameraFollowPointer );
            						}
            						else {
HXLINE( 738)							_hx_tmp1 = true;
            						}
HXDLIN( 738)						if (!(_hx_tmp1)) {
HXLINE( 738)							Float offX = ( (Float)(0) );
HXDLIN( 738)							Float offY = ( (Float)(0) );
HXDLIN( 738)							if (!(this->character->isPlayer)) {
HXLINE( 738)								Float offX1 = (this->character->getMidpoint(null())->x + 150);
HXDLIN( 738)								offX = (offX1 + this->character->cameraPosition->__get(0));
HXDLIN( 738)								Float offY1 = (this->character->getMidpoint(null())->y - ( (Float)(100) ));
HXDLIN( 738)								offY = (offY1 + this->character->cameraPosition->__get(1));
            							}
            							else {
HXLINE( 738)								Float offX2 = (this->character->getMidpoint(null())->x - ( (Float)(100) ));
HXDLIN( 738)								offX = (offX2 - this->character->cameraPosition->__get(0));
HXDLIN( 738)								Float offY2 = (this->character->getMidpoint(null())->y - ( (Float)(100) ));
HXDLIN( 738)								offY = (offY2 + this->character->cameraPosition->__get(1));
            							}
HXDLIN( 738)							this->cameraFollowPointer->setPosition(offX,offY);
HXDLIN( 738)							if (( (bool)(snap) )) {
HXLINE( 738)								{
HXLINE( 738)									 ::flixel::math::FlxBasePoint this2 = ::flixel::FlxG_obj::camera->scroll;
HXDLIN( 738)									Float x = this->cameraFollowPointer->getMidpoint(null())->x;
HXDLIN( 738)									this2->set_x((x - (( (Float)(::flixel::FlxG_obj::width) ) / ( (Float)(2) ))));
            								}
HXDLIN( 738)								{
HXLINE( 738)									 ::flixel::math::FlxBasePoint this3 = ::flixel::FlxG_obj::camera->scroll;
HXDLIN( 738)									Float y1 = this->cameraFollowPointer->getMidpoint(null())->y;
HXDLIN( 738)									this3->set_y((y1 - (( (Float)(::flixel::FlxG_obj::height) ) / ( (Float)(2) ))));
            								}
            							}
            						}
            					}
HXLINE( 739)					this->unsavedProgress = true;
            				}
            				else {
HXLINE( 741)					if (::hx::IsInstanceEq( sender,this->positionXStepper )) {
HXLINE( 743)						this->character->positionArray[0] = this->positionXStepper->value;
HXLINE( 744)						{
HXLINE( 744)							bool _hx_tmp2;
HXDLIN( 744)							bool _hx_tmp3;
HXDLIN( 744)							if (::hx::IsNotNull( this->character )) {
HXLINE( 744)								_hx_tmp3 = !(this->character->isPlayer);
            							}
            							else {
HXLINE( 744)								_hx_tmp3 = false;
            							}
HXDLIN( 744)							if (!(_hx_tmp3)) {
HXLINE( 744)								if (::hx::IsNull( this->character )) {
HXLINE( 744)									::String name = this->_char;
HXDLIN( 744)									bool _hx_tmp4;
HXDLIN( 744)									bool _hx_tmp5;
HXDLIN( 744)									bool _hx_tmp6;
HXDLIN( 744)									bool _hx_tmp7;
HXDLIN( 744)									bool _hx_tmp8;
HXDLIN( 744)									bool _hx_tmp9;
HXDLIN( 744)									bool _hx_tmp10;
HXDLIN( 744)									if ((name != HX_("bf",c4,55,00,00))) {
HXLINE( 744)										_hx_tmp10 = !(::StringTools_obj::startsWith(name,HX_("bf-",e9,b5,4a,00)));
            									}
            									else {
HXLINE( 744)										_hx_tmp10 = false;
            									}
HXDLIN( 744)									if (_hx_tmp10) {
HXLINE( 744)										_hx_tmp9 = !(::StringTools_obj::endsWith(name,HX_("-player",4e,cb,fe,86)));
            									}
            									else {
HXLINE( 744)										_hx_tmp9 = false;
            									}
HXDLIN( 744)									if (_hx_tmp9) {
HXLINE( 744)										_hx_tmp8 = !(::StringTools_obj::endsWith(name,HX_("-playable",bb,1a,12,5a)));
            									}
            									else {
HXLINE( 744)										_hx_tmp8 = false;
            									}
HXDLIN( 744)									if (_hx_tmp8) {
HXLINE( 744)										_hx_tmp7 = !(::StringTools_obj::endsWith(name,HX_("-dead",51,69,6e,2b)));
            									}
            									else {
HXLINE( 744)										_hx_tmp7 = false;
            									}
HXDLIN( 744)									if (!(_hx_tmp7)) {
HXLINE( 744)										_hx_tmp6 = ::StringTools_obj::endsWith(name,HX_("-opponent",ca,2e,28,0d));
            									}
            									else {
HXLINE( 744)										_hx_tmp6 = true;
            									}
HXDLIN( 744)									if (!(_hx_tmp6)) {
HXLINE( 744)										_hx_tmp5 = ::StringTools_obj::startsWith(name,HX_("gf-",2e,81,4e,00));
            									}
            									else {
HXLINE( 744)										_hx_tmp5 = true;
            									}
HXDLIN( 744)									if (!(_hx_tmp5)) {
HXLINE( 744)										_hx_tmp4 = ::StringTools_obj::endsWith(name,HX_("-gf",8c,7f,22,00));
            									}
            									else {
HXLINE( 744)										_hx_tmp4 = true;
            									}
HXDLIN( 744)									if (!(_hx_tmp4)) {
HXLINE( 744)										_hx_tmp2 = (name == HX_("gf",1f,5a,00,00));
            									}
            									else {
HXLINE( 744)										_hx_tmp2 = true;
            									}
            								}
            								else {
HXLINE( 744)									_hx_tmp2 = false;
            								}
            							}
            							else {
HXLINE( 744)								_hx_tmp2 = true;
            							}
HXDLIN( 744)							if (_hx_tmp2) {
HXLINE( 744)								this->character->setPosition(this->dadPosition->x,this->dadPosition->y);
            							}
            							else {
HXLINE( 744)								this->character->setPosition(this->bfPosition->x,this->bfPosition->y);
            							}
HXDLIN( 744)							 ::objects::Character fh = this->character;
HXDLIN( 744)							fh->set_x((fh->x + this->character->positionArray->__get(0)));
HXDLIN( 744)							 ::objects::Character fh1 = this->character;
HXDLIN( 744)							fh1->set_y((fh1->y + this->character->positionArray->__get(1)));
HXDLIN( 744)							{
HXLINE( 744)								 ::Dynamic snap1 = false;
HXDLIN( 744)								if (::hx::IsNull( snap1 )) {
HXLINE( 744)									snap1 = true;
            								}
HXDLIN( 744)								bool _hx_tmp11;
HXDLIN( 744)								if (::hx::IsNotNull( this->character )) {
HXLINE( 744)									_hx_tmp11 = ::hx::IsNull( this->cameraFollowPointer );
            								}
            								else {
HXLINE( 744)									_hx_tmp11 = true;
            								}
HXDLIN( 744)								if (!(_hx_tmp11)) {
HXLINE( 744)									Float offX3 = ( (Float)(0) );
HXDLIN( 744)									Float offY3 = ( (Float)(0) );
HXDLIN( 744)									if (!(this->character->isPlayer)) {
HXLINE( 744)										Float offX4 = (this->character->getMidpoint(null())->x + 150);
HXDLIN( 744)										offX3 = (offX4 + this->character->cameraPosition->__get(0));
HXDLIN( 744)										Float offY4 = (this->character->getMidpoint(null())->y - ( (Float)(100) ));
HXDLIN( 744)										offY3 = (offY4 + this->character->cameraPosition->__get(1));
            									}
            									else {
HXLINE( 744)										Float offX5 = (this->character->getMidpoint(null())->x - ( (Float)(100) ));
HXDLIN( 744)										offX3 = (offX5 - this->character->cameraPosition->__get(0));
HXDLIN( 744)										Float offY5 = (this->character->getMidpoint(null())->y - ( (Float)(100) ));
HXDLIN( 744)										offY3 = (offY5 + this->character->cameraPosition->__get(1));
            									}
HXDLIN( 744)									this->cameraFollowPointer->setPosition(offX3,offY3);
HXDLIN( 744)									if (( (bool)(snap1) )) {
HXLINE( 744)										{
HXLINE( 744)											 ::flixel::math::FlxBasePoint this4 = ::flixel::FlxG_obj::camera->scroll;
HXDLIN( 744)											Float x1 = this->cameraFollowPointer->getMidpoint(null())->x;
HXDLIN( 744)											this4->set_x((x1 - (( (Float)(::flixel::FlxG_obj::width) ) / ( (Float)(2) ))));
            										}
HXDLIN( 744)										{
HXLINE( 744)											 ::flixel::math::FlxBasePoint this5 = ::flixel::FlxG_obj::camera->scroll;
HXDLIN( 744)											Float y2 = this->cameraFollowPointer->getMidpoint(null())->y;
HXDLIN( 744)											this5->set_y((y2 - (( (Float)(::flixel::FlxG_obj::height) ) / ( (Float)(2) ))));
            										}
            									}
            								}
            							}
            						}
HXLINE( 745)						this->unsavedProgress = true;
            					}
            					else {
HXLINE( 747)						if (::hx::IsInstanceEq( sender,this->positionYStepper )) {
HXLINE( 749)							this->character->positionArray[1] = this->positionYStepper->value;
HXLINE( 750)							{
HXLINE( 750)								bool _hx_tmp12;
HXDLIN( 750)								bool _hx_tmp13;
HXDLIN( 750)								if (::hx::IsNotNull( this->character )) {
HXLINE( 750)									_hx_tmp13 = !(this->character->isPlayer);
            								}
            								else {
HXLINE( 750)									_hx_tmp13 = false;
            								}
HXDLIN( 750)								if (!(_hx_tmp13)) {
HXLINE( 750)									if (::hx::IsNull( this->character )) {
HXLINE( 750)										::String name1 = this->_char;
HXDLIN( 750)										bool _hx_tmp14;
HXDLIN( 750)										bool _hx_tmp15;
HXDLIN( 750)										bool _hx_tmp16;
HXDLIN( 750)										bool _hx_tmp17;
HXDLIN( 750)										bool _hx_tmp18;
HXDLIN( 750)										bool _hx_tmp19;
HXDLIN( 750)										bool _hx_tmp20;
HXDLIN( 750)										if ((name1 != HX_("bf",c4,55,00,00))) {
HXLINE( 750)											_hx_tmp20 = !(::StringTools_obj::startsWith(name1,HX_("bf-",e9,b5,4a,00)));
            										}
            										else {
HXLINE( 750)											_hx_tmp20 = false;
            										}
HXDLIN( 750)										if (_hx_tmp20) {
HXLINE( 750)											_hx_tmp19 = !(::StringTools_obj::endsWith(name1,HX_("-player",4e,cb,fe,86)));
            										}
            										else {
HXLINE( 750)											_hx_tmp19 = false;
            										}
HXDLIN( 750)										if (_hx_tmp19) {
HXLINE( 750)											_hx_tmp18 = !(::StringTools_obj::endsWith(name1,HX_("-playable",bb,1a,12,5a)));
            										}
            										else {
HXLINE( 750)											_hx_tmp18 = false;
            										}
HXDLIN( 750)										if (_hx_tmp18) {
HXLINE( 750)											_hx_tmp17 = !(::StringTools_obj::endsWith(name1,HX_("-dead",51,69,6e,2b)));
            										}
            										else {
HXLINE( 750)											_hx_tmp17 = false;
            										}
HXDLIN( 750)										if (!(_hx_tmp17)) {
HXLINE( 750)											_hx_tmp16 = ::StringTools_obj::endsWith(name1,HX_("-opponent",ca,2e,28,0d));
            										}
            										else {
HXLINE( 750)											_hx_tmp16 = true;
            										}
HXDLIN( 750)										if (!(_hx_tmp16)) {
HXLINE( 750)											_hx_tmp15 = ::StringTools_obj::startsWith(name1,HX_("gf-",2e,81,4e,00));
            										}
            										else {
HXLINE( 750)											_hx_tmp15 = true;
            										}
HXDLIN( 750)										if (!(_hx_tmp15)) {
HXLINE( 750)											_hx_tmp14 = ::StringTools_obj::endsWith(name1,HX_("-gf",8c,7f,22,00));
            										}
            										else {
HXLINE( 750)											_hx_tmp14 = true;
            										}
HXDLIN( 750)										if (!(_hx_tmp14)) {
HXLINE( 750)											_hx_tmp12 = (name1 == HX_("gf",1f,5a,00,00));
            										}
            										else {
HXLINE( 750)											_hx_tmp12 = true;
            										}
            									}
            									else {
HXLINE( 750)										_hx_tmp12 = false;
            									}
            								}
            								else {
HXLINE( 750)									_hx_tmp12 = true;
            								}
HXDLIN( 750)								if (_hx_tmp12) {
HXLINE( 750)									this->character->setPosition(this->dadPosition->x,this->dadPosition->y);
            								}
            								else {
HXLINE( 750)									this->character->setPosition(this->bfPosition->x,this->bfPosition->y);
            								}
HXDLIN( 750)								 ::objects::Character fh2 = this->character;
HXDLIN( 750)								fh2->set_x((fh2->x + this->character->positionArray->__get(0)));
HXDLIN( 750)								 ::objects::Character fh3 = this->character;
HXDLIN( 750)								fh3->set_y((fh3->y + this->character->positionArray->__get(1)));
HXDLIN( 750)								{
HXLINE( 750)									 ::Dynamic snap2 = false;
HXDLIN( 750)									if (::hx::IsNull( snap2 )) {
HXLINE( 750)										snap2 = true;
            									}
HXDLIN( 750)									bool _hx_tmp21;
HXDLIN( 750)									if (::hx::IsNotNull( this->character )) {
HXLINE( 750)										_hx_tmp21 = ::hx::IsNull( this->cameraFollowPointer );
            									}
            									else {
HXLINE( 750)										_hx_tmp21 = true;
            									}
HXDLIN( 750)									if (!(_hx_tmp21)) {
HXLINE( 750)										Float offX6 = ( (Float)(0) );
HXDLIN( 750)										Float offY6 = ( (Float)(0) );
HXDLIN( 750)										if (!(this->character->isPlayer)) {
HXLINE( 750)											Float offX7 = (this->character->getMidpoint(null())->x + 150);
HXDLIN( 750)											offX6 = (offX7 + this->character->cameraPosition->__get(0));
HXDLIN( 750)											Float offY7 = (this->character->getMidpoint(null())->y - ( (Float)(100) ));
HXDLIN( 750)											offY6 = (offY7 + this->character->cameraPosition->__get(1));
            										}
            										else {
HXLINE( 750)											Float offX8 = (this->character->getMidpoint(null())->x - ( (Float)(100) ));
HXDLIN( 750)											offX6 = (offX8 - this->character->cameraPosition->__get(0));
HXDLIN( 750)											Float offY8 = (this->character->getMidpoint(null())->y - ( (Float)(100) ));
HXDLIN( 750)											offY6 = (offY8 + this->character->cameraPosition->__get(1));
            										}
HXDLIN( 750)										this->cameraFollowPointer->setPosition(offX6,offY6);
HXDLIN( 750)										if (( (bool)(snap2) )) {
HXLINE( 750)											{
HXLINE( 750)												 ::flixel::math::FlxBasePoint this6 = ::flixel::FlxG_obj::camera->scroll;
HXDLIN( 750)												Float x2 = this->cameraFollowPointer->getMidpoint(null())->x;
HXDLIN( 750)												this6->set_x((x2 - (( (Float)(::flixel::FlxG_obj::width) ) / ( (Float)(2) ))));
            											}
HXDLIN( 750)											{
HXLINE( 750)												 ::flixel::math::FlxBasePoint this7 = ::flixel::FlxG_obj::camera->scroll;
HXDLIN( 750)												Float y3 = this->cameraFollowPointer->getMidpoint(null())->y;
HXDLIN( 750)												this7->set_y((y3 - (( (Float)(::flixel::FlxG_obj::height) ) / ( (Float)(2) ))));
            											}
            										}
            									}
            								}
            							}
HXLINE( 751)							this->unsavedProgress = true;
            						}
            						else {
HXLINE( 753)							if (::hx::IsInstanceEq( sender,this->singDurationStepper )) {
HXLINE( 755)								this->character->singDuration = this->singDurationStepper->value;
HXLINE( 756)								this->unsavedProgress = true;
            							}
            							else {
HXLINE( 758)								if (::hx::IsInstanceEq( sender,this->positionCameraXStepper )) {
HXLINE( 760)									this->character->cameraPosition[0] = this->positionCameraXStepper->value;
HXLINE( 761)									bool _hx_tmp22;
HXDLIN( 761)									if (::hx::IsNotNull( this->character )) {
HXLINE( 761)										_hx_tmp22 = ::hx::IsNull( this->cameraFollowPointer );
            									}
            									else {
HXLINE( 761)										_hx_tmp22 = true;
            									}
HXDLIN( 761)									if (!(_hx_tmp22)) {
HXLINE( 761)										Float offX9 = ( (Float)(0) );
HXDLIN( 761)										Float offY9 = ( (Float)(0) );
HXDLIN( 761)										if (!(this->character->isPlayer)) {
HXLINE( 761)											Float offX10 = (this->character->getMidpoint(null())->x + 150);
HXDLIN( 761)											offX9 = (offX10 + this->character->cameraPosition->__get(0));
HXDLIN( 761)											Float offY10 = (this->character->getMidpoint(null())->y - ( (Float)(100) ));
HXDLIN( 761)											offY9 = (offY10 + this->character->cameraPosition->__get(1));
            										}
            										else {
HXLINE( 761)											Float offX11 = (this->character->getMidpoint(null())->x - ( (Float)(100) ));
HXDLIN( 761)											offX9 = (offX11 - this->character->cameraPosition->__get(0));
HXDLIN( 761)											Float offY11 = (this->character->getMidpoint(null())->y - ( (Float)(100) ));
HXDLIN( 761)											offY9 = (offY11 + this->character->cameraPosition->__get(1));
            										}
HXDLIN( 761)										this->cameraFollowPointer->setPosition(offX9,offY9);
HXDLIN( 761)										{
HXLINE( 761)											{
HXLINE( 761)												 ::flixel::math::FlxBasePoint this8 = ::flixel::FlxG_obj::camera->scroll;
HXDLIN( 761)												Float x3 = this->cameraFollowPointer->getMidpoint(null())->x;
HXDLIN( 761)												this8->set_x((x3 - (( (Float)(::flixel::FlxG_obj::width) ) / ( (Float)(2) ))));
            											}
HXDLIN( 761)											{
HXLINE( 761)												 ::flixel::math::FlxBasePoint this9 = ::flixel::FlxG_obj::camera->scroll;
HXDLIN( 761)												Float y4 = this->cameraFollowPointer->getMidpoint(null())->y;
HXDLIN( 761)												this9->set_y((y4 - (( (Float)(::flixel::FlxG_obj::height) ) / ( (Float)(2) ))));
            											}
            										}
            									}
HXLINE( 762)									this->unsavedProgress = true;
            								}
            								else {
HXLINE( 764)									if (::hx::IsInstanceEq( sender,this->positionCameraYStepper )) {
HXLINE( 766)										this->character->cameraPosition[1] = this->positionCameraYStepper->value;
HXLINE( 767)										bool _hx_tmp23;
HXDLIN( 767)										if (::hx::IsNotNull( this->character )) {
HXLINE( 767)											_hx_tmp23 = ::hx::IsNull( this->cameraFollowPointer );
            										}
            										else {
HXLINE( 767)											_hx_tmp23 = true;
            										}
HXDLIN( 767)										if (!(_hx_tmp23)) {
HXLINE( 767)											Float offX12 = ( (Float)(0) );
HXDLIN( 767)											Float offY12 = ( (Float)(0) );
HXDLIN( 767)											if (!(this->character->isPlayer)) {
HXLINE( 767)												Float offX13 = (this->character->getMidpoint(null())->x + 150);
HXDLIN( 767)												offX12 = (offX13 + this->character->cameraPosition->__get(0));
HXDLIN( 767)												Float offY13 = (this->character->getMidpoint(null())->y - ( (Float)(100) ));
HXDLIN( 767)												offY12 = (offY13 + this->character->cameraPosition->__get(1));
            											}
            											else {
HXLINE( 767)												Float offX14 = (this->character->getMidpoint(null())->x - ( (Float)(100) ));
HXDLIN( 767)												offX12 = (offX14 - this->character->cameraPosition->__get(0));
HXDLIN( 767)												Float offY14 = (this->character->getMidpoint(null())->y - ( (Float)(100) ));
HXDLIN( 767)												offY12 = (offY14 + this->character->cameraPosition->__get(1));
            											}
HXDLIN( 767)											this->cameraFollowPointer->setPosition(offX12,offY12);
HXDLIN( 767)											{
HXLINE( 767)												{
HXLINE( 767)													 ::flixel::math::FlxBasePoint this10 = ::flixel::FlxG_obj::camera->scroll;
HXDLIN( 767)													Float x4 = this->cameraFollowPointer->getMidpoint(null())->x;
HXDLIN( 767)													this10->set_x((x4 - (( (Float)(::flixel::FlxG_obj::width) ) / ( (Float)(2) ))));
            												}
HXDLIN( 767)												{
HXLINE( 767)													 ::flixel::math::FlxBasePoint this11 = ::flixel::FlxG_obj::camera->scroll;
HXDLIN( 767)													Float y5 = this->cameraFollowPointer->getMidpoint(null())->y;
HXDLIN( 767)													this11->set_y((y5 - (( (Float)(::flixel::FlxG_obj::height) ) / ( (Float)(2) ))));
            												}
            											}
            										}
HXLINE( 768)										this->unsavedProgress = true;
            									}
            									else {
HXLINE( 770)										if (::hx::IsInstanceEq( sender,this->healthColorStepperR )) {
HXLINE( 772)											this->character->healthColorArray[0] = ::Math_obj::round(this->healthColorStepperR->value);
HXLINE( 773)											{
HXLINE( 773)												this->healthColorStepperR->set_value(( (Float)(this->character->healthColorArray->__get(0)) ));
HXDLIN( 773)												this->healthColorStepperG->set_value(( (Float)(this->character->healthColorArray->__get(1)) ));
HXDLIN( 773)												this->healthColorStepperB->set_value(( (Float)(this->character->healthColorArray->__get(2)) ));
HXDLIN( 773)												 ::flixel::FlxSprite _hx_tmp24 = this->healthBar->leftBar;
HXDLIN( 773)												 ::flixel::FlxSprite _hx_tmp25 = this->healthBar->rightBar;
HXDLIN( 773)												int Red = this->character->healthColorArray->__get(0);
HXDLIN( 773)												int Green = this->character->healthColorArray->__get(1);
HXDLIN( 773)												int Blue = this->character->healthColorArray->__get(2);
HXDLIN( 773)												int Alpha = 255;
HXDLIN( 773)												int color = ::flixel::util::_FlxColor::FlxColor_Impl__obj::_new(null());
HXDLIN( 773)												{
HXLINE( 773)													color = (color & -16711681);
HXDLIN( 773)													int color1;
HXDLIN( 773)													if ((Red > 255)) {
HXLINE( 773)														color1 = 255;
            													}
            													else {
HXLINE( 773)														if ((Red < 0)) {
HXLINE( 773)															color1 = 0;
            														}
            														else {
HXLINE( 773)															color1 = Red;
            														}
            													}
HXDLIN( 773)													color = (color | (color1 << 16));
            												}
HXDLIN( 773)												{
HXLINE( 773)													color = (color & -65281);
HXDLIN( 773)													int color2;
HXDLIN( 773)													if ((Green > 255)) {
HXLINE( 773)														color2 = 255;
            													}
            													else {
HXLINE( 773)														if ((Green < 0)) {
HXLINE( 773)															color2 = 0;
            														}
            														else {
HXLINE( 773)															color2 = Green;
            														}
            													}
HXDLIN( 773)													color = (color | (color2 << 8));
            												}
HXDLIN( 773)												{
HXLINE( 773)													color = (color & -256);
HXDLIN( 773)													int color3;
HXDLIN( 773)													if ((Blue > 255)) {
HXLINE( 773)														color3 = 255;
            													}
            													else {
HXLINE( 773)														if ((Blue < 0)) {
HXLINE( 773)															color3 = 0;
            														}
            														else {
HXLINE( 773)															color3 = Blue;
            														}
            													}
HXDLIN( 773)													color = (color | color3);
            												}
HXDLIN( 773)												{
HXLINE( 773)													color = (color & 16777215);
HXDLIN( 773)													int color4;
HXDLIN( 773)													if ((Alpha > 255)) {
HXLINE( 773)														color4 = 255;
            													}
            													else {
HXLINE( 773)														if ((Alpha < 0)) {
HXLINE( 773)															color4 = 0;
            														}
            														else {
HXLINE( 773)															color4 = Alpha;
            														}
            													}
HXDLIN( 773)													color = (color | (color4 << 24));
            												}
HXDLIN( 773)												_hx_tmp24->set_color(_hx_tmp25->set_color(color));
HXDLIN( 773)												this->healthIcon->changeIcon(this->character->healthIcon,false);
HXDLIN( 773)												::String _hx_tmp26 = (HX_("Character: ",6f,a2,f1,a2) + this->_char);
HXDLIN( 773)												::backend::DiscordClient_obj::changePresence(HX_("Character Editor",84,45,58,b1),_hx_tmp26,this->healthIcon->getCharacter(),null(),null(),null());
            											}
HXLINE( 774)											this->unsavedProgress = true;
            										}
            										else {
HXLINE( 776)											if (::hx::IsInstanceEq( sender,this->healthColorStepperG )) {
HXLINE( 778)												this->character->healthColorArray[1] = ::Math_obj::round(this->healthColorStepperG->value);
HXLINE( 779)												{
HXLINE( 779)													this->healthColorStepperR->set_value(( (Float)(this->character->healthColorArray->__get(0)) ));
HXDLIN( 779)													this->healthColorStepperG->set_value(( (Float)(this->character->healthColorArray->__get(1)) ));
HXDLIN( 779)													this->healthColorStepperB->set_value(( (Float)(this->character->healthColorArray->__get(2)) ));
HXDLIN( 779)													 ::flixel::FlxSprite _hx_tmp27 = this->healthBar->leftBar;
HXDLIN( 779)													 ::flixel::FlxSprite _hx_tmp28 = this->healthBar->rightBar;
HXDLIN( 779)													int Red1 = this->character->healthColorArray->__get(0);
HXDLIN( 779)													int Green1 = this->character->healthColorArray->__get(1);
HXDLIN( 779)													int Blue1 = this->character->healthColorArray->__get(2);
HXDLIN( 779)													int Alpha1 = 255;
HXDLIN( 779)													int color5 = ::flixel::util::_FlxColor::FlxColor_Impl__obj::_new(null());
HXDLIN( 779)													{
HXLINE( 779)														color5 = (color5 & -16711681);
HXDLIN( 779)														int color6;
HXDLIN( 779)														if ((Red1 > 255)) {
HXLINE( 779)															color6 = 255;
            														}
            														else {
HXLINE( 779)															if ((Red1 < 0)) {
HXLINE( 779)																color6 = 0;
            															}
            															else {
HXLINE( 779)																color6 = Red1;
            															}
            														}
HXDLIN( 779)														color5 = (color5 | (color6 << 16));
            													}
HXDLIN( 779)													{
HXLINE( 779)														color5 = (color5 & -65281);
HXDLIN( 779)														int color7;
HXDLIN( 779)														if ((Green1 > 255)) {
HXLINE( 779)															color7 = 255;
            														}
            														else {
HXLINE( 779)															if ((Green1 < 0)) {
HXLINE( 779)																color7 = 0;
            															}
            															else {
HXLINE( 779)																color7 = Green1;
            															}
            														}
HXDLIN( 779)														color5 = (color5 | (color7 << 8));
            													}
HXDLIN( 779)													{
HXLINE( 779)														color5 = (color5 & -256);
HXDLIN( 779)														int color8;
HXDLIN( 779)														if ((Blue1 > 255)) {
HXLINE( 779)															color8 = 255;
            														}
            														else {
HXLINE( 779)															if ((Blue1 < 0)) {
HXLINE( 779)																color8 = 0;
            															}
            															else {
HXLINE( 779)																color8 = Blue1;
            															}
            														}
HXDLIN( 779)														color5 = (color5 | color8);
            													}
HXDLIN( 779)													{
HXLINE( 779)														color5 = (color5 & 16777215);
HXDLIN( 779)														int color9;
HXDLIN( 779)														if ((Alpha1 > 255)) {
HXLINE( 779)															color9 = 255;
            														}
            														else {
HXLINE( 779)															if ((Alpha1 < 0)) {
HXLINE( 779)																color9 = 0;
            															}
            															else {
HXLINE( 779)																color9 = Alpha1;
            															}
            														}
HXDLIN( 779)														color5 = (color5 | (color9 << 24));
            													}
HXDLIN( 779)													_hx_tmp27->set_color(_hx_tmp28->set_color(color5));
HXDLIN( 779)													this->healthIcon->changeIcon(this->character->healthIcon,false);
HXDLIN( 779)													::String _hx_tmp29 = (HX_("Character: ",6f,a2,f1,a2) + this->_char);
HXDLIN( 779)													::backend::DiscordClient_obj::changePresence(HX_("Character Editor",84,45,58,b1),_hx_tmp29,this->healthIcon->getCharacter(),null(),null(),null());
            												}
HXLINE( 780)												this->unsavedProgress = true;
            											}
            											else {
HXLINE( 782)												if (::hx::IsInstanceEq( sender,this->healthColorStepperB )) {
HXLINE( 784)													this->character->healthColorArray[2] = ::Math_obj::round(this->healthColorStepperB->value);
HXLINE( 785)													{
HXLINE( 785)														this->healthColorStepperR->set_value(( (Float)(this->character->healthColorArray->__get(0)) ));
HXDLIN( 785)														this->healthColorStepperG->set_value(( (Float)(this->character->healthColorArray->__get(1)) ));
HXDLIN( 785)														this->healthColorStepperB->set_value(( (Float)(this->character->healthColorArray->__get(2)) ));
HXDLIN( 785)														 ::flixel::FlxSprite _hx_tmp30 = this->healthBar->leftBar;
HXDLIN( 785)														 ::flixel::FlxSprite _hx_tmp31 = this->healthBar->rightBar;
HXDLIN( 785)														int Red2 = this->character->healthColorArray->__get(0);
HXDLIN( 785)														int Green2 = this->character->healthColorArray->__get(1);
HXDLIN( 785)														int Blue2 = this->character->healthColorArray->__get(2);
HXDLIN( 785)														int Alpha2 = 255;
HXDLIN( 785)														int color10 = ::flixel::util::_FlxColor::FlxColor_Impl__obj::_new(null());
HXDLIN( 785)														{
HXLINE( 785)															color10 = (color10 & -16711681);
HXDLIN( 785)															int color11;
HXDLIN( 785)															if ((Red2 > 255)) {
HXLINE( 785)																color11 = 255;
            															}
            															else {
HXLINE( 785)																if ((Red2 < 0)) {
HXLINE( 785)																	color11 = 0;
            																}
            																else {
HXLINE( 785)																	color11 = Red2;
            																}
            															}
HXDLIN( 785)															color10 = (color10 | (color11 << 16));
            														}
HXDLIN( 785)														{
HXLINE( 785)															color10 = (color10 & -65281);
HXDLIN( 785)															int color12;
HXDLIN( 785)															if ((Green2 > 255)) {
HXLINE( 785)																color12 = 255;
            															}
            															else {
HXLINE( 785)																if ((Green2 < 0)) {
HXLINE( 785)																	color12 = 0;
            																}
            																else {
HXLINE( 785)																	color12 = Green2;
            																}
            															}
HXDLIN( 785)															color10 = (color10 | (color12 << 8));
            														}
HXDLIN( 785)														{
HXLINE( 785)															color10 = (color10 & -256);
HXDLIN( 785)															int color13;
HXDLIN( 785)															if ((Blue2 > 255)) {
HXLINE( 785)																color13 = 255;
            															}
            															else {
HXLINE( 785)																if ((Blue2 < 0)) {
HXLINE( 785)																	color13 = 0;
            																}
            																else {
HXLINE( 785)																	color13 = Blue2;
            																}
            															}
HXDLIN( 785)															color10 = (color10 | color13);
            														}
HXDLIN( 785)														{
HXLINE( 785)															color10 = (color10 & 16777215);
HXDLIN( 785)															int color14;
HXDLIN( 785)															if ((Alpha2 > 255)) {
HXLINE( 785)																color14 = 255;
            															}
            															else {
HXLINE( 785)																if ((Alpha2 < 0)) {
HXLINE( 785)																	color14 = 0;
            																}
            																else {
HXLINE( 785)																	color14 = Alpha2;
            																}
            															}
HXDLIN( 785)															color10 = (color10 | (color14 << 24));
            														}
HXDLIN( 785)														_hx_tmp30->set_color(_hx_tmp31->set_color(color10));
HXDLIN( 785)														this->healthIcon->changeIcon(this->character->healthIcon,false);
HXDLIN( 785)														::String _hx_tmp32 = (HX_("Character: ",6f,a2,f1,a2) + this->_char);
HXDLIN( 785)														::backend::DiscordClient_obj::changePresence(HX_("Character Editor",84,45,58,b1),_hx_tmp32,this->healthIcon->getCharacter(),null(),null(),null());
            													}
HXLINE( 786)													this->unsavedProgress = true;
            												}
            											}
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(CharacterEditorState_obj,UIEvent,(void))

void CharacterEditorState_obj::reloadCharacterImage(){
            	HX_GC_STACKFRAME(&_hx_pos_8fcf73527616c70a_792_reloadCharacterImage)
HXLINE( 793)		::String lastAnim = this->character->_lastPlayedAnimation;
HXLINE( 794)		::Array< ::Dynamic> anims = this->character->animationsArray->copy();
HXLINE( 796)		this->character->atlas = ( ( ::flxanimate::PsychFlxAnimate)(::flixel::util::FlxDestroyUtil_obj::destroy(this->character->atlas)) );
HXLINE( 797)		this->character->isAnimateAtlas = false;
HXLINE( 798)		this->character->set_color(-1);
HXLINE( 799)		this->character->set_alpha(( (Float)(1) ));
HXLINE( 801)		if (::backend::Paths_obj::fileExists(((HX_("images/",77,50,74,c1) + this->character->imageFile) + HX_("/Animation.json",61,fc,54,44)),HX_("TEXT",ad,94,ba,37),null(),null())) {
HXLINE( 803)			this->character->atlas =  ::flxanimate::PsychFlxAnimate_obj::__alloc( HX_CTX ,null(),null(),null(),null());
HXLINE( 804)			this->character->atlas->set_showPivot(false);
HXLINE( 805)			try {
            				HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 807)				::backend::Paths_obj::loadAnimateAtlas(this->character->atlas,this->character->imageFile,null(),null());
            			} catch( ::Dynamic _hx_e) {
            				if (_hx_e.IsClass<  ::Dynamic >() ){
            					HX_STACK_BEGIN_CATCH
            					 ::Dynamic _g = _hx_e;
HXLINE( 809)					{
HXLINE( 809)						null();
            					}
HXDLIN( 809)					 ::Dynamic e = _g;
HXLINE( 811)					{
HXLINE( 811)						 ::flixel::_hx_system::frontEnds::LogFrontEnd _this = ::flixel::FlxG_obj::log;
HXDLIN( 811)						::String data = ((HX_("Could not load atlas ",63,89,13,d5) + this->character->imageFile) + HX_(": ",a6,32,00,00));
HXDLIN( 811)						 ::Dynamic data1 = (data + ::Std_obj::string(e));
HXDLIN( 811)						_this->advanced(data1,::flixel::_hx_system::debug::log::LogStyle_obj::WARNING,true,::hx::SourceInfo(HX_("source/states/editors/CharacterEditorState.hx",41,39,ad,0d),811,HX_("states.editors.CharacterEditorState",0f,02,8c,78),HX_("reloadCharacterImage",2b,80,35,0a)));
            					}
            				}
            				else {
            					HX_STACK_DO_THROW(_hx_e);
            				}
            			}
HXLINE( 813)			this->character->isAnimateAtlas = true;
            		}
            		else {
HXLINE( 817)			 ::objects::Character _hx_tmp = this->character;
HXDLIN( 817)			_hx_tmp->set_frames(::backend::Paths_obj::getMultiAtlas(this->character->imageFile.split(HX_(",",2c,00,00,00)),null(),null()));
            		}
HXLINE( 820)		{
HXLINE( 820)			int _g1 = 0;
HXDLIN( 820)			while((_g1 < anims->length)){
HXLINE( 820)				 ::Dynamic anim = anims->__get(_g1);
HXDLIN( 820)				_g1 = (_g1 + 1);
HXLINE( 821)				::String animAnim = ( (::String)((HX_("",00,00,00,00) + anim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic))) );
HXLINE( 822)				::String animName = ( (::String)((HX_("",00,00,00,00) + anim->__Field(HX_("name",4b,72,ff,48),::hx::paccDynamic))) );
HXLINE( 823)				int animFps = ( (int)(anim->__Field(HX_("fps",e9,c7,4d,00),::hx::paccDynamic)) );
HXLINE( 824)				bool animLoop = ( (bool)(anim->__Field(HX_("loop",64,a6,b7,47),::hx::paccDynamic)) );
HXLINE( 825)				::Array< int > animIndices = ( (::Array< int >)(anim->__Field(HX_("indices",27,47,54,e3),::hx::paccDynamic)) );
HXLINE( 826)				this->addAnimation(animAnim,animName,( (Float)(animFps) ),animLoop,animIndices);
            			}
            		}
HXLINE( 829)		if ((anims->length > 0)) {
HXLINE( 831)			if ((lastAnim != HX_("",00,00,00,00))) {
HXLINE( 831)				this->character->playAnim(lastAnim,true,null(),null());
            			}
            			else {
HXLINE( 832)				this->character->dance();
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(CharacterEditorState_obj,reloadCharacterImage,(void))

void CharacterEditorState_obj::reloadCharacterOptions(){
            	HX_STACKFRAME(&_hx_pos_8fcf73527616c70a_836_reloadCharacterOptions)
HXLINE( 837)		if (::hx::IsNull( this->UI_characterbox )) {
HXLINE( 837)			return;
            		}
HXLINE( 839)		this->check_player->set_checked(this->character->isPlayer);
HXLINE( 840)		this->imageInputText->set_text(this->character->imageFile);
HXLINE( 841)		this->healthIconInputText->set_text(this->character->healthIcon);
HXLINE( 842)		::String _hx_tmp;
HXDLIN( 842)		if (::hx::IsNotNull( this->character->vocalsFile )) {
HXLINE( 842)			_hx_tmp = this->character->vocalsFile;
            		}
            		else {
HXLINE( 842)			_hx_tmp = HX_("",00,00,00,00);
            		}
HXDLIN( 842)		this->vocalsInputText->set_text(_hx_tmp);
HXLINE( 843)		this->singDurationStepper->set_value(this->character->singDuration);
HXLINE( 844)		this->scaleStepper->set_value(this->character->jsonScale);
HXLINE( 845)		this->flipXCheckBox->set_checked(this->character->originalFlipX);
HXLINE( 846)		this->noAntialiasingCheckBox->set_checked(this->character->noAntialiasing);
HXLINE( 847)		this->positionXStepper->set_value(this->character->positionArray->__get(0));
HXLINE( 848)		this->positionYStepper->set_value(this->character->positionArray->__get(1));
HXLINE( 849)		this->positionCameraXStepper->set_value(this->character->cameraPosition->__get(0));
HXLINE( 850)		this->positionCameraYStepper->set_value(this->character->cameraPosition->__get(1));
HXLINE( 851)		this->reloadAnimationDropDown();
HXLINE( 852)		{
HXLINE( 852)			this->healthColorStepperR->set_value(( (Float)(this->character->healthColorArray->__get(0)) ));
HXDLIN( 852)			this->healthColorStepperG->set_value(( (Float)(this->character->healthColorArray->__get(1)) ));
HXDLIN( 852)			this->healthColorStepperB->set_value(( (Float)(this->character->healthColorArray->__get(2)) ));
HXDLIN( 852)			 ::flixel::FlxSprite _hx_tmp1 = this->healthBar->leftBar;
HXDLIN( 852)			 ::flixel::FlxSprite _hx_tmp2 = this->healthBar->rightBar;
HXDLIN( 852)			int Red = this->character->healthColorArray->__get(0);
HXDLIN( 852)			int Green = this->character->healthColorArray->__get(1);
HXDLIN( 852)			int Blue = this->character->healthColorArray->__get(2);
HXDLIN( 852)			int Alpha = 255;
HXDLIN( 852)			int color = ::flixel::util::_FlxColor::FlxColor_Impl__obj::_new(null());
HXDLIN( 852)			{
HXLINE( 852)				color = (color & -16711681);
HXDLIN( 852)				int color1;
HXDLIN( 852)				if ((Red > 255)) {
HXLINE( 852)					color1 = 255;
            				}
            				else {
HXLINE( 852)					if ((Red < 0)) {
HXLINE( 852)						color1 = 0;
            					}
            					else {
HXLINE( 852)						color1 = Red;
            					}
            				}
HXDLIN( 852)				color = (color | (color1 << 16));
            			}
HXDLIN( 852)			{
HXLINE( 852)				color = (color & -65281);
HXDLIN( 852)				int color2;
HXDLIN( 852)				if ((Green > 255)) {
HXLINE( 852)					color2 = 255;
            				}
            				else {
HXLINE( 852)					if ((Green < 0)) {
HXLINE( 852)						color2 = 0;
            					}
            					else {
HXLINE( 852)						color2 = Green;
            					}
            				}
HXDLIN( 852)				color = (color | (color2 << 8));
            			}
HXDLIN( 852)			{
HXLINE( 852)				color = (color & -256);
HXDLIN( 852)				int color3;
HXDLIN( 852)				if ((Blue > 255)) {
HXLINE( 852)					color3 = 255;
            				}
            				else {
HXLINE( 852)					if ((Blue < 0)) {
HXLINE( 852)						color3 = 0;
            					}
            					else {
HXLINE( 852)						color3 = Blue;
            					}
            				}
HXDLIN( 852)				color = (color | color3);
            			}
HXDLIN( 852)			{
HXLINE( 852)				color = (color & 16777215);
HXDLIN( 852)				int color4;
HXDLIN( 852)				if ((Alpha > 255)) {
HXLINE( 852)					color4 = 255;
            				}
            				else {
HXLINE( 852)					if ((Alpha < 0)) {
HXLINE( 852)						color4 = 0;
            					}
            					else {
HXLINE( 852)						color4 = Alpha;
            					}
            				}
HXDLIN( 852)				color = (color | (color4 << 24));
            			}
HXDLIN( 852)			_hx_tmp1->set_color(_hx_tmp2->set_color(color));
HXDLIN( 852)			this->healthIcon->changeIcon(this->character->healthIcon,false);
HXDLIN( 852)			::String _hx_tmp3 = (HX_("Character: ",6f,a2,f1,a2) + this->_char);
HXDLIN( 852)			::backend::DiscordClient_obj::changePresence(HX_("Character Editor",84,45,58,b1),_hx_tmp3,this->healthIcon->getCharacter(),null(),null(),null());
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(CharacterEditorState_obj,reloadCharacterOptions,(void))

void CharacterEditorState_obj::update(Float elapsed){
            	HX_GC_STACKFRAME(&_hx_pos_8fcf73527616c70a_861_update)
HXLINE( 862)		this->super::update(elapsed);
HXLINE( 864)		if (::hx::IsNotNull( ::backend::ui::PsychUIInputText_obj::focusOn )) {
HXLINE( 866)			::backend::ClientPrefs_obj::toggleVolumeKeys(false);
HXLINE( 867)			return;
            		}
HXLINE( 869)		::backend::ClientPrefs_obj::toggleVolumeKeys(true);
HXLINE( 871)		Float shiftMult = ( (Float)(1) );
HXLINE( 872)		Float ctrlMult = ( (Float)(1) );
HXLINE( 873)		Float shiftMultBig = ( (Float)(1) );
HXLINE( 874)		 ::flixel::input::keyboard::FlxKeyList _this = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 874)		if (_this->keyManager->checkStatusUnsafe(16,_this->status)) {
HXLINE( 876)			shiftMult = ( (Float)(4) );
HXLINE( 877)			shiftMultBig = ( (Float)(10) );
            		}
HXLINE( 879)		 ::flixel::input::keyboard::FlxKeyList _this1 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 879)		if (_this1->keyManager->checkStatusUnsafe(17,_this1->status)) {
HXLINE( 879)			ctrlMult = ((Float)0.25);
            		}
HXLINE( 882)		 ::flixel::input::keyboard::FlxKeyList _this2 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 882)		if (_this2->keyManager->checkStatusUnsafe(74,_this2->status)) {
HXLINE( 882)			 ::flixel::FlxCamera fh = ::flixel::FlxG_obj::camera;
HXDLIN( 882)			fh->scroll->set_x((fh->scroll->x - (((elapsed * ( (Float)(500) )) * shiftMult) * ctrlMult)));
            		}
HXLINE( 883)		 ::flixel::input::keyboard::FlxKeyList _this3 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 883)		if (_this3->keyManager->checkStatusUnsafe(75,_this3->status)) {
HXLINE( 883)			 ::flixel::FlxCamera fh1 = ::flixel::FlxG_obj::camera;
HXDLIN( 883)			fh1->scroll->set_y((fh1->scroll->y + (((elapsed * ( (Float)(500) )) * shiftMult) * ctrlMult)));
            		}
HXLINE( 884)		 ::flixel::input::keyboard::FlxKeyList _this4 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 884)		if (_this4->keyManager->checkStatusUnsafe(76,_this4->status)) {
HXLINE( 884)			 ::flixel::FlxCamera fh2 = ::flixel::FlxG_obj::camera;
HXDLIN( 884)			fh2->scroll->set_x((fh2->scroll->x + (((elapsed * ( (Float)(500) )) * shiftMult) * ctrlMult)));
            		}
HXLINE( 885)		 ::flixel::input::keyboard::FlxKeyList _this5 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 885)		if (_this5->keyManager->checkStatusUnsafe(73,_this5->status)) {
HXLINE( 885)			 ::flixel::FlxCamera fh3 = ::flixel::FlxG_obj::camera;
HXDLIN( 885)			fh3->scroll->set_y((fh3->scroll->y - (((elapsed * ( (Float)(500) )) * shiftMult) * ctrlMult)));
            		}
HXLINE( 887)		Float lastZoom = ::flixel::FlxG_obj::camera->zoom;
HXLINE( 888)		bool _hx_tmp;
HXDLIN( 888)		 ::flixel::input::keyboard::FlxKeyList _this6 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 888)		if (_this6->keyManager->checkStatusUnsafe(82,_this6->status)) {
HXLINE( 888)			 ::flixel::input::keyboard::FlxKeyList _this7 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 888)			_hx_tmp = !(_this7->keyManager->checkStatusUnsafe(17,_this7->status));
            		}
            		else {
HXLINE( 888)			_hx_tmp = false;
            		}
HXDLIN( 888)		if (_hx_tmp) {
HXLINE( 888)			::flixel::FlxG_obj::camera->set_zoom(( (Float)(1) ));
            		}
            		else {
HXLINE( 889)			bool _hx_tmp1;
HXDLIN( 889)			 ::flixel::input::keyboard::FlxKeyList _this8 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 889)			if (_this8->keyManager->checkStatusUnsafe(69,_this8->status)) {
HXLINE( 889)				_hx_tmp1 = (::flixel::FlxG_obj::camera->zoom < 3);
            			}
            			else {
HXLINE( 889)				_hx_tmp1 = false;
            			}
HXDLIN( 889)			if (_hx_tmp1) {
HXLINE( 890)				 ::flixel::FlxCamera fh4 = ::flixel::FlxG_obj::camera;
HXDLIN( 890)				fh4->set_zoom((fh4->zoom + (((elapsed * ::flixel::FlxG_obj::camera->zoom) * shiftMult) * ctrlMult)));
HXLINE( 891)				if ((::flixel::FlxG_obj::camera->zoom > 3)) {
HXLINE( 891)					::flixel::FlxG_obj::camera->set_zoom(( (Float)(3) ));
            				}
            			}
            			else {
HXLINE( 893)				bool _hx_tmp2;
HXDLIN( 893)				 ::flixel::input::keyboard::FlxKeyList _this9 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 893)				if (_this9->keyManager->checkStatusUnsafe(81,_this9->status)) {
HXLINE( 893)					_hx_tmp2 = (::flixel::FlxG_obj::camera->zoom > ((Float)0.1));
            				}
            				else {
HXLINE( 893)					_hx_tmp2 = false;
            				}
HXDLIN( 893)				if (_hx_tmp2) {
HXLINE( 894)					 ::flixel::FlxCamera fh5 = ::flixel::FlxG_obj::camera;
HXDLIN( 894)					fh5->set_zoom((fh5->zoom - (((elapsed * ::flixel::FlxG_obj::camera->zoom) * shiftMult) * ctrlMult)));
HXLINE( 895)					if ((::flixel::FlxG_obj::camera->zoom < ((Float)0.1))) {
HXLINE( 895)						::flixel::FlxG_obj::camera->set_zoom(((Float)0.1));
            					}
            				}
            			}
            		}
HXLINE( 898)		if ((lastZoom != ::flixel::FlxG_obj::camera->zoom)) {
HXLINE( 898)			 ::flixel::text::FlxText _hx_tmp3 = this->cameraZoomText;
HXDLIN( 898)			_hx_tmp3->set_text(((HX_("Zoom: ",99,74,4a,2f) + ::flixel::math::FlxMath_obj::roundDecimal(::flixel::FlxG_obj::camera->zoom,2)) + HX_("x",78,00,00,00)));
            		}
HXLINE( 901)		bool changedAnim = false;
HXLINE( 902)		if ((this->anims->length > 1)) {
HXLINE( 904)			bool _hx_tmp4;
HXDLIN( 904)			 ::flixel::input::keyboard::FlxKeyList _this10 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 904)			if (_this10->keyManager->checkStatusUnsafe(87,_this10->status)) {
HXLINE( 904)				changedAnim = true;
HXDLIN( 904)				_hx_tmp4 = changedAnim;
            			}
            			else {
HXLINE( 904)				_hx_tmp4 = false;
            			}
HXDLIN( 904)			if (_hx_tmp4) {
HXLINE( 904)				this->curAnim--;
            			}
            			else {
HXLINE( 905)				bool _hx_tmp5;
HXDLIN( 905)				 ::flixel::input::keyboard::FlxKeyList _this11 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 905)				if (_this11->keyManager->checkStatusUnsafe(83,_this11->status)) {
HXLINE( 905)					changedAnim = true;
HXDLIN( 905)					_hx_tmp5 = changedAnim;
            				}
            				else {
HXLINE( 905)					_hx_tmp5 = false;
            				}
HXDLIN( 905)				if (_hx_tmp5) {
HXLINE( 905)					this->curAnim++;
            				}
            			}
HXLINE( 907)			if (changedAnim) {
HXLINE( 909)				this->undoOffsets = null();
HXLINE( 910)				this->curAnim = ::flixel::math::FlxMath_obj::wrap(this->curAnim,0,(this->anims->length - 1));
HXLINE( 911)				this->character->playAnim(( (::String)(this->anims->__get(this->curAnim)->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)) ),true,null(),null());
HXLINE( 912)				{
HXLINE( 912)					this->animsTxt->removeFormat(this->selectedFormat,null(),null());
HXDLIN( 912)					::String intendText = HX_("",00,00,00,00);
HXDLIN( 912)					{
HXLINE( 912)						int _g_current = 0;
HXDLIN( 912)						::Array< ::Dynamic> _g_array = this->anims;
HXDLIN( 912)						while((_g_current < _g_array->length)){
HXLINE( 912)							 ::Dynamic _g_value = _g_array->__get(_g_current);
HXDLIN( 912)							_g_current = (_g_current + 1);
HXDLIN( 912)							int _g_key = (_g_current - 1);
HXDLIN( 912)							int num = _g_key;
HXDLIN( 912)							 ::Dynamic anim = _g_value;
HXDLIN( 912)							{
HXLINE( 912)								if ((num > 0)) {
HXLINE( 912)									intendText = (intendText + HX_("\n",0a,00,00,00));
            								}
HXDLIN( 912)								if ((num == this->curAnim)) {
HXLINE( 912)									int n = intendText.length;
HXDLIN( 912)									::String intendText1 = ( (::String)((anim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic) + HX_(": ",a6,32,00,00))) );
HXDLIN( 912)									intendText = (intendText + (intendText1 + ::Std_obj::string( ::Dynamic(anim->__Field(HX_("offsets",80,09,65,d7),::hx::paccDynamic)))));
HXDLIN( 912)									this->animsTxt->addFormat(this->selectedFormat,n,intendText.length);
            								}
            								else {
HXLINE( 912)									::String intendText2 = ( (::String)((anim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic) + HX_(": ",a6,32,00,00))) );
HXDLIN( 912)									intendText = (intendText + (intendText2 + ::Std_obj::string( ::Dynamic(anim->__Field(HX_("offsets",80,09,65,d7),::hx::paccDynamic)))));
            								}
            							}
            						}
            					}
HXDLIN( 912)					this->animsTxt->set_text(intendText);
            				}
            			}
            		}
HXLINE( 916)		bool changedOffset = false;
HXLINE( 917)		 ::flixel::input::keyboard::FlxKeyList _this12 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 917)		bool moveKeysP = _this12->keyManager->checkStatusUnsafe(37,_this12->status);
HXDLIN( 917)		 ::flixel::input::keyboard::FlxKeyList _this13 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 917)		bool moveKeysP1 = _this13->keyManager->checkStatusUnsafe(39,_this13->status);
HXDLIN( 917)		 ::flixel::input::keyboard::FlxKeyList _this14 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 917)		bool moveKeysP2 = _this14->keyManager->checkStatusUnsafe(38,_this14->status);
HXDLIN( 917)		 ::flixel::input::keyboard::FlxKeyList _this15 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 917)		::Array< bool > moveKeysP3 = ::Array_obj< bool >::__new(4)->init(0,moveKeysP)->init(1,moveKeysP1)->init(2,moveKeysP2)->init(3,_this15->keyManager->checkStatusUnsafe(40,_this15->status));
HXLINE( 918)		 ::flixel::input::keyboard::FlxKeyList _this16 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 918)		bool moveKeys = _this16->keyManager->checkStatusUnsafe(37,_this16->status);
HXDLIN( 918)		 ::flixel::input::keyboard::FlxKeyList _this17 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 918)		bool moveKeys1 = _this17->keyManager->checkStatusUnsafe(39,_this17->status);
HXDLIN( 918)		 ::flixel::input::keyboard::FlxKeyList _this18 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 918)		bool moveKeys2 = _this18->keyManager->checkStatusUnsafe(38,_this18->status);
HXDLIN( 918)		 ::flixel::input::keyboard::FlxKeyList _this19 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 918)		::Array< bool > moveKeys3 = ::Array_obj< bool >::__new(4)->init(0,moveKeys)->init(1,moveKeys1)->init(2,moveKeys2)->init(3,_this19->keyManager->checkStatusUnsafe(40,_this19->status));
HXLINE( 919)		if (moveKeysP3->contains(true)) {
HXLINE( 921)			 ::objects::Character fh6 = this->character;
HXDLIN( 921)			{
HXLINE( 921)				int x;
HXDLIN( 921)				if (moveKeysP3->__get(0)) {
HXLINE( 921)					x = 1;
            				}
            				else {
HXLINE( 921)					x = 0;
            				}
HXDLIN( 921)				int x1;
HXDLIN( 921)				if (moveKeysP3->__get(1)) {
HXLINE( 921)					x1 = 1;
            				}
            				else {
HXLINE( 921)					x1 = 0;
            				}
HXDLIN( 921)				fh6->offset->set_x((fh6->offset->x + (( (Float)((x - x1)) ) * shiftMultBig)));
            			}
HXLINE( 922)			 ::objects::Character fh7 = this->character;
HXDLIN( 922)			{
HXLINE( 922)				int y;
HXDLIN( 922)				if (moveKeysP3->__get(2)) {
HXLINE( 922)					y = 1;
            				}
            				else {
HXLINE( 922)					y = 0;
            				}
HXDLIN( 922)				int y1;
HXDLIN( 922)				if (moveKeysP3->__get(3)) {
HXLINE( 922)					y1 = 1;
            				}
            				else {
HXLINE( 922)					y1 = 0;
            				}
HXDLIN( 922)				fh7->offset->set_y((fh7->offset->y + (( (Float)((y - y1)) ) * shiftMultBig)));
            			}
HXLINE( 923)			changedOffset = true;
            		}
HXLINE( 926)		if (moveKeys3->contains(true)) {
HXLINE( 928)			 ::states::editors::CharacterEditorState _hx_tmp6 = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 928)			_hx_tmp6->holdingArrowsTime = (_hx_tmp6->holdingArrowsTime + elapsed);
HXLINE( 929)			if ((this->holdingArrowsTime > ((Float)0.6))) {
HXLINE( 931)				 ::states::editors::CharacterEditorState _hx_tmp7 = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 931)				_hx_tmp7->holdingArrowsElapsed = (_hx_tmp7->holdingArrowsElapsed + elapsed);
HXLINE( 932)				while((this->holdingArrowsElapsed > ((Float)0.0166666666666666664))){
HXLINE( 934)					 ::objects::Character fh8 = this->character;
HXDLIN( 934)					{
HXLINE( 934)						int x2;
HXDLIN( 934)						if (moveKeys3->__get(0)) {
HXLINE( 934)							x2 = 1;
            						}
            						else {
HXLINE( 934)							x2 = 0;
            						}
HXDLIN( 934)						int x3;
HXDLIN( 934)						if (moveKeys3->__get(1)) {
HXLINE( 934)							x3 = 1;
            						}
            						else {
HXLINE( 934)							x3 = 0;
            						}
HXDLIN( 934)						fh8->offset->set_x((fh8->offset->x + (( (Float)((x2 - x3)) ) * shiftMultBig)));
            					}
HXLINE( 935)					 ::objects::Character fh9 = this->character;
HXDLIN( 935)					{
HXLINE( 935)						int y2;
HXDLIN( 935)						if (moveKeys3->__get(2)) {
HXLINE( 935)							y2 = 1;
            						}
            						else {
HXLINE( 935)							y2 = 0;
            						}
HXDLIN( 935)						int y3;
HXDLIN( 935)						if (moveKeys3->__get(3)) {
HXLINE( 935)							y3 = 1;
            						}
            						else {
HXLINE( 935)							y3 = 0;
            						}
HXDLIN( 935)						fh9->offset->set_y((fh9->offset->y + (( (Float)((y2 - y3)) ) * shiftMultBig)));
            					}
HXLINE( 936)					 ::states::editors::CharacterEditorState _hx_tmp8 = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 936)					_hx_tmp8->holdingArrowsElapsed = (_hx_tmp8->holdingArrowsElapsed - ((Float)0.0166666666666666664));
HXLINE( 937)					changedOffset = true;
            				}
            			}
            		}
            		else {
HXLINE( 941)			this->holdingArrowsTime = ( (Float)(0) );
            		}
HXLINE( 943)		bool _hx_tmp9;
HXDLIN( 943)		 ::flixel::input::mouse::FlxMouseButton _this20 = ::flixel::FlxG_obj::mouse->_rightButton;
HXDLIN( 943)		bool _hx_tmp10;
HXDLIN( 943)		if ((_this20->current != 1)) {
HXLINE( 943)			_hx_tmp10 = (_this20->current == 2);
            		}
            		else {
HXLINE( 943)			_hx_tmp10 = true;
            		}
HXDLIN( 943)		if (_hx_tmp10) {
HXLINE( 943)			 ::flixel::input::mouse::FlxMouse _this21 = ::flixel::FlxG_obj::mouse;
HXDLIN( 943)			if (((_this21->viewX - _this21->_prevViewX) == 0)) {
HXLINE( 943)				 ::flixel::input::mouse::FlxMouse _this22 = ::flixel::FlxG_obj::mouse;
HXDLIN( 943)				_hx_tmp9 = ((_this22->viewY - _this22->_prevViewY) != 0);
            			}
            			else {
HXLINE( 943)				_hx_tmp9 = true;
            			}
            		}
            		else {
HXLINE( 943)			_hx_tmp9 = false;
            		}
HXDLIN( 943)		if (_hx_tmp9) {
HXLINE( 945)			 ::objects::Character fh10 = this->character;
HXDLIN( 945)			{
HXLINE( 945)				 ::flixel::input::mouse::FlxMouse _this23 = ::flixel::FlxG_obj::mouse;
HXDLIN( 945)				fh10->offset->set_x((fh10->offset->x - ( (Float)((_this23->viewX - _this23->_prevViewX)) )));
            			}
HXLINE( 946)			 ::objects::Character fh11 = this->character;
HXDLIN( 946)			{
HXLINE( 946)				 ::flixel::input::mouse::FlxMouse _this24 = ::flixel::FlxG_obj::mouse;
HXDLIN( 946)				fh11->offset->set_y((fh11->offset->y - ( (Float)((_this24->viewY - _this24->_prevViewY)) )));
            			}
HXLINE( 947)			changedOffset = true;
            		}
HXLINE( 950)		 ::flixel::input::keyboard::FlxKeyList _this25 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 950)		if (_this25->keyManager->checkStatusUnsafe(17,_this25->status)) {
HXLINE( 952)			 ::flixel::input::keyboard::FlxKeyList _this26 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 952)			if (_this26->keyManager->checkStatusUnsafe(67,_this26->status)) {
HXLINE( 954)				this->copiedOffset[0] = this->character->offset->x;
HXLINE( 955)				this->copiedOffset[1] = this->character->offset->y;
HXLINE( 956)				changedOffset = true;
            			}
            			else {
HXLINE( 958)				 ::flixel::input::keyboard::FlxKeyList _this27 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 958)				if (_this27->keyManager->checkStatusUnsafe(86,_this27->status)) {
HXLINE( 960)					this->undoOffsets = ::Array_obj< Float >::__new(2)->init(0,this->character->offset->x)->init(1,this->character->offset->y);
HXLINE( 961)					this->character->offset->set_x(this->copiedOffset->__get(0));
HXLINE( 962)					this->character->offset->set_y(this->copiedOffset->__get(1));
HXLINE( 963)					changedOffset = true;
            				}
            				else {
HXLINE( 965)					 ::flixel::input::keyboard::FlxKeyList _this28 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 965)					if (_this28->keyManager->checkStatusUnsafe(82,_this28->status)) {
HXLINE( 967)						this->undoOffsets = ::Array_obj< Float >::__new(2)->init(0,this->character->offset->x)->init(1,this->character->offset->y);
HXLINE( 968)						{
HXLINE( 968)							 ::flixel::math::FlxBasePoint this1 = this->character->offset;
HXDLIN( 968)							this1->set_x(( (Float)(0) ));
HXDLIN( 968)							this1->set_y(( (Float)(0) ));
            						}
HXLINE( 969)						changedOffset = true;
            					}
            					else {
HXLINE( 971)						bool _hx_tmp11;
HXDLIN( 971)						 ::flixel::input::keyboard::FlxKeyList _this29 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 971)						if (_this29->keyManager->checkStatusUnsafe(90,_this29->status)) {
HXLINE( 971)							_hx_tmp11 = ::hx::IsNotNull( this->undoOffsets );
            						}
            						else {
HXLINE( 971)							_hx_tmp11 = false;
            						}
HXDLIN( 971)						if (_hx_tmp11) {
HXLINE( 973)							this->character->offset->set_x(this->undoOffsets->__get(0));
HXLINE( 974)							this->character->offset->set_y(this->undoOffsets->__get(1));
HXLINE( 975)							changedOffset = true;
            						}
            					}
            				}
            			}
            		}
HXLINE( 979)		 ::Dynamic anim1 = this->anims->__get(this->curAnim);
HXLINE( 980)		bool _hx_tmp12;
HXDLIN( 980)		bool _hx_tmp13;
HXDLIN( 980)		if (changedOffset) {
HXLINE( 980)			_hx_tmp13 = ::hx::IsNotNull( anim1 );
            		}
            		else {
HXLINE( 980)			_hx_tmp13 = false;
            		}
HXDLIN( 980)		if (_hx_tmp13) {
HXLINE( 980)			_hx_tmp12 = ::hx::IsNotNull( anim1->__Field(HX_("offsets",80,09,65,d7),::hx::paccDynamic) );
            		}
            		else {
HXLINE( 980)			_hx_tmp12 = false;
            		}
HXDLIN( 980)		if (_hx_tmp12) {
HXLINE( 982)			 ::Dynamic(anim1->__Field(HX_("offsets",80,09,65,d7),::hx::paccDynamic))->__SetItem(0,::Std_obj::_hx_int(this->character->offset->x));
HXLINE( 983)			 ::Dynamic(anim1->__Field(HX_("offsets",80,09,65,d7),::hx::paccDynamic))->__SetItem(1,::Std_obj::_hx_int(this->character->offset->y));
HXLINE( 985)			this->character->addOffset(( (::String)(anim1->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)) ),this->character->offset->x,this->character->offset->y);
HXLINE( 986)			{
HXLINE( 986)				this->animsTxt->removeFormat(this->selectedFormat,null(),null());
HXDLIN( 986)				::String intendText3 = HX_("",00,00,00,00);
HXDLIN( 986)				{
HXLINE( 986)					int _g_current1 = 0;
HXDLIN( 986)					::Array< ::Dynamic> _g_array1 = this->anims;
HXDLIN( 986)					while((_g_current1 < _g_array1->length)){
HXLINE( 986)						 ::Dynamic _g_value1 = _g_array1->__get(_g_current1);
HXDLIN( 986)						_g_current1 = (_g_current1 + 1);
HXDLIN( 986)						int _g_key1 = (_g_current1 - 1);
HXDLIN( 986)						int num1 = _g_key1;
HXDLIN( 986)						 ::Dynamic anim2 = _g_value1;
HXDLIN( 986)						{
HXLINE( 986)							if ((num1 > 0)) {
HXLINE( 986)								intendText3 = (intendText3 + HX_("\n",0a,00,00,00));
            							}
HXDLIN( 986)							if ((num1 == this->curAnim)) {
HXLINE( 986)								int n1 = intendText3.length;
HXDLIN( 986)								::String intendText4 = ( (::String)((anim2->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic) + HX_(": ",a6,32,00,00))) );
HXDLIN( 986)								intendText3 = (intendText3 + (intendText4 + ::Std_obj::string( ::Dynamic(anim2->__Field(HX_("offsets",80,09,65,d7),::hx::paccDynamic)))));
HXDLIN( 986)								this->animsTxt->addFormat(this->selectedFormat,n1,intendText3.length);
            							}
            							else {
HXLINE( 986)								::String intendText5 = ( (::String)((anim2->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic) + HX_(": ",a6,32,00,00))) );
HXDLIN( 986)								intendText3 = (intendText3 + (intendText5 + ::Std_obj::string( ::Dynamic(anim2->__Field(HX_("offsets",80,09,65,d7),::hx::paccDynamic)))));
            							}
            						}
            					}
            				}
HXDLIN( 986)				this->animsTxt->set_text(intendText3);
            			}
            		}
HXLINE( 989)		::String txt = HX_("ERROR: No Animation Found",f5,a5,8a,62);
HXLINE( 990)		int clr = -65536;
HXLINE( 991)		 ::objects::Character _this30 = this->character;
HXDLIN( 991)		bool _hx_tmp14;
HXDLIN( 991)		if (!(_this30->isAnimateAtlas)) {
HXLINE( 991)			_hx_tmp14 = ::hx::IsNull( _this30->animation->_curAnim );
            		}
            		else {
HXLINE( 991)			if (::hx::IsNotNull( _this30->atlas->anim->curInstance )) {
HXLINE( 991)				_hx_tmp14 = ::hx::IsNull( _this30->atlas->anim->get_curSymbol() );
            			}
            			else {
HXLINE( 991)				_hx_tmp14 = true;
            			}
            		}
HXDLIN( 991)		if (!(_hx_tmp14)) {
HXLINE( 993)			bool _hx_tmp15;
HXDLIN( 993)			 ::flixel::input::keyboard::FlxKeyList _this31 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 993)			if (!(_this31->keyManager->checkStatusUnsafe(65,_this31->status))) {
HXLINE( 993)				 ::flixel::input::keyboard::FlxKeyList _this32 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 993)				_hx_tmp15 = _this32->keyManager->checkStatusUnsafe(68,_this32->status);
            			}
            			else {
HXLINE( 993)				_hx_tmp15 = true;
            			}
HXDLIN( 993)			if (_hx_tmp15) {
HXLINE( 995)				 ::states::editors::CharacterEditorState _hx_tmp16 = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 995)				_hx_tmp16->holdingFrameTime = (_hx_tmp16->holdingFrameTime + elapsed);
HXLINE( 996)				if ((this->holdingFrameTime > ((Float)0.5))) {
HXLINE( 996)					 ::states::editors::CharacterEditorState _hx_tmp17 = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 996)					_hx_tmp17->holdingFrameElapsed = (_hx_tmp17->holdingFrameElapsed + elapsed);
            				}
            			}
            			else {
HXLINE( 998)				this->holdingFrameTime = ( (Float)(0) );
            			}
HXLINE(1000)			 ::flixel::input::keyboard::FlxKeyList _this33 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN(1000)			if (_this33->keyManager->checkStatusUnsafe(32,_this33->status)) {
HXLINE(1001)				this->character->playAnim(this->character->_lastPlayedAnimation,true,null(),null());
            			}
HXLINE(1003)			int frames = -1;
HXLINE(1004)			int length = -1;
HXLINE(1005)			bool _hx_tmp18;
HXDLIN(1005)			if (!(this->character->isAnimateAtlas)) {
HXLINE(1005)				_hx_tmp18 = ::hx::IsNotNull( this->character->animation->_curAnim );
            			}
            			else {
HXLINE(1005)				_hx_tmp18 = false;
            			}
HXDLIN(1005)			if (_hx_tmp18) {
HXLINE(1007)				frames = this->character->animation->_curAnim->curFrame;
HXLINE(1008)				length = this->character->animation->_curAnim->frames->length;
            			}
            			else {
HXLINE(1010)				bool _hx_tmp19;
HXDLIN(1010)				if (this->character->isAnimateAtlas) {
HXLINE(1010)					_hx_tmp19 = ::hx::IsNotNull( this->character->atlas->anim );
            				}
            				else {
HXLINE(1010)					_hx_tmp19 = false;
            				}
HXDLIN(1010)				if (_hx_tmp19) {
HXLINE(1012)					frames = this->character->atlas->anim->get_curFrame();
HXLINE(1013)					length = this->character->atlas->anim->get_length();
            				}
            			}
HXLINE(1016)			if ((length >= 0)) {
HXLINE(1018)				bool _hx_tmp20;
HXDLIN(1018)				bool _hx_tmp21;
HXDLIN(1018)				 ::flixel::input::keyboard::FlxKeyList _this34 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN(1018)				if (!(_this34->keyManager->checkStatusUnsafe(65,_this34->status))) {
HXLINE(1018)					 ::flixel::input::keyboard::FlxKeyList _this35 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN(1018)					_hx_tmp21 = _this35->keyManager->checkStatusUnsafe(68,_this35->status);
            				}
            				else {
HXLINE(1018)					_hx_tmp21 = true;
            				}
HXDLIN(1018)				if (!(_hx_tmp21)) {
HXLINE(1018)					_hx_tmp20 = (this->holdingFrameTime > ((Float)0.5));
            				}
            				else {
HXLINE(1018)					_hx_tmp20 = true;
            				}
HXDLIN(1018)				if (_hx_tmp20) {
HXLINE(1020)					bool isLeft = false;
HXLINE(1021)					bool _hx_tmp22;
HXDLIN(1021)					bool _hx_tmp23;
HXDLIN(1021)					if ((this->holdingFrameTime > ((Float)0.5))) {
HXLINE(1021)						 ::flixel::input::keyboard::FlxKeyList _this36 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN(1021)						_hx_tmp23 = _this36->keyManager->checkStatusUnsafe(65,_this36->status);
            					}
            					else {
HXLINE(1021)						_hx_tmp23 = false;
            					}
HXDLIN(1021)					if (!(_hx_tmp23)) {
HXLINE(1021)						 ::flixel::input::keyboard::FlxKeyList _this37 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN(1021)						_hx_tmp22 = _this37->keyManager->checkStatusUnsafe(65,_this37->status);
            					}
            					else {
HXLINE(1021)						_hx_tmp22 = true;
            					}
HXDLIN(1021)					if (_hx_tmp22) {
HXLINE(1021)						isLeft = true;
            					}
HXLINE(1022)					this->character->set_animPaused(true);
HXLINE(1024)					bool _hx_tmp24;
HXDLIN(1024)					if (!((this->holdingFrameTime <= ((Float)0.5)))) {
HXLINE(1024)						_hx_tmp24 = (this->holdingFrameElapsed > ((Float)0.1));
            					}
            					else {
HXLINE(1024)						_hx_tmp24 = true;
            					}
HXDLIN(1024)					if (_hx_tmp24) {
HXLINE(1026)						Float frames1;
HXDLIN(1026)						if (isLeft) {
HXLINE(1026)							frames1 = -(shiftMult);
            						}
            						else {
HXLINE(1026)							frames1 = shiftMult;
            						}
HXDLIN(1026)						frames = ::flixel::math::FlxMath_obj::wrap((frames + ::Std_obj::_hx_int(frames1)),0,(length - 1));
HXLINE(1027)						if (!(this->character->isAnimateAtlas)) {
HXLINE(1027)							this->character->animation->_curAnim->set_curFrame(frames);
            						}
            						else {
HXLINE(1028)							this->character->atlas->anim->set_curFrame(frames);
            						}
HXLINE(1029)						 ::states::editors::CharacterEditorState _hx_tmp25 = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN(1029)						_hx_tmp25->holdingFrameElapsed = (_hx_tmp25->holdingFrameElapsed - ((Float)0.1));
            					}
            				}
HXLINE(1033)				txt = ((((HX_("Frames: ( ",e4,49,2d,a4) + frames) + HX_(" / ",31,71,18,00)) + (length - 1)) + HX_(" )",09,1c,00,00));
HXLINE(1035)				clr = -1;
            			}
            		}
HXLINE(1038)		if ((txt != this->frameAdvanceText->text)) {
HXLINE(1038)			this->frameAdvanceText->set_text(txt);
            		}
HXLINE(1039)		this->frameAdvanceText->set_color(clr);
HXLINE(1042)		 ::flixel::input::keyboard::FlxKeyList _this38 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN(1042)		if (_this38->keyManager->checkStatusUnsafe(123,_this38->status)) {
HXLINE(1043)			this->silhouettes->set_visible(!(this->silhouettes->visible));
            		}
HXLINE(1045)		bool _hx_tmp26;
HXDLIN(1045)		 ::flixel::input::keyboard::FlxKeyList _this39 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN(1045)		if (!(_this39->keyManager->checkStatusUnsafe(112,_this39->status))) {
HXLINE(1045)			if (this->helpBg->visible) {
HXLINE(1045)				 ::flixel::input::keyboard::FlxKeyList _this40 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN(1045)				_hx_tmp26 = _this40->keyManager->checkStatusUnsafe(27,_this40->status);
            			}
            			else {
HXLINE(1045)				_hx_tmp26 = false;
            			}
            		}
            		else {
HXLINE(1045)			_hx_tmp26 = true;
            		}
HXDLIN(1045)		if (_hx_tmp26) {
HXLINE(1047)			this->helpBg->set_visible(!(this->helpBg->visible));
HXLINE(1048)			this->helpTexts->set_visible(this->helpBg->visible);
            		}
            		else {
HXLINE(1050)			 ::flixel::input::keyboard::FlxKeyList _this41 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN(1050)			if (_this41->keyManager->checkStatusUnsafe(27,_this41->status)) {
HXLINE(1052)				if (!(this->_goToPlayState)) {
HXLINE(1054)					if (!(this->unsavedProgress)) {
HXLINE(1056)						::backend::MusicBeatState_obj::switchState( ::states::editors::MasterEditorMenu_obj::__alloc( HX_CTX ));
HXLINE(1057)						 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp27 = ::flixel::FlxG_obj::sound;
HXDLIN(1057)						_hx_tmp27->playMusic(::backend::Paths_obj::returnSound((HX_("music/",ea,bf,1b,3f) + HX_("freakyMenu",15,c9,93,86)),null(),true,null()),null(),null(),null());
            					}
            					else {
HXLINE(1059)						this->openSubState( ::states::editors::content::ExitConfirmationPrompt_obj::__alloc( HX_CTX ,null()));
            					}
            				}
            				else {
HXLINE(1063)					::flixel::FlxG_obj::mouse->set_visible(false);
HXLINE(1064)					::backend::MusicBeatState_obj::switchState( ::states::PlayState_obj::__alloc( HX_CTX ));
            				}
HXLINE(1066)				return;
            			}
            		}
            	}


void CharacterEditorState_obj::loadBG(){
            	HX_GC_STACKFRAME(&_hx_pos_8fcf73527616c70a_1072_loadBG)
HXLINE(1073)		::String lastLoaded = ::backend::Paths_obj::currentLevel;
HXLINE(1074)		::backend::Paths_obj::currentLevel = this->assetFolder;
HXLINE(1082)		 ::objects::BGSprite bg =  ::objects::BGSprite_obj::__alloc( HX_CTX ,HX_("stageback",e5,7b,3b,06),-600,-200,((Float)0.9),((Float)0.9),null(),null());
HXLINE(1083)		this->add(bg);
HXLINE(1085)		 ::objects::BGSprite stageFront =  ::objects::BGSprite_obj::__alloc( HX_CTX ,HX_("stagefront",2b,fd,b0,c6),-650,600,((Float)0.9),((Float)0.9),null(),null());
HXLINE(1086)		stageFront->setGraphicSize(::Std_obj::_hx_int((stageFront->get_width() * ((Float)1.1))),null());
HXLINE(1087)		stageFront->updateHitbox();
HXLINE(1088)		this->add(stageFront);
HXLINE(1091)		{
HXLINE(1091)			 ::flixel::math::FlxBasePoint this1 = this->dadPosition;
HXDLIN(1091)			this1->set_x(( (Float)(100) ));
HXDLIN(1091)			this1->set_y(( (Float)(100) ));
            		}
HXLINE(1092)		{
HXLINE(1092)			 ::flixel::math::FlxBasePoint this2 = this->bfPosition;
HXDLIN(1092)			this2->set_x(( (Float)(770) ));
HXDLIN(1092)			this2->set_y(( (Float)(100) ));
            		}
HXLINE(1095)		::backend::Paths_obj::currentLevel = lastLoaded;
            	}


HX_DEFINE_DYNAMIC_FUNC0(CharacterEditorState_obj,loadBG,(void))

void CharacterEditorState_obj::updatePointerPos( ::Dynamic __o_snap){
            		 ::Dynamic snap = __o_snap;
            		if (::hx::IsNull(__o_snap)) snap = true;
            	HX_STACKFRAME(&_hx_pos_8fcf73527616c70a_1099_updatePointerPos)
HXLINE(1100)		bool _hx_tmp;
HXDLIN(1100)		if (::hx::IsNotNull( this->character )) {
HXLINE(1100)			_hx_tmp = ::hx::IsNull( this->cameraFollowPointer );
            		}
            		else {
HXLINE(1100)			_hx_tmp = true;
            		}
HXDLIN(1100)		if (_hx_tmp) {
HXLINE(1100)			return;
            		}
HXLINE(1102)		Float offX = ( (Float)(0) );
HXLINE(1103)		Float offY = ( (Float)(0) );
HXLINE(1104)		if (!(this->character->isPlayer)) {
HXLINE(1106)			Float offX1 = (this->character->getMidpoint(null())->x + 150);
HXDLIN(1106)			offX = (offX1 + this->character->cameraPosition->__get(0));
HXLINE(1107)			Float offY1 = (this->character->getMidpoint(null())->y - ( (Float)(100) ));
HXDLIN(1107)			offY = (offY1 + this->character->cameraPosition->__get(1));
            		}
            		else {
HXLINE(1111)			Float offX2 = (this->character->getMidpoint(null())->x - ( (Float)(100) ));
HXDLIN(1111)			offX = (offX2 - this->character->cameraPosition->__get(0));
HXLINE(1112)			Float offY2 = (this->character->getMidpoint(null())->y - ( (Float)(100) ));
HXDLIN(1112)			offY = (offY2 + this->character->cameraPosition->__get(1));
            		}
HXLINE(1114)		this->cameraFollowPointer->setPosition(offX,offY);
HXLINE(1116)		if (( (bool)(snap) )) {
HXLINE(1118)			{
HXLINE(1118)				 ::flixel::math::FlxBasePoint this1 = ::flixel::FlxG_obj::camera->scroll;
HXDLIN(1118)				Float x = this->cameraFollowPointer->getMidpoint(null())->x;
HXDLIN(1118)				this1->set_x((x - (( (Float)(::flixel::FlxG_obj::width) ) / ( (Float)(2) ))));
            			}
HXLINE(1119)			{
HXLINE(1119)				 ::flixel::math::FlxBasePoint this2 = ::flixel::FlxG_obj::camera->scroll;
HXDLIN(1119)				Float y = this->cameraFollowPointer->getMidpoint(null())->y;
HXDLIN(1119)				this2->set_y((y - (( (Float)(::flixel::FlxG_obj::height) ) / ( (Float)(2) ))));
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(CharacterEditorState_obj,updatePointerPos,(void))

void CharacterEditorState_obj::updateHealthBar(){
            	HX_STACKFRAME(&_hx_pos_8fcf73527616c70a_1124_updateHealthBar)
HXLINE(1125)		this->healthColorStepperR->set_value(( (Float)(this->character->healthColorArray->__get(0)) ));
HXLINE(1126)		this->healthColorStepperG->set_value(( (Float)(this->character->healthColorArray->__get(1)) ));
HXLINE(1127)		this->healthColorStepperB->set_value(( (Float)(this->character->healthColorArray->__get(2)) ));
HXLINE(1128)		 ::flixel::FlxSprite _hx_tmp = this->healthBar->leftBar;
HXDLIN(1128)		 ::flixel::FlxSprite _hx_tmp1 = this->healthBar->rightBar;
HXDLIN(1128)		int Red = this->character->healthColorArray->__get(0);
HXDLIN(1128)		int Green = this->character->healthColorArray->__get(1);
HXDLIN(1128)		int Blue = this->character->healthColorArray->__get(2);
HXDLIN(1128)		int Alpha = 255;
HXDLIN(1128)		int color = ::flixel::util::_FlxColor::FlxColor_Impl__obj::_new(null());
HXDLIN(1128)		{
HXLINE(1128)			color = (color & -16711681);
HXDLIN(1128)			int color1;
HXDLIN(1128)			if ((Red > 255)) {
HXLINE(1128)				color1 = 255;
            			}
            			else {
HXLINE(1128)				if ((Red < 0)) {
HXLINE(1128)					color1 = 0;
            				}
            				else {
HXLINE(1128)					color1 = Red;
            				}
            			}
HXDLIN(1128)			color = (color | (color1 << 16));
            		}
HXDLIN(1128)		{
HXLINE(1128)			color = (color & -65281);
HXDLIN(1128)			int color2;
HXDLIN(1128)			if ((Green > 255)) {
HXLINE(1128)				color2 = 255;
            			}
            			else {
HXLINE(1128)				if ((Green < 0)) {
HXLINE(1128)					color2 = 0;
            				}
            				else {
HXLINE(1128)					color2 = Green;
            				}
            			}
HXDLIN(1128)			color = (color | (color2 << 8));
            		}
HXDLIN(1128)		{
HXLINE(1128)			color = (color & -256);
HXDLIN(1128)			int color3;
HXDLIN(1128)			if ((Blue > 255)) {
HXLINE(1128)				color3 = 255;
            			}
            			else {
HXLINE(1128)				if ((Blue < 0)) {
HXLINE(1128)					color3 = 0;
            				}
            				else {
HXLINE(1128)					color3 = Blue;
            				}
            			}
HXDLIN(1128)			color = (color | color3);
            		}
HXDLIN(1128)		{
HXLINE(1128)			color = (color & 16777215);
HXDLIN(1128)			int color4;
HXDLIN(1128)			if ((Alpha > 255)) {
HXLINE(1128)				color4 = 255;
            			}
            			else {
HXLINE(1128)				if ((Alpha < 0)) {
HXLINE(1128)					color4 = 0;
            				}
            				else {
HXLINE(1128)					color4 = Alpha;
            				}
            			}
HXDLIN(1128)			color = (color | (color4 << 24));
            		}
HXDLIN(1128)		_hx_tmp->set_color(_hx_tmp1->set_color(color));
HXLINE(1129)		this->healthIcon->changeIcon(this->character->healthIcon,false);
HXLINE(1130)		::String _hx_tmp2 = (HX_("Character: ",6f,a2,f1,a2) + this->_char);
HXDLIN(1130)		::backend::DiscordClient_obj::changePresence(HX_("Character Editor",84,45,58,b1),_hx_tmp2,this->healthIcon->getCharacter(),null(),null(),null());
            	}


HX_DEFINE_DYNAMIC_FUNC0(CharacterEditorState_obj,updateHealthBar,(void))

void CharacterEditorState_obj::updatePresence(){
            	HX_STACKFRAME(&_hx_pos_8fcf73527616c70a_1136_updatePresence)
HXDLIN(1136)		::String _hx_tmp = (HX_("Character: ",6f,a2,f1,a2) + this->_char);
HXDLIN(1136)		::backend::DiscordClient_obj::changePresence(HX_("Character Editor",84,45,58,b1),_hx_tmp,this->healthIcon->getCharacter(),null(),null(),null());
            	}


HX_DEFINE_DYNAMIC_FUNC0(CharacterEditorState_obj,updatePresence,(void))

void CharacterEditorState_obj::reloadAnimList(){
            	HX_STACKFRAME(&_hx_pos_8fcf73527616c70a_1141_reloadAnimList)
HXLINE(1142)		this->anims = this->character->animationsArray;
HXLINE(1143)		if ((this->anims->length > 0)) {
HXLINE(1143)			this->character->playAnim(( (::String)(this->anims->__get(0)->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)) ),true,null(),null());
            		}
HXLINE(1144)		this->curAnim = 0;
HXLINE(1146)		{
HXLINE(1146)			this->animsTxt->removeFormat(this->selectedFormat,null(),null());
HXDLIN(1146)			::String intendText = HX_("",00,00,00,00);
HXDLIN(1146)			{
HXLINE(1146)				int _g_current = 0;
HXDLIN(1146)				::Array< ::Dynamic> _g_array = this->anims;
HXDLIN(1146)				while((_g_current < _g_array->length)){
HXLINE(1146)					 ::Dynamic _g_value = _g_array->__get(_g_current);
HXDLIN(1146)					_g_current = (_g_current + 1);
HXDLIN(1146)					int _g_key = (_g_current - 1);
HXDLIN(1146)					int num = _g_key;
HXDLIN(1146)					 ::Dynamic anim = _g_value;
HXDLIN(1146)					{
HXLINE(1146)						if ((num > 0)) {
HXLINE(1146)							intendText = (intendText + HX_("\n",0a,00,00,00));
            						}
HXDLIN(1146)						if ((num == this->curAnim)) {
HXLINE(1146)							int n = intendText.length;
HXDLIN(1146)							::String intendText1 = ( (::String)((anim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic) + HX_(": ",a6,32,00,00))) );
HXDLIN(1146)							intendText = (intendText + (intendText1 + ::Std_obj::string( ::Dynamic(anim->__Field(HX_("offsets",80,09,65,d7),::hx::paccDynamic)))));
HXDLIN(1146)							this->animsTxt->addFormat(this->selectedFormat,n,intendText.length);
            						}
            						else {
HXLINE(1146)							::String intendText2 = ( (::String)((anim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic) + HX_(": ",a6,32,00,00))) );
HXDLIN(1146)							intendText = (intendText + (intendText2 + ::Std_obj::string( ::Dynamic(anim->__Field(HX_("offsets",80,09,65,d7),::hx::paccDynamic)))));
            						}
            					}
            				}
            			}
HXDLIN(1146)			this->animsTxt->set_text(intendText);
            		}
HXLINE(1147)		if (::hx::IsNotNull( this->animationDropDown )) {
HXLINE(1147)			this->reloadAnimationDropDown();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(CharacterEditorState_obj,reloadAnimList,(void))

void CharacterEditorState_obj::updateText(){
            	HX_STACKFRAME(&_hx_pos_8fcf73527616c70a_1151_updateText)
HXLINE(1152)		this->animsTxt->removeFormat(this->selectedFormat,null(),null());
HXLINE(1154)		::String intendText = HX_("",00,00,00,00);
HXLINE(1155)		{
HXLINE(1155)			int _g_current = 0;
HXDLIN(1155)			::Array< ::Dynamic> _g_array = this->anims;
HXDLIN(1155)			while((_g_current < _g_array->length)){
HXLINE(1155)				 ::Dynamic _g_value = _g_array->__get(_g_current);
HXDLIN(1155)				_g_current = (_g_current + 1);
HXDLIN(1155)				int _g_key = (_g_current - 1);
HXDLIN(1155)				int num = _g_key;
HXDLIN(1155)				 ::Dynamic anim = _g_value;
HXLINE(1156)				{
HXLINE(1157)					if ((num > 0)) {
HXLINE(1157)						intendText = (intendText + HX_("\n",0a,00,00,00));
            					}
HXLINE(1159)					if ((num == this->curAnim)) {
HXLINE(1161)						int n = intendText.length;
HXLINE(1162)						::String intendText1 = ( (::String)((anim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic) + HX_(": ",a6,32,00,00))) );
HXDLIN(1162)						intendText = (intendText + (intendText1 + ::Std_obj::string( ::Dynamic(anim->__Field(HX_("offsets",80,09,65,d7),::hx::paccDynamic)))));
HXLINE(1163)						this->animsTxt->addFormat(this->selectedFormat,n,intendText.length);
            					}
            					else {
HXLINE(1165)						::String intendText2 = ( (::String)((anim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic) + HX_(": ",a6,32,00,00))) );
HXDLIN(1165)						intendText = (intendText + (intendText2 + ::Std_obj::string( ::Dynamic(anim->__Field(HX_("offsets",80,09,65,d7),::hx::paccDynamic)))));
            					}
            				}
            			}
            		}
HXLINE(1167)		this->animsTxt->set_text(intendText);
            	}


HX_DEFINE_DYNAMIC_FUNC0(CharacterEditorState_obj,updateText,(void))

void CharacterEditorState_obj::updateCharacterPositions(){
            	HX_STACKFRAME(&_hx_pos_8fcf73527616c70a_1171_updateCharacterPositions)
HXLINE(1172)		bool _hx_tmp;
HXDLIN(1172)		bool _hx_tmp1;
HXDLIN(1172)		if (::hx::IsNotNull( this->character )) {
HXLINE(1172)			_hx_tmp1 = !(this->character->isPlayer);
            		}
            		else {
HXLINE(1172)			_hx_tmp1 = false;
            		}
HXDLIN(1172)		if (!(_hx_tmp1)) {
HXLINE(1172)			if (::hx::IsNull( this->character )) {
HXLINE(1172)				::String name = this->_char;
HXDLIN(1172)				bool _hx_tmp2;
HXDLIN(1172)				bool _hx_tmp3;
HXDLIN(1172)				bool _hx_tmp4;
HXDLIN(1172)				bool _hx_tmp5;
HXDLIN(1172)				bool _hx_tmp6;
HXDLIN(1172)				bool _hx_tmp7;
HXDLIN(1172)				bool _hx_tmp8;
HXDLIN(1172)				if ((name != HX_("bf",c4,55,00,00))) {
HXLINE(1172)					_hx_tmp8 = !(::StringTools_obj::startsWith(name,HX_("bf-",e9,b5,4a,00)));
            				}
            				else {
HXLINE(1172)					_hx_tmp8 = false;
            				}
HXDLIN(1172)				if (_hx_tmp8) {
HXLINE(1172)					_hx_tmp7 = !(::StringTools_obj::endsWith(name,HX_("-player",4e,cb,fe,86)));
            				}
            				else {
HXLINE(1172)					_hx_tmp7 = false;
            				}
HXDLIN(1172)				if (_hx_tmp7) {
HXLINE(1172)					_hx_tmp6 = !(::StringTools_obj::endsWith(name,HX_("-playable",bb,1a,12,5a)));
            				}
            				else {
HXLINE(1172)					_hx_tmp6 = false;
            				}
HXDLIN(1172)				if (_hx_tmp6) {
HXLINE(1172)					_hx_tmp5 = !(::StringTools_obj::endsWith(name,HX_("-dead",51,69,6e,2b)));
            				}
            				else {
HXLINE(1172)					_hx_tmp5 = false;
            				}
HXDLIN(1172)				if (!(_hx_tmp5)) {
HXLINE(1172)					_hx_tmp4 = ::StringTools_obj::endsWith(name,HX_("-opponent",ca,2e,28,0d));
            				}
            				else {
HXLINE(1172)					_hx_tmp4 = true;
            				}
HXDLIN(1172)				if (!(_hx_tmp4)) {
HXLINE(1172)					_hx_tmp3 = ::StringTools_obj::startsWith(name,HX_("gf-",2e,81,4e,00));
            				}
            				else {
HXLINE(1172)					_hx_tmp3 = true;
            				}
HXDLIN(1172)				if (!(_hx_tmp3)) {
HXLINE(1172)					_hx_tmp2 = ::StringTools_obj::endsWith(name,HX_("-gf",8c,7f,22,00));
            				}
            				else {
HXLINE(1172)					_hx_tmp2 = true;
            				}
HXDLIN(1172)				if (!(_hx_tmp2)) {
HXLINE(1172)					_hx_tmp = (name == HX_("gf",1f,5a,00,00));
            				}
            				else {
HXLINE(1172)					_hx_tmp = true;
            				}
            			}
            			else {
HXLINE(1172)				_hx_tmp = false;
            			}
            		}
            		else {
HXLINE(1172)			_hx_tmp = true;
            		}
HXDLIN(1172)		if (_hx_tmp) {
HXLINE(1172)			this->character->setPosition(this->dadPosition->x,this->dadPosition->y);
            		}
            		else {
HXLINE(1173)			this->character->setPosition(this->bfPosition->x,this->bfPosition->y);
            		}
HXLINE(1175)		 ::objects::Character fh = this->character;
HXDLIN(1175)		fh->set_x((fh->x + this->character->positionArray->__get(0)));
HXLINE(1176)		 ::objects::Character fh1 = this->character;
HXDLIN(1176)		fh1->set_y((fh1->y + this->character->positionArray->__get(1)));
HXLINE(1177)		{
HXLINE(1177)			 ::Dynamic snap = false;
HXDLIN(1177)			if (::hx::IsNull( snap )) {
HXLINE(1177)				snap = true;
            			}
HXDLIN(1177)			bool _hx_tmp9;
HXDLIN(1177)			if (::hx::IsNotNull( this->character )) {
HXLINE(1177)				_hx_tmp9 = ::hx::IsNull( this->cameraFollowPointer );
            			}
            			else {
HXLINE(1177)				_hx_tmp9 = true;
            			}
HXDLIN(1177)			if (!(_hx_tmp9)) {
HXLINE(1177)				Float offX = ( (Float)(0) );
HXDLIN(1177)				Float offY = ( (Float)(0) );
HXDLIN(1177)				if (!(this->character->isPlayer)) {
HXLINE(1177)					Float offX1 = (this->character->getMidpoint(null())->x + 150);
HXDLIN(1177)					offX = (offX1 + this->character->cameraPosition->__get(0));
HXDLIN(1177)					Float offY1 = (this->character->getMidpoint(null())->y - ( (Float)(100) ));
HXDLIN(1177)					offY = (offY1 + this->character->cameraPosition->__get(1));
            				}
            				else {
HXLINE(1177)					Float offX2 = (this->character->getMidpoint(null())->x - ( (Float)(100) ));
HXDLIN(1177)					offX = (offX2 - this->character->cameraPosition->__get(0));
HXDLIN(1177)					Float offY2 = (this->character->getMidpoint(null())->y - ( (Float)(100) ));
HXDLIN(1177)					offY = (offY2 + this->character->cameraPosition->__get(1));
            				}
HXDLIN(1177)				this->cameraFollowPointer->setPosition(offX,offY);
HXDLIN(1177)				if (( (bool)(snap) )) {
HXLINE(1177)					{
HXLINE(1177)						 ::flixel::math::FlxBasePoint this1 = ::flixel::FlxG_obj::camera->scroll;
HXDLIN(1177)						Float x = this->cameraFollowPointer->getMidpoint(null())->x;
HXDLIN(1177)						this1->set_x((x - (( (Float)(::flixel::FlxG_obj::width) ) / ( (Float)(2) ))));
            					}
HXDLIN(1177)					{
HXLINE(1177)						 ::flixel::math::FlxBasePoint this2 = ::flixel::FlxG_obj::camera->scroll;
HXDLIN(1177)						Float y = this->cameraFollowPointer->getMidpoint(null())->y;
HXDLIN(1177)						this2->set_y((y - (( (Float)(::flixel::FlxG_obj::height) ) / ( (Float)(2) ))));
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(CharacterEditorState_obj,updateCharacterPositions,(void))

bool CharacterEditorState_obj::predictCharacterIsNotPlayer(::String name){
            	HX_STACKFRAME(&_hx_pos_8fcf73527616c70a_1182_predictCharacterIsNotPlayer)
HXDLIN(1182)		bool _hx_tmp;
HXDLIN(1182)		bool _hx_tmp1;
HXDLIN(1182)		bool _hx_tmp2;
HXDLIN(1182)		bool _hx_tmp3;
HXDLIN(1182)		bool _hx_tmp4;
HXDLIN(1182)		bool _hx_tmp5;
HXDLIN(1182)		bool _hx_tmp6;
HXDLIN(1182)		if ((name != HX_("bf",c4,55,00,00))) {
HXDLIN(1182)			_hx_tmp6 = !(::StringTools_obj::startsWith(name,HX_("bf-",e9,b5,4a,00)));
            		}
            		else {
HXDLIN(1182)			_hx_tmp6 = false;
            		}
HXDLIN(1182)		if (_hx_tmp6) {
HXDLIN(1182)			_hx_tmp5 = !(::StringTools_obj::endsWith(name,HX_("-player",4e,cb,fe,86)));
            		}
            		else {
HXDLIN(1182)			_hx_tmp5 = false;
            		}
HXDLIN(1182)		if (_hx_tmp5) {
HXDLIN(1182)			_hx_tmp4 = !(::StringTools_obj::endsWith(name,HX_("-playable",bb,1a,12,5a)));
            		}
            		else {
HXDLIN(1182)			_hx_tmp4 = false;
            		}
HXDLIN(1182)		if (_hx_tmp4) {
HXDLIN(1182)			_hx_tmp3 = !(::StringTools_obj::endsWith(name,HX_("-dead",51,69,6e,2b)));
            		}
            		else {
HXDLIN(1182)			_hx_tmp3 = false;
            		}
HXDLIN(1182)		if (!(_hx_tmp3)) {
HXDLIN(1182)			_hx_tmp2 = ::StringTools_obj::endsWith(name,HX_("-opponent",ca,2e,28,0d));
            		}
            		else {
HXDLIN(1182)			_hx_tmp2 = true;
            		}
HXDLIN(1182)		if (!(_hx_tmp2)) {
HXDLIN(1182)			_hx_tmp1 = ::StringTools_obj::startsWith(name,HX_("gf-",2e,81,4e,00));
            		}
            		else {
HXDLIN(1182)			_hx_tmp1 = true;
            		}
HXDLIN(1182)		if (!(_hx_tmp1)) {
HXDLIN(1182)			_hx_tmp = ::StringTools_obj::endsWith(name,HX_("-gf",8c,7f,22,00));
            		}
            		else {
HXDLIN(1182)			_hx_tmp = true;
            		}
HXDLIN(1182)		if (!(_hx_tmp)) {
HXLINE(1183)			return (name == HX_("gf",1f,5a,00,00));
            		}
            		else {
HXDLIN(1182)			return true;
            		}
HXDLIN(1182)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC1(CharacterEditorState_obj,predictCharacterIsNotPlayer,return )

void CharacterEditorState_obj::addAnimation(::String anim,::String name,Float fps,bool loop,::Array< int > indices){
            	HX_STACKFRAME(&_hx_pos_8fcf73527616c70a_1187_addAnimation)
HXLINE(1188)		if (!(this->character->isAnimateAtlas)) {
HXLINE(1190)			bool _hx_tmp;
HXDLIN(1190)			if (::hx::IsNotNull( indices )) {
HXLINE(1190)				_hx_tmp = (indices->length > 0);
            			}
            			else {
HXLINE(1190)				_hx_tmp = false;
            			}
HXDLIN(1190)			if (_hx_tmp) {
HXLINE(1191)				this->character->animation->addByIndices(anim,name,indices,HX_("",00,00,00,00),fps,loop,null(),null());
            			}
            			else {
HXLINE(1193)				this->character->animation->addByPrefix(anim,name,fps,loop,null(),null());
            			}
            		}
            		else {
HXLINE(1197)			bool _hx_tmp1;
HXDLIN(1197)			if (::hx::IsNotNull( indices )) {
HXLINE(1197)				_hx_tmp1 = (indices->length > 0);
            			}
            			else {
HXLINE(1197)				_hx_tmp1 = false;
            			}
HXDLIN(1197)			if (_hx_tmp1) {
HXLINE(1198)				this->character->atlas->anim->addBySymbolIndices(anim,name,indices,fps,loop,null(),null());
            			}
            			else {
HXLINE(1200)				this->character->atlas->anim->addBySymbol(anim,name,fps,loop,null(),null());
            			}
            		}
HXLINE(1203)		if (!(this->character->hasAnimation(anim))) {
HXLINE(1204)			this->character->addOffset(anim,0,0);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC5(CharacterEditorState_obj,addAnimation,(void))

 ::Dynamic CharacterEditorState_obj::newAnim(::String anim,::String name){
            	HX_STACKFRAME(&_hx_pos_8fcf73527616c70a_1209_newAnim)
HXDLIN(1209)		return  ::Dynamic(::hx::Anon_obj::Create(6)
            			->setFixed(0,HX_("offsets",80,09,65,d7),::Array_obj< int >::fromData( _hx_array_data_788c020f_73,2))
            			->setFixed(1,HX_("indices",27,47,54,e3),::Array_obj< int >::__new(0))
            			->setFixed(2,HX_("fps",e9,c7,4d,00),24)
            			->setFixed(3,HX_("anim",11,86,71,40),anim)
            			->setFixed(4,HX_("loop",64,a6,b7,47),false)
            			->setFixed(5,HX_("name",4b,72,ff,48),name));
            	}


HX_DEFINE_DYNAMIC_FUNC2(CharacterEditorState_obj,newAnim,return )

void CharacterEditorState_obj::reloadCharacterDropDown(){
            	HX_STACKFRAME(&_hx_pos_8fcf73527616c70a_1220_reloadCharacterDropDown)
HXLINE(1221)		::String defaultDirectory = null();
HXDLIN(1221)		bool allowDuplicates = false;
HXDLIN(1221)		if (::hx::IsNull( defaultDirectory )) {
HXLINE(1221)			defaultDirectory = HX_("assets/shared/",1e,69,1e,47);
            		}
HXDLIN(1221)		defaultDirectory = ::StringTools_obj::trim(defaultDirectory);
HXDLIN(1221)		if (!(::StringTools_obj::endsWith(defaultDirectory,HX_("/",2f,00,00,00)))) {
HXLINE(1221)			defaultDirectory = (defaultDirectory + HX_("/",2f,00,00,00));
            		}
HXDLIN(1221)		if (!(::StringTools_obj::startsWith(defaultDirectory,HX_("assets/",4c,2a,dc,36)))) {
HXLINE(1221)			defaultDirectory = (HX_("assets/",4c,2a,dc,36) + defaultDirectory);
            		}
HXDLIN(1221)		::Array< ::String > mergedList = ::Array_obj< ::String >::__new(0);
HXDLIN(1221)		::Array< ::String > foldersToCheck = ::Array_obj< ::String >::__new(0);
HXDLIN(1221)		if (::sys::FileSystem_obj::exists((defaultDirectory + HX_("data/characterList.txt",c4,ce,ff,de)))) {
HXLINE(1221)			foldersToCheck->push((defaultDirectory + HX_("data/characterList.txt",c4,ce,ff,de)));
            		}
HXDLIN(1221)		bool _hx_tmp;
HXDLIN(1221)		if (::hx::IsNotNull( ::backend::Paths_obj::currentLevel )) {
HXLINE(1221)			_hx_tmp = (::backend::Paths_obj::currentLevel != defaultDirectory);
            		}
            		else {
HXLINE(1221)			_hx_tmp = false;
            		}
HXDLIN(1221)		if (_hx_tmp) {
HXLINE(1221)			::String folder = ::backend::Paths_obj::currentLevel;
HXDLIN(1221)			if (::hx::IsNull( folder )) {
HXLINE(1221)				folder = HX_("shared",a5,5e,2b,1d);
            			}
HXDLIN(1221)			::String pth = (((HX_("assets/",4c,2a,dc,36) + folder) + HX_("/",2f,00,00,00)) + HX_("data/characterList.txt",c4,ce,ff,de));
HXDLIN(1221)			bool _hx_tmp1;
HXDLIN(1221)			if (!(foldersToCheck->contains(pth))) {
HXLINE(1221)				_hx_tmp1 = ::sys::FileSystem_obj::exists(pth);
            			}
            			else {
HXLINE(1221)				_hx_tmp1 = false;
            			}
HXDLIN(1221)			if (_hx_tmp1) {
HXLINE(1221)				foldersToCheck->push(pth);
            			}
            		}
HXDLIN(1221)		{
HXLINE(1221)			{
HXLINE(1221)				int _g = 0;
HXDLIN(1221)				::Array< ::String > _g1 = ::backend::Mods_obj::globalMods;
HXDLIN(1221)				while((_g < _g1->length)){
HXLINE(1221)					::String mod = _g1->__get(_g);
HXDLIN(1221)					_g = (_g + 1);
HXDLIN(1221)					::String key = ((mod + HX_("/",2f,00,00,00)) + HX_("data/characterList.txt",c4,ce,ff,de));
HXDLIN(1221)					if (::hx::IsNull( key )) {
HXLINE(1221)						key = HX_("",00,00,00,00);
            					}
HXDLIN(1221)					::String folder1 = (HX_("mods/",9e,2f,58,0c) + key);
HXDLIN(1221)					bool _hx_tmp2;
HXDLIN(1221)					if (::sys::FileSystem_obj::exists(folder1)) {
HXLINE(1221)						_hx_tmp2 = !(foldersToCheck->contains(folder1));
            					}
            					else {
HXLINE(1221)						_hx_tmp2 = false;
            					}
HXDLIN(1221)					if (_hx_tmp2) {
HXLINE(1221)						foldersToCheck->push(folder1);
            					}
            				}
            			}
HXDLIN(1221)			::String key1 = HX_("data/characterList.txt",c4,ce,ff,de);
HXDLIN(1221)			if (::hx::IsNull( key1 )) {
HXLINE(1221)				key1 = HX_("",00,00,00,00);
            			}
HXDLIN(1221)			::String folder2 = (HX_("mods/",9e,2f,58,0c) + key1);
HXDLIN(1221)			bool _hx_tmp3;
HXDLIN(1221)			if (::sys::FileSystem_obj::exists(folder2)) {
HXLINE(1221)				_hx_tmp3 = !(foldersToCheck->contains(folder2));
            			}
            			else {
HXLINE(1221)				_hx_tmp3 = false;
            			}
HXDLIN(1221)			if (_hx_tmp3) {
HXLINE(1221)				::String key2 = HX_("data/characterList.txt",c4,ce,ff,de);
HXDLIN(1221)				if (::hx::IsNull( key2 )) {
HXLINE(1221)					key2 = HX_("",00,00,00,00);
            				}
HXDLIN(1221)				foldersToCheck->push((HX_("mods/",9e,2f,58,0c) + key2));
            			}
HXDLIN(1221)			bool _hx_tmp4;
HXDLIN(1221)			if (::hx::IsNotNull( ::backend::Mods_obj::currentModDirectory )) {
HXLINE(1221)				_hx_tmp4 = (::backend::Mods_obj::currentModDirectory.length > 0);
            			}
            			else {
HXLINE(1221)				_hx_tmp4 = false;
            			}
HXDLIN(1221)			if (_hx_tmp4) {
HXLINE(1221)				::String key3 = ((::backend::Mods_obj::currentModDirectory + HX_("/",2f,00,00,00)) + HX_("data/characterList.txt",c4,ce,ff,de));
HXDLIN(1221)				if (::hx::IsNull( key3 )) {
HXLINE(1221)					key3 = HX_("",00,00,00,00);
            				}
HXDLIN(1221)				::String folder3 = (HX_("mods/",9e,2f,58,0c) + key3);
HXDLIN(1221)				bool _hx_tmp5;
HXDLIN(1221)				if (::sys::FileSystem_obj::exists(folder3)) {
HXLINE(1221)					_hx_tmp5 = !(foldersToCheck->contains(folder3));
            				}
            				else {
HXLINE(1221)					_hx_tmp5 = false;
            				}
HXDLIN(1221)				if (_hx_tmp5) {
HXLINE(1221)					foldersToCheck->push(folder3);
            				}
            			}
            		}
HXDLIN(1221)		::Array< ::String > paths = foldersToCheck;
HXDLIN(1221)		::String defaultPath = (defaultDirectory + HX_("data/characterList.txt",c4,ce,ff,de));
HXDLIN(1221)		if (paths->contains(defaultPath)) {
HXLINE(1221)			paths->remove(defaultPath);
HXDLIN(1221)			paths->insert(0,defaultPath);
            		}
HXDLIN(1221)		{
HXLINE(1221)			int _g2 = 0;
HXDLIN(1221)			while((_g2 < paths->length)){
HXLINE(1221)				::String file = paths->__get(_g2);
HXDLIN(1221)				_g2 = (_g2 + 1);
HXDLIN(1221)				::String daList = null();
HXDLIN(1221)				if (::sys::FileSystem_obj::exists(file)) {
HXLINE(1221)					daList = ::sys::io::File_obj::getContent(file);
            				}
HXDLIN(1221)				::Array< ::String > list;
HXDLIN(1221)				if (::hx::IsNotNull( daList )) {
HXLINE(1221)					::Array< ::String > daList1 = ::Array_obj< ::String >::__new(0);
HXDLIN(1221)					daList1 = ::StringTools_obj::trim(daList).split(HX_("\n",0a,00,00,00));
HXDLIN(1221)					{
HXLINE(1221)						int _g3 = 0;
HXDLIN(1221)						int _g4 = daList1->length;
HXDLIN(1221)						while((_g3 < _g4)){
HXLINE(1221)							_g3 = (_g3 + 1);
HXDLIN(1221)							int i = (_g3 - 1);
HXDLIN(1221)							daList1[i] = ::StringTools_obj::trim(daList1->__get(i));
            						}
            					}
HXDLIN(1221)					list = daList1;
            				}
            				else {
HXLINE(1221)					list = ::Array_obj< ::String >::__new(0);
            				}
HXDLIN(1221)				{
HXLINE(1221)					int _g5 = 0;
HXDLIN(1221)					while((_g5 < list->length)){
HXLINE(1221)						::String value = list->__get(_g5);
HXDLIN(1221)						_g5 = (_g5 + 1);
HXDLIN(1221)						bool _hx_tmp6;
HXDLIN(1221)						bool _hx_tmp7;
HXDLIN(1221)						if (!(allowDuplicates)) {
HXLINE(1221)							_hx_tmp7 = !(mergedList->contains(value));
            						}
            						else {
HXLINE(1221)							_hx_tmp7 = true;
            						}
HXDLIN(1221)						if (_hx_tmp7) {
HXLINE(1221)							_hx_tmp6 = (value.length > 0);
            						}
            						else {
HXLINE(1221)							_hx_tmp6 = false;
            						}
HXDLIN(1221)						if (_hx_tmp6) {
HXLINE(1221)							mergedList->push(value);
            						}
            					}
            				}
            			}
            		}
HXDLIN(1221)		this->characterList = mergedList;
HXLINE(1222)		::Array< ::String > foldersToCheck1 = ::Array_obj< ::String >::__new(0);
HXDLIN(1222)		if (::sys::FileSystem_obj::exists((HX_("assets/shared/",1e,69,1e,47) + HX_("characters/",45,3c,bf,be)))) {
HXLINE(1222)			foldersToCheck1->push((HX_("assets/shared/",1e,69,1e,47) + HX_("characters/",45,3c,bf,be)));
            		}
HXDLIN(1222)		bool _hx_tmp8;
HXDLIN(1222)		if (::hx::IsNotNull( ::backend::Paths_obj::currentLevel )) {
HXLINE(1222)			_hx_tmp8 = (::backend::Paths_obj::currentLevel != HX_("assets/shared/",1e,69,1e,47));
            		}
            		else {
HXLINE(1222)			_hx_tmp8 = false;
            		}
HXDLIN(1222)		if (_hx_tmp8) {
HXLINE(1222)			::String folder4 = ::backend::Paths_obj::currentLevel;
HXDLIN(1222)			if (::hx::IsNull( folder4 )) {
HXLINE(1222)				folder4 = HX_("shared",a5,5e,2b,1d);
            			}
HXDLIN(1222)			::String pth1 = (((HX_("assets/",4c,2a,dc,36) + folder4) + HX_("/",2f,00,00,00)) + HX_("characters/",45,3c,bf,be));
HXDLIN(1222)			bool _hx_tmp9;
HXDLIN(1222)			if (!(foldersToCheck1->contains(pth1))) {
HXLINE(1222)				_hx_tmp9 = ::sys::FileSystem_obj::exists(pth1);
            			}
            			else {
HXLINE(1222)				_hx_tmp9 = false;
            			}
HXDLIN(1222)			if (_hx_tmp9) {
HXLINE(1222)				foldersToCheck1->push(pth1);
            			}
            		}
HXDLIN(1222)		{
HXLINE(1222)			{
HXLINE(1222)				int _g6 = 0;
HXDLIN(1222)				::Array< ::String > _g7 = ::backend::Mods_obj::globalMods;
HXDLIN(1222)				while((_g6 < _g7->length)){
HXLINE(1222)					::String mod1 = _g7->__get(_g6);
HXDLIN(1222)					_g6 = (_g6 + 1);
HXDLIN(1222)					::String key4 = ((mod1 + HX_("/",2f,00,00,00)) + HX_("characters/",45,3c,bf,be));
HXDLIN(1222)					if (::hx::IsNull( key4 )) {
HXLINE(1222)						key4 = HX_("",00,00,00,00);
            					}
HXDLIN(1222)					::String folder5 = (HX_("mods/",9e,2f,58,0c) + key4);
HXDLIN(1222)					bool _hx_tmp10;
HXDLIN(1222)					if (::sys::FileSystem_obj::exists(folder5)) {
HXLINE(1222)						_hx_tmp10 = !(foldersToCheck1->contains(folder5));
            					}
            					else {
HXLINE(1222)						_hx_tmp10 = false;
            					}
HXDLIN(1222)					if (_hx_tmp10) {
HXLINE(1222)						foldersToCheck1->push(folder5);
            					}
            				}
            			}
HXDLIN(1222)			::String key5 = HX_("characters/",45,3c,bf,be);
HXDLIN(1222)			if (::hx::IsNull( key5 )) {
HXLINE(1222)				key5 = HX_("",00,00,00,00);
            			}
HXDLIN(1222)			::String folder6 = (HX_("mods/",9e,2f,58,0c) + key5);
HXDLIN(1222)			bool _hx_tmp11;
HXDLIN(1222)			if (::sys::FileSystem_obj::exists(folder6)) {
HXLINE(1222)				_hx_tmp11 = !(foldersToCheck1->contains(folder6));
            			}
            			else {
HXLINE(1222)				_hx_tmp11 = false;
            			}
HXDLIN(1222)			if (_hx_tmp11) {
HXLINE(1222)				::String key6 = HX_("characters/",45,3c,bf,be);
HXDLIN(1222)				if (::hx::IsNull( key6 )) {
HXLINE(1222)					key6 = HX_("",00,00,00,00);
            				}
HXDLIN(1222)				foldersToCheck1->push((HX_("mods/",9e,2f,58,0c) + key6));
            			}
HXDLIN(1222)			bool _hx_tmp12;
HXDLIN(1222)			if (::hx::IsNotNull( ::backend::Mods_obj::currentModDirectory )) {
HXLINE(1222)				_hx_tmp12 = (::backend::Mods_obj::currentModDirectory.length > 0);
            			}
            			else {
HXLINE(1222)				_hx_tmp12 = false;
            			}
HXDLIN(1222)			if (_hx_tmp12) {
HXLINE(1222)				::String key7 = ((::backend::Mods_obj::currentModDirectory + HX_("/",2f,00,00,00)) + HX_("characters/",45,3c,bf,be));
HXDLIN(1222)				if (::hx::IsNull( key7 )) {
HXLINE(1222)					key7 = HX_("",00,00,00,00);
            				}
HXDLIN(1222)				::String folder7 = (HX_("mods/",9e,2f,58,0c) + key7);
HXDLIN(1222)				bool _hx_tmp13;
HXDLIN(1222)				if (::sys::FileSystem_obj::exists(folder7)) {
HXLINE(1222)					_hx_tmp13 = !(foldersToCheck1->contains(folder7));
            				}
            				else {
HXLINE(1222)					_hx_tmp13 = false;
            				}
HXDLIN(1222)				if (_hx_tmp13) {
HXLINE(1222)					foldersToCheck1->push(folder7);
            				}
            			}
            		}
HXDLIN(1222)		::Array< ::String > foldersToCheck2 = foldersToCheck1;
HXLINE(1223)		{
HXLINE(1223)			int _g8 = 0;
HXDLIN(1223)			while((_g8 < foldersToCheck2->length)){
HXLINE(1223)				::String folder8 = foldersToCheck2->__get(_g8);
HXDLIN(1223)				_g8 = (_g8 + 1);
HXLINE(1224)				{
HXLINE(1224)					int _g9 = 0;
HXDLIN(1224)					::Array< ::String > _g10 = ::sys::FileSystem_obj::readDirectory(folder8);
HXDLIN(1224)					while((_g9 < _g10->length)){
HXLINE(1224)						::String file1 = _g10->__get(_g9);
HXDLIN(1224)						_g9 = (_g9 + 1);
HXLINE(1225)						if (::StringTools_obj::endsWith(file1.toLowerCase(),HX_(".json",56,f1,d6,c2))) {
HXLINE(1227)							::String charToCheck = file1.substr(0,(file1.length - 5));
HXLINE(1228)							if (!(this->characterList->contains(charToCheck))) {
HXLINE(1229)								this->characterList->push(charToCheck);
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE(1232)		if ((this->characterList->length < 1)) {
HXLINE(1232)			this->characterList->push(HX_("",00,00,00,00));
            		}
HXLINE(1233)		this->charDropDown->set_list(this->characterList);
HXLINE(1234)		this->charDropDown->set_selectedLabel(this->_char);
            	}


HX_DEFINE_DYNAMIC_FUNC0(CharacterEditorState_obj,reloadCharacterDropDown,(void))

void CharacterEditorState_obj::reloadAnimationDropDown(){
            	HX_STACKFRAME(&_hx_pos_8fcf73527616c70a_1237_reloadAnimationDropDown)
HXLINE(1238)		::Array< ::String > animList = ::Array_obj< ::String >::__new(0);
HXLINE(1239)		{
HXLINE(1239)			int _g = 0;
HXDLIN(1239)			::Array< ::Dynamic> _g1 = this->anims;
HXDLIN(1239)			while((_g < _g1->length)){
HXLINE(1239)				 ::Dynamic anim = _g1->__get(_g);
HXDLIN(1239)				_g = (_g + 1);
HXDLIN(1239)				animList->push( ::Dynamic(anim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)));
            			}
            		}
HXLINE(1240)		if ((animList->length < 1)) {
HXLINE(1240)			animList->push(HX_("NO ANIMATIONS",6e,22,ac,1b));
            		}
HXLINE(1242)		this->animationDropDown->set_list(animList);
            	}


HX_DEFINE_DYNAMIC_FUNC0(CharacterEditorState_obj,reloadAnimationDropDown,(void))

void CharacterEditorState_obj::onSaveComplete( ::openfl::events::Event _){
            	HX_STACKFRAME(&_hx_pos_8fcf73527616c70a_1248_onSaveComplete)
HXLINE(1249)		if (::hx::IsNull( this->_file )) {
HXLINE(1249)			return;
            		}
HXLINE(1250)		this->_file->removeEventListener(HX_("complete",b9,00,c8,7f),this->onSaveComplete_dyn(),null());
HXLINE(1251)		this->_file->removeEventListener(HX_("cancel",7a,ed,33,b8),this->onSaveCancel_dyn(),null());
HXLINE(1252)		this->_file->removeEventListener(HX_("ioError",02,fe,41,76),this->onSaveError_dyn(),null());
HXLINE(1253)		this->_file = null();
HXLINE(1254)		::flixel::FlxG_obj::log->advanced(HX_("Successfully saved file.",c0,0d,09,f4),::flixel::_hx_system::debug::log::LogStyle_obj::NOTICE,false,::hx::SourceInfo(HX_("source/states/editors/CharacterEditorState.hx",41,39,ad,0d),1254,HX_("states.editors.CharacterEditorState",0f,02,8c,78),HX_("onSaveComplete",d5,ac,3f,bc)));
            	}


HX_DEFINE_DYNAMIC_FUNC1(CharacterEditorState_obj,onSaveComplete,(void))

void CharacterEditorState_obj::onSaveCancel( ::openfl::events::Event _){
            	HX_STACKFRAME(&_hx_pos_8fcf73527616c70a_1261_onSaveCancel)
HXLINE(1262)		if (::hx::IsNull( this->_file )) {
HXLINE(1262)			return;
            		}
HXLINE(1263)		this->_file->removeEventListener(HX_("complete",b9,00,c8,7f),this->onSaveComplete_dyn(),null());
HXLINE(1264)		this->_file->removeEventListener(HX_("cancel",7a,ed,33,b8),this->onSaveCancel_dyn(),null());
HXLINE(1265)		this->_file->removeEventListener(HX_("ioError",02,fe,41,76),this->onSaveError_dyn(),null());
HXLINE(1266)		this->_file = null();
            	}


HX_DEFINE_DYNAMIC_FUNC1(CharacterEditorState_obj,onSaveCancel,(void))

void CharacterEditorState_obj::onSaveError( ::openfl::events::IOErrorEvent _){
            	HX_STACKFRAME(&_hx_pos_8fcf73527616c70a_1273_onSaveError)
HXLINE(1274)		if (::hx::IsNull( this->_file )) {
HXLINE(1274)			return;
            		}
HXLINE(1275)		this->_file->removeEventListener(HX_("complete",b9,00,c8,7f),this->onSaveComplete_dyn(),null());
HXLINE(1276)		this->_file->removeEventListener(HX_("cancel",7a,ed,33,b8),this->onSaveCancel_dyn(),null());
HXLINE(1277)		this->_file->removeEventListener(HX_("ioError",02,fe,41,76),this->onSaveError_dyn(),null());
HXLINE(1278)		this->_file = null();
HXLINE(1279)		::flixel::FlxG_obj::log->advanced(HX_("Problem saving file",41,4c,cd,8e),::flixel::_hx_system::debug::log::LogStyle_obj::ERROR,true,::hx::SourceInfo(HX_("source/states/editors/CharacterEditorState.hx",41,39,ad,0d),1279,HX_("states.editors.CharacterEditorState",0f,02,8c,78),HX_("onSaveError",2c,b6,19,24)));
            	}


HX_DEFINE_DYNAMIC_FUNC1(CharacterEditorState_obj,onSaveError,(void))

void CharacterEditorState_obj::saveCharacter(){
            	HX_GC_STACKFRAME(&_hx_pos_8fcf73527616c70a_1282_saveCharacter)
HXLINE(1283)		if (::hx::IsNotNull( this->_file )) {
HXLINE(1283)			return;
            		}
HXLINE(1285)		 ::Dynamic json =  ::Dynamic(::hx::Anon_obj::Create(12)
            			->setFixed(0,HX_("animations",ef,34,1c,83),this->character->animationsArray)
            			->setFixed(1,HX_("vocals_file",3d,c5,2d,83),this->character->vocalsFile)
            			->setFixed(2,HX_("no_antialiasing",f2,74,67,98),this->character->noAntialiasing)
            			->setFixed(3,HX_("image",5b,1f,69,bd),this->character->imageFile)
            			->setFixed(4,HX_("position",a9,a0,fa,ca),this->character->positionArray)
            			->setFixed(5,HX_("healthicon",15,8e,6f,17),this->character->healthIcon)
            			->setFixed(6,HX_("flip_x",26,2b,6a,3d),this->character->originalFlipX)
            			->setFixed(7,HX_("healthbar_colors",78,d9,40,40),this->character->healthColorArray)
            			->setFixed(8,HX_("camera_position",c3,d4,4a,56),this->character->cameraPosition)
            			->setFixed(9,HX_("sing_duration",84,ae,a8,66),this->character->singDuration)
            			->setFixed(10,HX_("scale",8a,ce,ce,78),this->character->jsonScale)
            			->setFixed(11,HX_("_editor_isPlayer",7e,61,dd,7d),this->character->isPlayer));
HXLINE(1302)		::String data = ::states::editors::content::PsychJsonPrinter_obj::print(json,::Array_obj< ::String >::fromData( _hx_array_data_788c020f_88,5));
HXLINE(1304)		if ((data.length > 0)) {
HXLINE(1306)			this->_file =  ::openfl::net::FileReference_obj::__alloc( HX_CTX );
HXLINE(1307)			this->_file->addEventListener(HX_("select",fc,1a,33,6a),this->onSaveComplete_dyn(),null(),null(),null());
HXLINE(1308)			this->_file->addEventListener(HX_("cancel",7a,ed,33,b8),this->onSaveCancel_dyn(),null(),null(),null());
HXLINE(1309)			this->_file->addEventListener(HX_("ioError",02,fe,41,76),this->onSaveError_dyn(),null(),null(),null());
HXLINE(1310)			this->_file->save(data,((HX_("",00,00,00,00) + this->_char) + HX_(".json",56,f1,d6,c2)));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(CharacterEditorState_obj,saveCharacter,(void))


::hx::ObjectPtr< CharacterEditorState_obj > CharacterEditorState_obj::__new(::String _hx_char,::hx::Null< bool >  __o_goToPlayState) {
	::hx::ObjectPtr< CharacterEditorState_obj > __this = new CharacterEditorState_obj();
	__this->__construct(_hx_char,__o_goToPlayState);
	return __this;
}

::hx::ObjectPtr< CharacterEditorState_obj > CharacterEditorState_obj::__alloc(::hx::Ctx *_hx_ctx,::String _hx_char,::hx::Null< bool >  __o_goToPlayState) {
	CharacterEditorState_obj *__this = (CharacterEditorState_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(CharacterEditorState_obj), true, "states.editors.CharacterEditorState"));
	*(void **)__this = CharacterEditorState_obj::_hx_vtable;
	__this->__construct(_hx_char,__o_goToPlayState);
	return __this;
}

CharacterEditorState_obj::CharacterEditorState_obj()
{
}

void CharacterEditorState_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(CharacterEditorState);
	HX_MARK_MEMBER_NAME(character,"character");
	HX_MARK_MEMBER_NAME(ghost,"ghost");
	HX_MARK_MEMBER_NAME(animateGhost,"animateGhost");
	HX_MARK_MEMBER_NAME(animateGhostImage,"animateGhostImage");
	HX_MARK_MEMBER_NAME(cameraFollowPointer,"cameraFollowPointer");
	HX_MARK_MEMBER_NAME(isAnimateSprite,"isAnimateSprite");
	HX_MARK_MEMBER_NAME(silhouettes,"silhouettes");
	HX_MARK_MEMBER_NAME(dadPosition,"dadPosition");
	HX_MARK_MEMBER_NAME(bfPosition,"bfPosition");
	HX_MARK_MEMBER_NAME(helpBg,"helpBg");
	HX_MARK_MEMBER_NAME(helpTexts,"helpTexts");
	HX_MARK_MEMBER_NAME(cameraZoomText,"cameraZoomText");
	HX_MARK_MEMBER_NAME(frameAdvanceText,"frameAdvanceText");
	HX_MARK_MEMBER_NAME(healthBar,"healthBar");
	HX_MARK_MEMBER_NAME(healthIcon,"healthIcon");
	HX_MARK_MEMBER_NAME(copiedOffset,"copiedOffset");
	HX_MARK_MEMBER_NAME(_char,"_char");
	HX_MARK_MEMBER_NAME(_goToPlayState,"_goToPlayState");
	HX_MARK_MEMBER_NAME(anims,"anims");
	HX_MARK_MEMBER_NAME(animsTxt,"animsTxt");
	HX_MARK_MEMBER_NAME(curAnim,"curAnim");
	HX_MARK_MEMBER_NAME(camEditor,"camEditor");
	HX_MARK_MEMBER_NAME(camHUD,"camHUD");
	HX_MARK_MEMBER_NAME(UI_box,"UI_box");
	HX_MARK_MEMBER_NAME(UI_characterbox,"UI_characterbox");
	HX_MARK_MEMBER_NAME(unsavedProgress,"unsavedProgress");
	HX_MARK_MEMBER_NAME(selectedFormat,"selectedFormat");
	HX_MARK_MEMBER_NAME(ghostAlpha,"ghostAlpha");
	HX_MARK_MEMBER_NAME(check_player,"check_player");
	HX_MARK_MEMBER_NAME(charDropDown,"charDropDown");
	HX_MARK_MEMBER_NAME(animationDropDown,"animationDropDown");
	HX_MARK_MEMBER_NAME(animationInputText,"animationInputText");
	HX_MARK_MEMBER_NAME(animationNameInputText,"animationNameInputText");
	HX_MARK_MEMBER_NAME(animationIndicesInputText,"animationIndicesInputText");
	HX_MARK_MEMBER_NAME(animationFramerate,"animationFramerate");
	HX_MARK_MEMBER_NAME(animationLoopCheckBox,"animationLoopCheckBox");
	HX_MARK_MEMBER_NAME(imageInputText,"imageInputText");
	HX_MARK_MEMBER_NAME(healthIconInputText,"healthIconInputText");
	HX_MARK_MEMBER_NAME(vocalsInputText,"vocalsInputText");
	HX_MARK_MEMBER_NAME(singDurationStepper,"singDurationStepper");
	HX_MARK_MEMBER_NAME(scaleStepper,"scaleStepper");
	HX_MARK_MEMBER_NAME(positionXStepper,"positionXStepper");
	HX_MARK_MEMBER_NAME(positionYStepper,"positionYStepper");
	HX_MARK_MEMBER_NAME(positionCameraXStepper,"positionCameraXStepper");
	HX_MARK_MEMBER_NAME(positionCameraYStepper,"positionCameraYStepper");
	HX_MARK_MEMBER_NAME(flipXCheckBox,"flipXCheckBox");
	HX_MARK_MEMBER_NAME(noAntialiasingCheckBox,"noAntialiasingCheckBox");
	HX_MARK_MEMBER_NAME(healthColorStepperR,"healthColorStepperR");
	HX_MARK_MEMBER_NAME(healthColorStepperG,"healthColorStepperG");
	HX_MARK_MEMBER_NAME(healthColorStepperB,"healthColorStepperB");
	HX_MARK_MEMBER_NAME(holdingArrowsTime,"holdingArrowsTime");
	HX_MARK_MEMBER_NAME(holdingArrowsElapsed,"holdingArrowsElapsed");
	HX_MARK_MEMBER_NAME(holdingFrameTime,"holdingFrameTime");
	HX_MARK_MEMBER_NAME(holdingFrameElapsed,"holdingFrameElapsed");
	HX_MARK_MEMBER_NAME(undoOffsets,"undoOffsets");
	HX_MARK_MEMBER_NAME(assetFolder,"assetFolder");
	HX_MARK_MEMBER_NAME(characterList,"characterList");
	HX_MARK_MEMBER_NAME(_file,"_file");
	 ::backend::MusicBeatState_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void CharacterEditorState_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(character,"character");
	HX_VISIT_MEMBER_NAME(ghost,"ghost");
	HX_VISIT_MEMBER_NAME(animateGhost,"animateGhost");
	HX_VISIT_MEMBER_NAME(animateGhostImage,"animateGhostImage");
	HX_VISIT_MEMBER_NAME(cameraFollowPointer,"cameraFollowPointer");
	HX_VISIT_MEMBER_NAME(isAnimateSprite,"isAnimateSprite");
	HX_VISIT_MEMBER_NAME(silhouettes,"silhouettes");
	HX_VISIT_MEMBER_NAME(dadPosition,"dadPosition");
	HX_VISIT_MEMBER_NAME(bfPosition,"bfPosition");
	HX_VISIT_MEMBER_NAME(helpBg,"helpBg");
	HX_VISIT_MEMBER_NAME(helpTexts,"helpTexts");
	HX_VISIT_MEMBER_NAME(cameraZoomText,"cameraZoomText");
	HX_VISIT_MEMBER_NAME(frameAdvanceText,"frameAdvanceText");
	HX_VISIT_MEMBER_NAME(healthBar,"healthBar");
	HX_VISIT_MEMBER_NAME(healthIcon,"healthIcon");
	HX_VISIT_MEMBER_NAME(copiedOffset,"copiedOffset");
	HX_VISIT_MEMBER_NAME(_char,"_char");
	HX_VISIT_MEMBER_NAME(_goToPlayState,"_goToPlayState");
	HX_VISIT_MEMBER_NAME(anims,"anims");
	HX_VISIT_MEMBER_NAME(animsTxt,"animsTxt");
	HX_VISIT_MEMBER_NAME(curAnim,"curAnim");
	HX_VISIT_MEMBER_NAME(camEditor,"camEditor");
	HX_VISIT_MEMBER_NAME(camHUD,"camHUD");
	HX_VISIT_MEMBER_NAME(UI_box,"UI_box");
	HX_VISIT_MEMBER_NAME(UI_characterbox,"UI_characterbox");
	HX_VISIT_MEMBER_NAME(unsavedProgress,"unsavedProgress");
	HX_VISIT_MEMBER_NAME(selectedFormat,"selectedFormat");
	HX_VISIT_MEMBER_NAME(ghostAlpha,"ghostAlpha");
	HX_VISIT_MEMBER_NAME(check_player,"check_player");
	HX_VISIT_MEMBER_NAME(charDropDown,"charDropDown");
	HX_VISIT_MEMBER_NAME(animationDropDown,"animationDropDown");
	HX_VISIT_MEMBER_NAME(animationInputText,"animationInputText");
	HX_VISIT_MEMBER_NAME(animationNameInputText,"animationNameInputText");
	HX_VISIT_MEMBER_NAME(animationIndicesInputText,"animationIndicesInputText");
	HX_VISIT_MEMBER_NAME(animationFramerate,"animationFramerate");
	HX_VISIT_MEMBER_NAME(animationLoopCheckBox,"animationLoopCheckBox");
	HX_VISIT_MEMBER_NAME(imageInputText,"imageInputText");
	HX_VISIT_MEMBER_NAME(healthIconInputText,"healthIconInputText");
	HX_VISIT_MEMBER_NAME(vocalsInputText,"vocalsInputText");
	HX_VISIT_MEMBER_NAME(singDurationStepper,"singDurationStepper");
	HX_VISIT_MEMBER_NAME(scaleStepper,"scaleStepper");
	HX_VISIT_MEMBER_NAME(positionXStepper,"positionXStepper");
	HX_VISIT_MEMBER_NAME(positionYStepper,"positionYStepper");
	HX_VISIT_MEMBER_NAME(positionCameraXStepper,"positionCameraXStepper");
	HX_VISIT_MEMBER_NAME(positionCameraYStepper,"positionCameraYStepper");
	HX_VISIT_MEMBER_NAME(flipXCheckBox,"flipXCheckBox");
	HX_VISIT_MEMBER_NAME(noAntialiasingCheckBox,"noAntialiasingCheckBox");
	HX_VISIT_MEMBER_NAME(healthColorStepperR,"healthColorStepperR");
	HX_VISIT_MEMBER_NAME(healthColorStepperG,"healthColorStepperG");
	HX_VISIT_MEMBER_NAME(healthColorStepperB,"healthColorStepperB");
	HX_VISIT_MEMBER_NAME(holdingArrowsTime,"holdingArrowsTime");
	HX_VISIT_MEMBER_NAME(holdingArrowsElapsed,"holdingArrowsElapsed");
	HX_VISIT_MEMBER_NAME(holdingFrameTime,"holdingFrameTime");
	HX_VISIT_MEMBER_NAME(holdingFrameElapsed,"holdingFrameElapsed");
	HX_VISIT_MEMBER_NAME(undoOffsets,"undoOffsets");
	HX_VISIT_MEMBER_NAME(assetFolder,"assetFolder");
	HX_VISIT_MEMBER_NAME(characterList,"characterList");
	HX_VISIT_MEMBER_NAME(_file,"_file");
	 ::backend::MusicBeatState_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val CharacterEditorState_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"ghost") ) { return ::hx::Val( ghost ); }
		if (HX_FIELD_EQ(inName,"_char") ) { return ::hx::Val( _char ); }
		if (HX_FIELD_EQ(inName,"anims") ) { return ::hx::Val( anims ); }
		if (HX_FIELD_EQ(inName,"_file") ) { return ::hx::Val( _file ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"helpBg") ) { return ::hx::Val( helpBg ); }
		if (HX_FIELD_EQ(inName,"camHUD") ) { return ::hx::Val( camHUD ); }
		if (HX_FIELD_EQ(inName,"UI_box") ) { return ::hx::Val( UI_box ); }
		if (HX_FIELD_EQ(inName,"create") ) { return ::hx::Val( create_dyn() ); }
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		if (HX_FIELD_EQ(inName,"loadBG") ) { return ::hx::Val( loadBG_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"curAnim") ) { return ::hx::Val( curAnim ); }
		if (HX_FIELD_EQ(inName,"UIEvent") ) { return ::hx::Val( UIEvent_dyn() ); }
		if (HX_FIELD_EQ(inName,"newAnim") ) { return ::hx::Val( newAnim_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"animsTxt") ) { return ::hx::Val( animsTxt ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"character") ) { return ::hx::Val( character ); }
		if (HX_FIELD_EQ(inName,"helpTexts") ) { return ::hx::Val( helpTexts ); }
		if (HX_FIELD_EQ(inName,"healthBar") ) { return ::hx::Val( healthBar ); }
		if (HX_FIELD_EQ(inName,"camEditor") ) { return ::hx::Val( camEditor ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"bfPosition") ) { return ::hx::Val( bfPosition ); }
		if (HX_FIELD_EQ(inName,"healthIcon") ) { return ::hx::Val( healthIcon ); }
		if (HX_FIELD_EQ(inName,"makeUIMenu") ) { return ::hx::Val( makeUIMenu_dyn() ); }
		if (HX_FIELD_EQ(inName,"ghostAlpha") ) { return ::hx::Val( ghostAlpha ); }
		if (HX_FIELD_EQ(inName,"addGhostUI") ) { return ::hx::Val( addGhostUI_dyn() ); }
		if (HX_FIELD_EQ(inName,"updateText") ) { return ::hx::Val( updateText_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"silhouettes") ) { return ::hx::Val( silhouettes ); }
		if (HX_FIELD_EQ(inName,"dadPosition") ) { return ::hx::Val( dadPosition ); }
		if (HX_FIELD_EQ(inName,"undoOffsets") ) { return ::hx::Val( undoOffsets ); }
		if (HX_FIELD_EQ(inName,"assetFolder") ) { return ::hx::Val( assetFolder ); }
		if (HX_FIELD_EQ(inName,"onSaveError") ) { return ::hx::Val( onSaveError_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"animateGhost") ) { return ::hx::Val( animateGhost ); }
		if (HX_FIELD_EQ(inName,"copiedOffset") ) { return ::hx::Val( copiedOffset ); }
		if (HX_FIELD_EQ(inName,"addCharacter") ) { return ::hx::Val( addCharacter_dyn() ); }
		if (HX_FIELD_EQ(inName,"check_player") ) { return ::hx::Val( check_player ); }
		if (HX_FIELD_EQ(inName,"charDropDown") ) { return ::hx::Val( charDropDown ); }
		if (HX_FIELD_EQ(inName,"scaleStepper") ) { return ::hx::Val( scaleStepper ); }
		if (HX_FIELD_EQ(inName,"addAnimation") ) { return ::hx::Val( addAnimation_dyn() ); }
		if (HX_FIELD_EQ(inName,"onSaveCancel") ) { return ::hx::Val( onSaveCancel_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"addHelpScreen") ) { return ::hx::Val( addHelpScreen_dyn() ); }
		if (HX_FIELD_EQ(inName,"addSettingsUI") ) { return ::hx::Val( addSettingsUI_dyn() ); }
		if (HX_FIELD_EQ(inName,"flipXCheckBox") ) { return ::hx::Val( flipXCheckBox ); }
		if (HX_FIELD_EQ(inName,"characterList") ) { return ::hx::Val( characterList ); }
		if (HX_FIELD_EQ(inName,"saveCharacter") ) { return ::hx::Val( saveCharacter_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"cameraZoomText") ) { return ::hx::Val( cameraZoomText ); }
		if (HX_FIELD_EQ(inName,"_goToPlayState") ) { return ::hx::Val( _goToPlayState ); }
		if (HX_FIELD_EQ(inName,"selectedFormat") ) { return ::hx::Val( selectedFormat ); }
		if (HX_FIELD_EQ(inName,"imageInputText") ) { return ::hx::Val( imageInputText ); }
		if (HX_FIELD_EQ(inName,"addCharacterUI") ) { return ::hx::Val( addCharacterUI_dyn() ); }
		if (HX_FIELD_EQ(inName,"updatePresence") ) { return ::hx::Val( updatePresence_dyn() ); }
		if (HX_FIELD_EQ(inName,"reloadAnimList") ) { return ::hx::Val( reloadAnimList_dyn() ); }
		if (HX_FIELD_EQ(inName,"onSaveComplete") ) { return ::hx::Val( onSaveComplete_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"isAnimateSprite") ) { return ::hx::Val( isAnimateSprite ); }
		if (HX_FIELD_EQ(inName,"UI_characterbox") ) { return ::hx::Val( UI_characterbox ); }
		if (HX_FIELD_EQ(inName,"unsavedProgress") ) { return ::hx::Val( unsavedProgress ); }
		if (HX_FIELD_EQ(inName,"addAnimationsUI") ) { return ::hx::Val( addAnimationsUI_dyn() ); }
		if (HX_FIELD_EQ(inName,"vocalsInputText") ) { return ::hx::Val( vocalsInputText ); }
		if (HX_FIELD_EQ(inName,"updateHealthBar") ) { return ::hx::Val( updateHealthBar_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"frameAdvanceText") ) { return ::hx::Val( frameAdvanceText ); }
		if (HX_FIELD_EQ(inName,"positionXStepper") ) { return ::hx::Val( positionXStepper ); }
		if (HX_FIELD_EQ(inName,"positionYStepper") ) { return ::hx::Val( positionYStepper ); }
		if (HX_FIELD_EQ(inName,"holdingFrameTime") ) { return ::hx::Val( holdingFrameTime ); }
		if (HX_FIELD_EQ(inName,"updatePointerPos") ) { return ::hx::Val( updatePointerPos_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"animateGhostImage") ) { return ::hx::Val( animateGhostImage ); }
		if (HX_FIELD_EQ(inName,"animationDropDown") ) { return ::hx::Val( animationDropDown ); }
		if (HX_FIELD_EQ(inName,"holdingArrowsTime") ) { return ::hx::Val( holdingArrowsTime ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"animationInputText") ) { return ::hx::Val( animationInputText ); }
		if (HX_FIELD_EQ(inName,"animationFramerate") ) { return ::hx::Val( animationFramerate ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"cameraFollowPointer") ) { return ::hx::Val( cameraFollowPointer ); }
		if (HX_FIELD_EQ(inName,"healthIconInputText") ) { return ::hx::Val( healthIconInputText ); }
		if (HX_FIELD_EQ(inName,"singDurationStepper") ) { return ::hx::Val( singDurationStepper ); }
		if (HX_FIELD_EQ(inName,"healthColorStepperR") ) { return ::hx::Val( healthColorStepperR ); }
		if (HX_FIELD_EQ(inName,"healthColorStepperG") ) { return ::hx::Val( healthColorStepperG ); }
		if (HX_FIELD_EQ(inName,"healthColorStepperB") ) { return ::hx::Val( healthColorStepperB ); }
		if (HX_FIELD_EQ(inName,"holdingFrameElapsed") ) { return ::hx::Val( holdingFrameElapsed ); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"reloadCharacterImage") ) { return ::hx::Val( reloadCharacterImage_dyn() ); }
		if (HX_FIELD_EQ(inName,"holdingArrowsElapsed") ) { return ::hx::Val( holdingArrowsElapsed ); }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"animationLoopCheckBox") ) { return ::hx::Val( animationLoopCheckBox ); }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"animationNameInputText") ) { return ::hx::Val( animationNameInputText ); }
		if (HX_FIELD_EQ(inName,"positionCameraXStepper") ) { return ::hx::Val( positionCameraXStepper ); }
		if (HX_FIELD_EQ(inName,"positionCameraYStepper") ) { return ::hx::Val( positionCameraYStepper ); }
		if (HX_FIELD_EQ(inName,"noAntialiasingCheckBox") ) { return ::hx::Val( noAntialiasingCheckBox ); }
		if (HX_FIELD_EQ(inName,"reloadCharacterOptions") ) { return ::hx::Val( reloadCharacterOptions_dyn() ); }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"reloadCharacterDropDown") ) { return ::hx::Val( reloadCharacterDropDown_dyn() ); }
		if (HX_FIELD_EQ(inName,"reloadAnimationDropDown") ) { return ::hx::Val( reloadAnimationDropDown_dyn() ); }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"updateCharacterPositions") ) { return ::hx::Val( updateCharacterPositions_dyn() ); }
		break;
	case 25:
		if (HX_FIELD_EQ(inName,"animationIndicesInputText") ) { return ::hx::Val( animationIndicesInputText ); }
		break;
	case 27:
		if (HX_FIELD_EQ(inName,"predictCharacterIsNotPlayer") ) { return ::hx::Val( predictCharacterIsNotPlayer_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val CharacterEditorState_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"ghost") ) { ghost=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_char") ) { _char=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"anims") ) { anims=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_file") ) { _file=inValue.Cast<  ::openfl::net::FileReference >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"helpBg") ) { helpBg=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		if (HX_FIELD_EQ(inName,"camHUD") ) { camHUD=inValue.Cast<  ::flixel::FlxCamera >(); return inValue; }
		if (HX_FIELD_EQ(inName,"UI_box") ) { UI_box=inValue.Cast<  ::backend::ui::PsychUIBox >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"curAnim") ) { curAnim=inValue.Cast< int >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"animsTxt") ) { animsTxt=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"character") ) { character=inValue.Cast<  ::objects::Character >(); return inValue; }
		if (HX_FIELD_EQ(inName,"helpTexts") ) { helpTexts=inValue.Cast<  ::flixel::group::FlxTypedSpriteGroup >(); return inValue; }
		if (HX_FIELD_EQ(inName,"healthBar") ) { healthBar=inValue.Cast<  ::objects::Bar >(); return inValue; }
		if (HX_FIELD_EQ(inName,"camEditor") ) { camEditor=inValue.Cast<  ::flixel::FlxCamera >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"bfPosition") ) { bfPosition=inValue.Cast<  ::flixel::math::FlxBasePoint >(); return inValue; }
		if (HX_FIELD_EQ(inName,"healthIcon") ) { healthIcon=inValue.Cast<  ::objects::HealthIcon >(); return inValue; }
		if (HX_FIELD_EQ(inName,"ghostAlpha") ) { ghostAlpha=inValue.Cast< Float >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"silhouettes") ) { silhouettes=inValue.Cast<  ::flixel::group::FlxTypedSpriteGroup >(); return inValue; }
		if (HX_FIELD_EQ(inName,"dadPosition") ) { dadPosition=inValue.Cast<  ::flixel::math::FlxBasePoint >(); return inValue; }
		if (HX_FIELD_EQ(inName,"undoOffsets") ) { undoOffsets=inValue.Cast< ::Array< Float > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"assetFolder") ) { assetFolder=inValue.Cast< ::String >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"animateGhost") ) { animateGhost=inValue.Cast<  ::flxanimate::PsychFlxAnimate >(); return inValue; }
		if (HX_FIELD_EQ(inName,"copiedOffset") ) { copiedOffset=inValue.Cast< ::Array< Float > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"check_player") ) { check_player=inValue.Cast<  ::backend::ui::PsychUICheckBox >(); return inValue; }
		if (HX_FIELD_EQ(inName,"charDropDown") ) { charDropDown=inValue.Cast<  ::backend::ui::PsychUIDropDownMenu >(); return inValue; }
		if (HX_FIELD_EQ(inName,"scaleStepper") ) { scaleStepper=inValue.Cast<  ::backend::ui::PsychUINumericStepper >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"flipXCheckBox") ) { flipXCheckBox=inValue.Cast<  ::backend::ui::PsychUICheckBox >(); return inValue; }
		if (HX_FIELD_EQ(inName,"characterList") ) { characterList=inValue.Cast< ::Array< ::String > >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"cameraZoomText") ) { cameraZoomText=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_goToPlayState") ) { _goToPlayState=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"selectedFormat") ) { selectedFormat=inValue.Cast<  ::flixel::text::FlxTextFormat >(); return inValue; }
		if (HX_FIELD_EQ(inName,"imageInputText") ) { imageInputText=inValue.Cast<  ::backend::ui::PsychUIInputText >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"isAnimateSprite") ) { isAnimateSprite=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"UI_characterbox") ) { UI_characterbox=inValue.Cast<  ::backend::ui::PsychUIBox >(); return inValue; }
		if (HX_FIELD_EQ(inName,"unsavedProgress") ) { unsavedProgress=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"vocalsInputText") ) { vocalsInputText=inValue.Cast<  ::backend::ui::PsychUIInputText >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"frameAdvanceText") ) { frameAdvanceText=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
		if (HX_FIELD_EQ(inName,"positionXStepper") ) { positionXStepper=inValue.Cast<  ::backend::ui::PsychUINumericStepper >(); return inValue; }
		if (HX_FIELD_EQ(inName,"positionYStepper") ) { positionYStepper=inValue.Cast<  ::backend::ui::PsychUINumericStepper >(); return inValue; }
		if (HX_FIELD_EQ(inName,"holdingFrameTime") ) { holdingFrameTime=inValue.Cast< Float >(); return inValue; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"animateGhostImage") ) { animateGhostImage=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"animationDropDown") ) { animationDropDown=inValue.Cast<  ::backend::ui::PsychUIDropDownMenu >(); return inValue; }
		if (HX_FIELD_EQ(inName,"holdingArrowsTime") ) { holdingArrowsTime=inValue.Cast< Float >(); return inValue; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"animationInputText") ) { animationInputText=inValue.Cast<  ::backend::ui::PsychUIInputText >(); return inValue; }
		if (HX_FIELD_EQ(inName,"animationFramerate") ) { animationFramerate=inValue.Cast<  ::backend::ui::PsychUINumericStepper >(); return inValue; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"cameraFollowPointer") ) { cameraFollowPointer=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		if (HX_FIELD_EQ(inName,"healthIconInputText") ) { healthIconInputText=inValue.Cast<  ::backend::ui::PsychUIInputText >(); return inValue; }
		if (HX_FIELD_EQ(inName,"singDurationStepper") ) { singDurationStepper=inValue.Cast<  ::backend::ui::PsychUINumericStepper >(); return inValue; }
		if (HX_FIELD_EQ(inName,"healthColorStepperR") ) { healthColorStepperR=inValue.Cast<  ::backend::ui::PsychUINumericStepper >(); return inValue; }
		if (HX_FIELD_EQ(inName,"healthColorStepperG") ) { healthColorStepperG=inValue.Cast<  ::backend::ui::PsychUINumericStepper >(); return inValue; }
		if (HX_FIELD_EQ(inName,"healthColorStepperB") ) { healthColorStepperB=inValue.Cast<  ::backend::ui::PsychUINumericStepper >(); return inValue; }
		if (HX_FIELD_EQ(inName,"holdingFrameElapsed") ) { holdingFrameElapsed=inValue.Cast< Float >(); return inValue; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"holdingArrowsElapsed") ) { holdingArrowsElapsed=inValue.Cast< Float >(); return inValue; }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"animationLoopCheckBox") ) { animationLoopCheckBox=inValue.Cast<  ::backend::ui::PsychUICheckBox >(); return inValue; }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"animationNameInputText") ) { animationNameInputText=inValue.Cast<  ::backend::ui::PsychUIInputText >(); return inValue; }
		if (HX_FIELD_EQ(inName,"positionCameraXStepper") ) { positionCameraXStepper=inValue.Cast<  ::backend::ui::PsychUINumericStepper >(); return inValue; }
		if (HX_FIELD_EQ(inName,"positionCameraYStepper") ) { positionCameraYStepper=inValue.Cast<  ::backend::ui::PsychUINumericStepper >(); return inValue; }
		if (HX_FIELD_EQ(inName,"noAntialiasingCheckBox") ) { noAntialiasingCheckBox=inValue.Cast<  ::backend::ui::PsychUICheckBox >(); return inValue; }
		break;
	case 25:
		if (HX_FIELD_EQ(inName,"animationIndicesInputText") ) { animationIndicesInputText=inValue.Cast<  ::backend::ui::PsychUIInputText >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void CharacterEditorState_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("character",a9,db,d1,41));
	outFields->push(HX_("ghost",4f,8f,58,93));
	outFields->push(HX_("animateGhost",ee,fc,d7,04));
	outFields->push(HX_("animateGhostImage",8d,f3,3c,78));
	outFields->push(HX_("cameraFollowPointer",67,dd,eb,9c));
	outFields->push(HX_("isAnimateSprite",3c,a3,97,78));
	outFields->push(HX_("silhouettes",9b,6b,d9,40));
	outFields->push(HX_("dadPosition",10,b2,12,3e));
	outFields->push(HX_("bfPosition",8d,16,5e,4d));
	outFields->push(HX_("helpBg",e6,5e,4e,04));
	outFields->push(HX_("helpTexts",a5,ec,c6,36));
	outFields->push(HX_("cameraZoomText",25,d1,82,9b));
	outFields->push(HX_("frameAdvanceText",22,cf,32,ac));
	outFields->push(HX_("healthBar",97,8a,92,42));
	outFields->push(HX_("healthIcon",35,ba,48,02));
	outFields->push(HX_("copiedOffset",f7,dd,2d,57));
	outFields->push(HX_("_char",b5,7a,d0,f4));
	outFields->push(HX_("_goToPlayState",7b,a5,cc,c0));
	outFields->push(HX_("anims",42,c9,e3,22));
	outFields->push(HX_("animsTxt",4e,12,c0,94));
	outFields->push(HX_("curAnim",b1,f7,86,ab));
	outFields->push(HX_("camEditor",1c,1f,8e,64));
	outFields->push(HX_("camHUD",e8,2b,76,b7));
	outFields->push(HX_("UI_box",60,07,ac,43));
	outFields->push(HX_("UI_characterbox",0d,36,f0,05));
	outFields->push(HX_("unsavedProgress",5b,33,8b,06));
	outFields->push(HX_("selectedFormat",f2,e3,ec,80));
	outFields->push(HX_("ghostAlpha",8f,a9,36,a1));
	outFields->push(HX_("check_player",38,8d,65,c6));
	outFields->push(HX_("charDropDown",27,81,d5,54));
	outFields->push(HX_("animationDropDown",55,ef,bb,0d));
	outFields->push(HX_("animationInputText",33,7a,56,eb));
	outFields->push(HX_("animationNameInputText",68,24,12,3c));
	outFields->push(HX_("animationIndicesInputText",d4,98,c7,74));
	outFields->push(HX_("animationFramerate",e9,d5,7d,25));
	outFields->push(HX_("animationLoopCheckBox",cb,a1,1d,ab));
	outFields->push(HX_("imageInputText",fc,06,6b,e2));
	outFields->push(HX_("healthIconInputText",e2,40,32,15));
	outFields->push(HX_("vocalsInputText",99,5d,5c,6d));
	outFields->push(HX_("singDurationStepper",8e,52,ae,5a));
	outFields->push(HX_("scaleStepper",a7,a3,a9,18));
	outFields->push(HX_("positionXStepper",42,59,01,70));
	outFields->push(HX_("positionYStepper",61,cb,33,a9));
	outFields->push(HX_("positionCameraXStepper",c7,05,a8,a8));
	outFields->push(HX_("positionCameraYStepper",e6,77,da,e1));
	outFields->push(HX_("flipXCheckBox",4e,0e,ce,8c));
	outFields->push(HX_("noAntialiasingCheckBox",18,44,c1,1d));
	outFields->push(HX_("healthColorStepperR",68,28,37,8b));
	outFields->push(HX_("healthColorStepperG",5d,28,37,8b));
	outFields->push(HX_("healthColorStepperB",58,28,37,8b));
	outFields->push(HX_("holdingArrowsTime",9a,f6,8d,72));
	outFields->push(HX_("holdingArrowsElapsed",cf,c3,f8,c5));
	outFields->push(HX_("holdingFrameTime",57,dd,57,76));
	outFields->push(HX_("holdingFrameElapsed",32,f1,cf,09));
	outFields->push(HX_("undoOffsets",bc,37,89,5d));
	outFields->push(HX_("assetFolder",be,68,f2,8e));
	outFields->push(HX_("characterList",a7,ac,9f,40));
	outFields->push(HX_("_file",5b,ea,cc,f6));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo CharacterEditorState_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::objects::Character */ ,(int)offsetof(CharacterEditorState_obj,character),HX_("character",a9,db,d1,41)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(CharacterEditorState_obj,ghost),HX_("ghost",4f,8f,58,93)},
	{::hx::fsObject /*  ::flxanimate::PsychFlxAnimate */ ,(int)offsetof(CharacterEditorState_obj,animateGhost),HX_("animateGhost",ee,fc,d7,04)},
	{::hx::fsString,(int)offsetof(CharacterEditorState_obj,animateGhostImage),HX_("animateGhostImage",8d,f3,3c,78)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(CharacterEditorState_obj,cameraFollowPointer),HX_("cameraFollowPointer",67,dd,eb,9c)},
	{::hx::fsBool,(int)offsetof(CharacterEditorState_obj,isAnimateSprite),HX_("isAnimateSprite",3c,a3,97,78)},
	{::hx::fsObject /*  ::flixel::group::FlxTypedSpriteGroup */ ,(int)offsetof(CharacterEditorState_obj,silhouettes),HX_("silhouettes",9b,6b,d9,40)},
	{::hx::fsObject /*  ::flixel::math::FlxBasePoint */ ,(int)offsetof(CharacterEditorState_obj,dadPosition),HX_("dadPosition",10,b2,12,3e)},
	{::hx::fsObject /*  ::flixel::math::FlxBasePoint */ ,(int)offsetof(CharacterEditorState_obj,bfPosition),HX_("bfPosition",8d,16,5e,4d)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(CharacterEditorState_obj,helpBg),HX_("helpBg",e6,5e,4e,04)},
	{::hx::fsObject /*  ::flixel::group::FlxTypedSpriteGroup */ ,(int)offsetof(CharacterEditorState_obj,helpTexts),HX_("helpTexts",a5,ec,c6,36)},
	{::hx::fsObject /*  ::flixel::text::FlxText */ ,(int)offsetof(CharacterEditorState_obj,cameraZoomText),HX_("cameraZoomText",25,d1,82,9b)},
	{::hx::fsObject /*  ::flixel::text::FlxText */ ,(int)offsetof(CharacterEditorState_obj,frameAdvanceText),HX_("frameAdvanceText",22,cf,32,ac)},
	{::hx::fsObject /*  ::objects::Bar */ ,(int)offsetof(CharacterEditorState_obj,healthBar),HX_("healthBar",97,8a,92,42)},
	{::hx::fsObject /*  ::objects::HealthIcon */ ,(int)offsetof(CharacterEditorState_obj,healthIcon),HX_("healthIcon",35,ba,48,02)},
	{::hx::fsObject /* ::Array< Float > */ ,(int)offsetof(CharacterEditorState_obj,copiedOffset),HX_("copiedOffset",f7,dd,2d,57)},
	{::hx::fsString,(int)offsetof(CharacterEditorState_obj,_char),HX_("_char",b5,7a,d0,f4)},
	{::hx::fsBool,(int)offsetof(CharacterEditorState_obj,_goToPlayState),HX_("_goToPlayState",7b,a5,cc,c0)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(CharacterEditorState_obj,anims),HX_("anims",42,c9,e3,22)},
	{::hx::fsObject /*  ::flixel::text::FlxText */ ,(int)offsetof(CharacterEditorState_obj,animsTxt),HX_("animsTxt",4e,12,c0,94)},
	{::hx::fsInt,(int)offsetof(CharacterEditorState_obj,curAnim),HX_("curAnim",b1,f7,86,ab)},
	{::hx::fsObject /*  ::flixel::FlxCamera */ ,(int)offsetof(CharacterEditorState_obj,camEditor),HX_("camEditor",1c,1f,8e,64)},
	{::hx::fsObject /*  ::flixel::FlxCamera */ ,(int)offsetof(CharacterEditorState_obj,camHUD),HX_("camHUD",e8,2b,76,b7)},
	{::hx::fsObject /*  ::backend::ui::PsychUIBox */ ,(int)offsetof(CharacterEditorState_obj,UI_box),HX_("UI_box",60,07,ac,43)},
	{::hx::fsObject /*  ::backend::ui::PsychUIBox */ ,(int)offsetof(CharacterEditorState_obj,UI_characterbox),HX_("UI_characterbox",0d,36,f0,05)},
	{::hx::fsBool,(int)offsetof(CharacterEditorState_obj,unsavedProgress),HX_("unsavedProgress",5b,33,8b,06)},
	{::hx::fsObject /*  ::flixel::text::FlxTextFormat */ ,(int)offsetof(CharacterEditorState_obj,selectedFormat),HX_("selectedFormat",f2,e3,ec,80)},
	{::hx::fsFloat,(int)offsetof(CharacterEditorState_obj,ghostAlpha),HX_("ghostAlpha",8f,a9,36,a1)},
	{::hx::fsObject /*  ::backend::ui::PsychUICheckBox */ ,(int)offsetof(CharacterEditorState_obj,check_player),HX_("check_player",38,8d,65,c6)},
	{::hx::fsObject /*  ::backend::ui::PsychUIDropDownMenu */ ,(int)offsetof(CharacterEditorState_obj,charDropDown),HX_("charDropDown",27,81,d5,54)},
	{::hx::fsObject /*  ::backend::ui::PsychUIDropDownMenu */ ,(int)offsetof(CharacterEditorState_obj,animationDropDown),HX_("animationDropDown",55,ef,bb,0d)},
	{::hx::fsObject /*  ::backend::ui::PsychUIInputText */ ,(int)offsetof(CharacterEditorState_obj,animationInputText),HX_("animationInputText",33,7a,56,eb)},
	{::hx::fsObject /*  ::backend::ui::PsychUIInputText */ ,(int)offsetof(CharacterEditorState_obj,animationNameInputText),HX_("animationNameInputText",68,24,12,3c)},
	{::hx::fsObject /*  ::backend::ui::PsychUIInputText */ ,(int)offsetof(CharacterEditorState_obj,animationIndicesInputText),HX_("animationIndicesInputText",d4,98,c7,74)},
	{::hx::fsObject /*  ::backend::ui::PsychUINumericStepper */ ,(int)offsetof(CharacterEditorState_obj,animationFramerate),HX_("animationFramerate",e9,d5,7d,25)},
	{::hx::fsObject /*  ::backend::ui::PsychUICheckBox */ ,(int)offsetof(CharacterEditorState_obj,animationLoopCheckBox),HX_("animationLoopCheckBox",cb,a1,1d,ab)},
	{::hx::fsObject /*  ::backend::ui::PsychUIInputText */ ,(int)offsetof(CharacterEditorState_obj,imageInputText),HX_("imageInputText",fc,06,6b,e2)},
	{::hx::fsObject /*  ::backend::ui::PsychUIInputText */ ,(int)offsetof(CharacterEditorState_obj,healthIconInputText),HX_("healthIconInputText",e2,40,32,15)},
	{::hx::fsObject /*  ::backend::ui::PsychUIInputText */ ,(int)offsetof(CharacterEditorState_obj,vocalsInputText),HX_("vocalsInputText",99,5d,5c,6d)},
	{::hx::fsObject /*  ::backend::ui::PsychUINumericStepper */ ,(int)offsetof(CharacterEditorState_obj,singDurationStepper),HX_("singDurationStepper",8e,52,ae,5a)},
	{::hx::fsObject /*  ::backend::ui::PsychUINumericStepper */ ,(int)offsetof(CharacterEditorState_obj,scaleStepper),HX_("scaleStepper",a7,a3,a9,18)},
	{::hx::fsObject /*  ::backend::ui::PsychUINumericStepper */ ,(int)offsetof(CharacterEditorState_obj,positionXStepper),HX_("positionXStepper",42,59,01,70)},
	{::hx::fsObject /*  ::backend::ui::PsychUINumericStepper */ ,(int)offsetof(CharacterEditorState_obj,positionYStepper),HX_("positionYStepper",61,cb,33,a9)},
	{::hx::fsObject /*  ::backend::ui::PsychUINumericStepper */ ,(int)offsetof(CharacterEditorState_obj,positionCameraXStepper),HX_("positionCameraXStepper",c7,05,a8,a8)},
	{::hx::fsObject /*  ::backend::ui::PsychUINumericStepper */ ,(int)offsetof(CharacterEditorState_obj,positionCameraYStepper),HX_("positionCameraYStepper",e6,77,da,e1)},
	{::hx::fsObject /*  ::backend::ui::PsychUICheckBox */ ,(int)offsetof(CharacterEditorState_obj,flipXCheckBox),HX_("flipXCheckBox",4e,0e,ce,8c)},
	{::hx::fsObject /*  ::backend::ui::PsychUICheckBox */ ,(int)offsetof(CharacterEditorState_obj,noAntialiasingCheckBox),HX_("noAntialiasingCheckBox",18,44,c1,1d)},
	{::hx::fsObject /*  ::backend::ui::PsychUINumericStepper */ ,(int)offsetof(CharacterEditorState_obj,healthColorStepperR),HX_("healthColorStepperR",68,28,37,8b)},
	{::hx::fsObject /*  ::backend::ui::PsychUINumericStepper */ ,(int)offsetof(CharacterEditorState_obj,healthColorStepperG),HX_("healthColorStepperG",5d,28,37,8b)},
	{::hx::fsObject /*  ::backend::ui::PsychUINumericStepper */ ,(int)offsetof(CharacterEditorState_obj,healthColorStepperB),HX_("healthColorStepperB",58,28,37,8b)},
	{::hx::fsFloat,(int)offsetof(CharacterEditorState_obj,holdingArrowsTime),HX_("holdingArrowsTime",9a,f6,8d,72)},
	{::hx::fsFloat,(int)offsetof(CharacterEditorState_obj,holdingArrowsElapsed),HX_("holdingArrowsElapsed",cf,c3,f8,c5)},
	{::hx::fsFloat,(int)offsetof(CharacterEditorState_obj,holdingFrameTime),HX_("holdingFrameTime",57,dd,57,76)},
	{::hx::fsFloat,(int)offsetof(CharacterEditorState_obj,holdingFrameElapsed),HX_("holdingFrameElapsed",32,f1,cf,09)},
	{::hx::fsObject /* ::Array< Float > */ ,(int)offsetof(CharacterEditorState_obj,undoOffsets),HX_("undoOffsets",bc,37,89,5d)},
	{::hx::fsString,(int)offsetof(CharacterEditorState_obj,assetFolder),HX_("assetFolder",be,68,f2,8e)},
	{::hx::fsObject /* ::Array< ::String > */ ,(int)offsetof(CharacterEditorState_obj,characterList),HX_("characterList",a7,ac,9f,40)},
	{::hx::fsObject /*  ::openfl::net::FileReference */ ,(int)offsetof(CharacterEditorState_obj,_file),HX_("_file",5b,ea,cc,f6)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *CharacterEditorState_obj_sStaticStorageInfo = 0;
#endif

static ::String CharacterEditorState_obj_sMemberFields[] = {
	HX_("character",a9,db,d1,41),
	HX_("ghost",4f,8f,58,93),
	HX_("animateGhost",ee,fc,d7,04),
	HX_("animateGhostImage",8d,f3,3c,78),
	HX_("cameraFollowPointer",67,dd,eb,9c),
	HX_("isAnimateSprite",3c,a3,97,78),
	HX_("silhouettes",9b,6b,d9,40),
	HX_("dadPosition",10,b2,12,3e),
	HX_("bfPosition",8d,16,5e,4d),
	HX_("helpBg",e6,5e,4e,04),
	HX_("helpTexts",a5,ec,c6,36),
	HX_("cameraZoomText",25,d1,82,9b),
	HX_("frameAdvanceText",22,cf,32,ac),
	HX_("healthBar",97,8a,92,42),
	HX_("healthIcon",35,ba,48,02),
	HX_("copiedOffset",f7,dd,2d,57),
	HX_("_char",b5,7a,d0,f4),
	HX_("_goToPlayState",7b,a5,cc,c0),
	HX_("anims",42,c9,e3,22),
	HX_("animsTxt",4e,12,c0,94),
	HX_("curAnim",b1,f7,86,ab),
	HX_("camEditor",1c,1f,8e,64),
	HX_("camHUD",e8,2b,76,b7),
	HX_("UI_box",60,07,ac,43),
	HX_("UI_characterbox",0d,36,f0,05),
	HX_("unsavedProgress",5b,33,8b,06),
	HX_("selectedFormat",f2,e3,ec,80),
	HX_("create",fc,66,0f,7c),
	HX_("addHelpScreen",8e,32,66,90),
	HX_("addCharacter",48,fd,25,41),
	HX_("makeUIMenu",81,d6,03,55),
	HX_("ghostAlpha",8f,a9,36,a1),
	HX_("addGhostUI",42,b7,a0,ed),
	HX_("check_player",38,8d,65,c6),
	HX_("charDropDown",27,81,d5,54),
	HX_("addSettingsUI",78,4f,8a,5d),
	HX_("animationDropDown",55,ef,bb,0d),
	HX_("animationInputText",33,7a,56,eb),
	HX_("animationNameInputText",68,24,12,3c),
	HX_("animationIndicesInputText",d4,98,c7,74),
	HX_("animationFramerate",e9,d5,7d,25),
	HX_("animationLoopCheckBox",cb,a1,1d,ab),
	HX_("addAnimationsUI",c4,44,96,30),
	HX_("imageInputText",fc,06,6b,e2),
	HX_("healthIconInputText",e2,40,32,15),
	HX_("vocalsInputText",99,5d,5c,6d),
	HX_("singDurationStepper",8e,52,ae,5a),
	HX_("scaleStepper",a7,a3,a9,18),
	HX_("positionXStepper",42,59,01,70),
	HX_("positionYStepper",61,cb,33,a9),
	HX_("positionCameraXStepper",c7,05,a8,a8),
	HX_("positionCameraYStepper",e6,77,da,e1),
	HX_("flipXCheckBox",4e,0e,ce,8c),
	HX_("noAntialiasingCheckBox",18,44,c1,1d),
	HX_("healthColorStepperR",68,28,37,8b),
	HX_("healthColorStepperG",5d,28,37,8b),
	HX_("healthColorStepperB",58,28,37,8b),
	HX_("addCharacterUI",9c,29,96,54),
	HX_("UIEvent",26,fd,9f,07),
	HX_("reloadCharacterImage",2b,80,35,0a),
	HX_("reloadCharacterOptions",2e,68,40,41),
	HX_("holdingArrowsTime",9a,f6,8d,72),
	HX_("holdingArrowsElapsed",cf,c3,f8,c5),
	HX_("holdingFrameTime",57,dd,57,76),
	HX_("holdingFrameElapsed",32,f1,cf,09),
	HX_("undoOffsets",bc,37,89,5d),
	HX_("update",09,86,05,87),
	HX_("assetFolder",be,68,f2,8e),
	HX_("loadBG",6b,29,6f,58),
	HX_("updatePointerPos",40,78,8c,09),
	HX_("updateHealthBar",4e,5b,1d,92),
	HX_("updatePresence",64,45,01,9c),
	HX_("reloadAnimList",88,3b,92,6a),
	HX_("updateText",56,b7,ae,05),
	HX_("updateCharacterPositions",2a,9b,bf,f9),
	HX_("predictCharacterIsNotPlayer",1a,70,b5,04),
	HX_("addAnimation",a3,10,89,4a),
	HX_("newAnim",91,32,3e,f0),
	HX_("characterList",a7,ac,9f,40),
	HX_("reloadCharacterDropDown",61,a1,b4,a0),
	HX_("reloadAnimationDropDown",bc,07,b3,2b),
	HX_("_file",5b,ea,cc,f6),
	HX_("onSaveComplete",d5,ac,3f,bc),
	HX_("onSaveCancel",96,1a,31,d9),
	HX_("onSaveError",2c,b6,19,24),
	HX_("saveCharacter",ac,60,8c,66),
	::String(null()) };

::hx::Class CharacterEditorState_obj::__mClass;

void CharacterEditorState_obj::__register()
{
	CharacterEditorState_obj _hx_dummy;
	CharacterEditorState_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("states.editors.CharacterEditorState",0f,02,8c,78);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(CharacterEditorState_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< CharacterEditorState_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = CharacterEditorState_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = CharacterEditorState_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace states
} // end namespace editors
