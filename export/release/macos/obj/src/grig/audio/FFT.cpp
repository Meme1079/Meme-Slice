// Generated by Haxe 4.3.7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_grig_audio_FFT
#include <grig/audio/FFT.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_260fd16454ed33ab_24_new,"grig.audio.FFT","new",0x9bc09609,"grig.audio.FFT.new","grig/audio/FFT.hx",24,0x041fb1c9)
HX_LOCAL_STACK_FRAME(_hx_pos_260fd16454ed33ab_55_bitReverse,"grig.audio.FFT","bitReverse",0x72e23d4c,"grig.audio.FFT.bitReverse","grig/audio/FFT.hx",55,0x041fb1c9)
HX_LOCAL_STACK_FRAME(_hx_pos_260fd16454ed33ab_69_generateTables,"grig.audio.FFT","generateTables",0xbde5b6b1,"grig.audio.FFT.generateTables","grig/audio/FFT.hx",69,0x041fb1c9)
HX_LOCAL_STACK_FRAME(_hx_pos_260fd16454ed33ab_84_doFFT,"grig.audio.FFT","doFFT",0xc20e4e52,"grig.audio.FFT.doFFT","grig/audio/FFT.hx",84,0x041fb1c9)
HX_LOCAL_STACK_FRAME(_hx_pos_260fd16454ed33ab_114_calcFreq,"grig.audio.FFT","calcFreq",0x9b6f65a4,"grig.audio.FFT.calcFreq","grig/audio/FFT.hx",114,0x041fb1c9)
HX_LOCAL_STACK_FRAME(_hx_pos_260fd16454ed33ab_51_clamp_Int,"grig.audio.FFT","clamp_Int",0x338a00b4,"grig.audio.FFT.clamp_Int","grig/audio/FFT.hx",51,0x041fb1c9)
HX_LOCAL_STACK_FRAME(_hx_pos_260fd16454ed33ab_46_log,"grig.audio.FFT","log",0x9bbf1a2d,"grig.audio.FFT.log","grig/audio/FFT.hx",46,0x041fb1c9)
HX_LOCAL_STACK_FRAME(_hx_pos_260fd16454ed33ab_26_boot,"grig.audio.FFT","boot",0xa4dbb269,"grig.audio.FFT.boot","grig/audio/FFT.hx",26,0x041fb1c9)
namespace grig{
namespace audio{

void FFT_obj::__construct(::hx::Null< int >  __o_n){
            		int n = __o_n.Default(512);
            	HX_STACKFRAME(&_hx_pos_260fd16454ed33ab_24_new)
HXLINE(  30)		this->roots = ::Array_obj< ::Dynamic>::__new();
HXLINE(  29)		this->reversed = ::Array_obj< int >::__new();
HXLINE(  28)		this->hamming = ::Array_obj< Float >::__new();
HXLINE(  35)		this->hamming->resize(n);
HXLINE(  36)		this->reversed->resize(n);
HXLINE(  37)		::Array< ::Dynamic> _hx_tmp = this->roots;
HXDLIN(  37)		_hx_tmp->resize(::Std_obj::_hx_int((( (Float)(n) ) / ( (Float)(2) ))));
HXLINE(  39)		this->n = n;
HXLINE(  40)		this->logN = ::Std_obj::_hx_int(::grig::audio::FFT_obj::log(((Float)2.0),( (Float)(n) )));
HXLINE(  41)		this->generateTables();
            	}

Dynamic FFT_obj::__CreateEmpty() { return new FFT_obj; }

void *FFT_obj::_hx_vtable = 0;

Dynamic FFT_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< FFT_obj > _hx_result = new FFT_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool FFT_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x7d4febc7;
}

int FFT_obj::bitReverse(int x){
            	HX_STACKFRAME(&_hx_pos_260fd16454ed33ab_55_bitReverse)
HXLINE(  56)		int y = 0;
HXLINE(  58)		int i = this->logN;
HXLINE(  59)		while((i > 0)){
HXLINE(  60)			y = ((y << 1) | (x & 1));
HXLINE(  61)			x = (x >> 1);
HXLINE(  62)			i = (i - 1);
            		}
HXLINE(  65)		return y;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FFT_obj,bitReverse,return )

void FFT_obj::generateTables(){
            	HX_STACKFRAME(&_hx_pos_260fd16454ed33ab_69_generateTables)
HXLINE(  70)		{
HXLINE(  70)			int _g = 0;
HXDLIN(  70)			int _g1 = this->n;
HXDLIN(  70)			while((_g < _g1)){
HXLINE(  70)				_g = (_g + 1);
HXDLIN(  70)				int i = (_g - 1);
HXLINE(  71)				this->hamming[i] = (( (Float)(1) ) - (((Float)0.85) * ::Math_obj::cos((( (Float)(i) ) * (::grig::audio::FFT_obj::TWO_PI / ( (Float)(this->n) ))))));
            			}
            		}
HXLINE(  72)		{
HXLINE(  72)			int _g2 = 0;
HXDLIN(  72)			int _g3 = this->reversed->length;
HXDLIN(  72)			while((_g2 < _g3)){
HXLINE(  72)				_g2 = (_g2 + 1);
HXDLIN(  72)				int i1 = (_g2 - 1);
HXLINE(  73)				this->reversed[i1] = this->bitReverse(i1);
            			}
            		}
HXLINE(  74)		{
HXLINE(  74)			int _g4 = 0;
HXDLIN(  74)			int _g5 = ::Std_obj::_hx_int((( (Float)(this->n) ) / ( (Float)(2) )));
HXDLIN(  74)			while((_g4 < _g5)){
HXLINE(  74)				_g4 = (_g4 + 1);
HXDLIN(  74)				int i2 = (_g4 - 1);
HXLINE(  75)				 ::Dynamic z =  ::Dynamic(::hx::Anon_obj::Create(2)
            					->setFixed(0,HX_("imag",ca,71,ba,45),(( (Float)(i2) ) * (::grig::audio::FFT_obj::TWO_PI / ( (Float)(this->n) ))))
            					->setFixed(1,HX_("real",5e,4b,a7,4b),0));
HXDLIN(  75)				Float m = ::Math_obj::exp(( (Float)(z->__Field(HX_("real",5e,4b,a7,4b),::hx::paccDynamic)) ));
HXDLIN(  75)				Float phi = ( (Float)(z->__Field(HX_("imag",ca,71,ba,45),::hx::paccDynamic)) );
HXDLIN(  75)				this->roots[i2] =  ::Dynamic(::hx::Anon_obj::Create(2)
            					->setFixed(0,HX_("imag",ca,71,ba,45),(m * ::Math_obj::sin(phi)))
            					->setFixed(1,HX_("real",5e,4b,a7,4b),(m * ::Math_obj::cos(phi))));
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(FFT_obj,generateTables,(void))

void FFT_obj::doFFT(::Array< ::Dynamic> a){
            	HX_STACKFRAME(&_hx_pos_260fd16454ed33ab_84_doFFT)
HXLINE(  85)		int half = 1;
HXLINE(  86)		int inv = ::Std_obj::_hx_int((( (Float)(a->length) ) / ( (Float)(2) )));
HXLINE(  89)		while((inv > 0)){
HXLINE(  91)			int g = 0;
HXLINE(  92)			while((g < a->length)){
HXLINE(  94)				int b = 0;
HXLINE(  95)				int r = 0;
HXLINE(  96)				while((b < half)){
HXLINE(  97)					 ::Dynamic even = a->__get((g + b));
HXLINE(  98)					 ::Dynamic this1 = this->roots->__get(r);
HXDLIN(  98)					 ::Dynamic z = a->__get(((g + half) + b));
HXDLIN(  98)					Float odd_real = ((( (Float)(this1->__Field(HX_("real",5e,4b,a7,4b),::hx::paccDynamic)) ) * ( (Float)(z->__Field(HX_("real",5e,4b,a7,4b),::hx::paccDynamic)) )) - (( (Float)(this1->__Field(HX_("imag",ca,71,ba,45),::hx::paccDynamic)) ) * ( (Float)(z->__Field(HX_("imag",ca,71,ba,45),::hx::paccDynamic)) )));
HXDLIN(  98)					Float odd_imag = ((( (Float)(this1->__Field(HX_("real",5e,4b,a7,4b),::hx::paccDynamic)) ) * ( (Float)(z->__Field(HX_("imag",ca,71,ba,45),::hx::paccDynamic)) )) + (( (Float)(this1->__Field(HX_("imag",ca,71,ba,45),::hx::paccDynamic)) ) * ( (Float)(z->__Field(HX_("real",5e,4b,a7,4b),::hx::paccDynamic)) )));
HXLINE(  99)					a[(g + b)] =  ::Dynamic(::hx::Anon_obj::Create(2)
            						->setFixed(0,HX_("imag",ca,71,ba,45), ::Dynamic((even->__Field(HX_("imag",ca,71,ba,45),::hx::paccDynamic) + odd_imag)))
            						->setFixed(1,HX_("real",5e,4b,a7,4b), ::Dynamic((even->__Field(HX_("real",5e,4b,a7,4b),::hx::paccDynamic) + odd_real))));
HXLINE( 100)					a[((g + half) + b)] =  ::Dynamic(::hx::Anon_obj::Create(2)
            						->setFixed(0,HX_("imag",ca,71,ba,45),(( (Float)(even->__Field(HX_("imag",ca,71,ba,45),::hx::paccDynamic)) ) - odd_imag))
            						->setFixed(1,HX_("real",5e,4b,a7,4b),(( (Float)(even->__Field(HX_("real",5e,4b,a7,4b),::hx::paccDynamic)) ) - odd_real)));
HXLINE( 101)					b = (b + 1);
HXLINE( 102)					r = (r + inv);
            				}
HXLINE( 104)				g = (g + (half << 1));
            			}
HXLINE( 107)			half = (half << 1);
HXLINE( 108)			inv = (inv >> 1);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(FFT_obj,doFFT,(void))

::Array< Float > FFT_obj::calcFreq(::Array< Float > data){
            	HX_STACKFRAME(&_hx_pos_260fd16454ed33ab_114_calcFreq)
HXLINE( 117)		::Array< ::Dynamic> a = ::Array_obj< ::Dynamic>::__new();
HXLINE( 118)		::Array< Float > freq = ::Array_obj< Float >::__new();
HXLINE( 119)		a->resize(this->n);
HXLINE( 120)		freq->resize(::Std_obj::_hx_int((( (Float)(this->n) ) / ( (Float)(2) ))));
HXLINE( 121)		{
HXLINE( 121)			int _g = 0;
HXDLIN( 121)			int _g1 = a->length;
HXDLIN( 121)			while((_g < _g1)){
HXLINE( 121)				_g = (_g + 1);
HXDLIN( 121)				int i = (_g - 1);
HXLINE( 122)				a[this->reversed->__get(i)] =  ::Dynamic(::hx::Anon_obj::Create(2)
            					->setFixed(0,HX_("imag",ca,71,ba,45),((Float)0.0))
            					->setFixed(1,HX_("real",5e,4b,a7,4b),(data->__get(i) * this->hamming->__get(i))));
            			}
            		}
HXLINE( 124)		this->doFFT(a);
HXLINE( 129)		{
HXLINE( 129)			int _g2 = 0;
HXDLIN( 129)			int _g3 = ::Std_obj::_hx_int((( (Float)(this->n) ) / ( (Float)(2) )));
HXDLIN( 129)			while((_g2 < _g3)){
HXLINE( 129)				_g2 = (_g2 + 1);
HXDLIN( 129)				int i1 = (_g2 - 1);
HXLINE( 130)				 ::Dynamic z = a->__get((1 + i1));
HXDLIN( 130)				freq[i1] = ((( (Float)(2) ) * ::Math_obj::sqrt(((( (Float)(z->__Field(HX_("real",5e,4b,a7,4b),::hx::paccDynamic)) ) * ( (Float)(z->__Field(HX_("real",5e,4b,a7,4b),::hx::paccDynamic)) )) + (( (Float)(z->__Field(HX_("imag",ca,71,ba,45),::hx::paccDynamic)) ) * ( (Float)(z->__Field(HX_("imag",ca,71,ba,45),::hx::paccDynamic)) ))))) / ( (Float)(this->n) ));
            			}
            		}
HXLINE( 133)		int _hx_tmp = (::Std_obj::_hx_int((( (Float)(this->n) ) / ( (Float)(2) ))) - 1);
HXDLIN( 133)		 ::Dynamic z1 = a->__get(::Std_obj::_hx_int((( (Float)(this->n) ) / ( (Float)(2) ))));
HXDLIN( 133)		freq[_hx_tmp] = (::Math_obj::sqrt(((( (Float)(z1->__Field(HX_("real",5e,4b,a7,4b),::hx::paccDynamic)) ) * ( (Float)(z1->__Field(HX_("real",5e,4b,a7,4b),::hx::paccDynamic)) )) + (( (Float)(z1->__Field(HX_("imag",ca,71,ba,45),::hx::paccDynamic)) ) * ( (Float)(z1->__Field(HX_("imag",ca,71,ba,45),::hx::paccDynamic)) )))) / ( (Float)(this->n) ));
HXLINE( 135)		return freq;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FFT_obj,calcFreq,return )

int FFT_obj::clamp_Int(int value,int lower,int upper){
            	HX_STACKFRAME(&_hx_pos_260fd16454ed33ab_51_clamp_Int)
HXDLIN(  51)		if ((value < lower)) {
HXDLIN(  51)			return lower;
            		}
            		else {
HXDLIN(  51)			if ((value > upper)) {
HXDLIN(  51)				return upper;
            			}
            			else {
HXDLIN(  51)				return value;
            			}
            		}
HXDLIN(  51)		return 0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(FFT_obj,clamp_Int,return )

Float FFT_obj::TWO_PI;

Float FFT_obj::log(Float base,Float x){
            	HX_STACKFRAME(&_hx_pos_260fd16454ed33ab_46_log)
HXDLIN(  46)		return (::Math_obj::log(x) / ::Math_obj::log(base));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(FFT_obj,log,return )


::hx::ObjectPtr< FFT_obj > FFT_obj::__new(::hx::Null< int >  __o_n) {
	::hx::ObjectPtr< FFT_obj > __this = new FFT_obj();
	__this->__construct(__o_n);
	return __this;
}

::hx::ObjectPtr< FFT_obj > FFT_obj::__alloc(::hx::Ctx *_hx_ctx,::hx::Null< int >  __o_n) {
	FFT_obj *__this = (FFT_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(FFT_obj), true, "grig.audio.FFT"));
	*(void **)__this = FFT_obj::_hx_vtable;
	__this->__construct(__o_n);
	return __this;
}

FFT_obj::FFT_obj()
{
}

void FFT_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(FFT);
	HX_MARK_MEMBER_NAME(hamming,"hamming");
	HX_MARK_MEMBER_NAME(reversed,"reversed");
	HX_MARK_MEMBER_NAME(roots,"roots");
	HX_MARK_MEMBER_NAME(n,"n");
	HX_MARK_MEMBER_NAME(logN,"logN");
	HX_MARK_END_CLASS();
}

void FFT_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(hamming,"hamming");
	HX_VISIT_MEMBER_NAME(reversed,"reversed");
	HX_VISIT_MEMBER_NAME(roots,"roots");
	HX_VISIT_MEMBER_NAME(n,"n");
	HX_VISIT_MEMBER_NAME(logN,"logN");
}

::hx::Val FFT_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"n") ) { return ::hx::Val( n ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"logN") ) { return ::hx::Val( logN ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"roots") ) { return ::hx::Val( roots ); }
		if (HX_FIELD_EQ(inName,"doFFT") ) { return ::hx::Val( doFFT_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"hamming") ) { return ::hx::Val( hamming ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"reversed") ) { return ::hx::Val( reversed ); }
		if (HX_FIELD_EQ(inName,"calcFreq") ) { return ::hx::Val( calcFreq_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"bitReverse") ) { return ::hx::Val( bitReverse_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"generateTables") ) { return ::hx::Val( generateTables_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool FFT_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"log") ) { outValue = log_dyn(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"TWO_PI") ) { outValue = ( TWO_PI ); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"clamp_Int") ) { outValue = clamp_Int_dyn(); return true; }
	}
	return false;
}

::hx::Val FFT_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"n") ) { n=inValue.Cast< int >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"logN") ) { logN=inValue.Cast< int >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"roots") ) { roots=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"hamming") ) { hamming=inValue.Cast< ::Array< Float > >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"reversed") ) { reversed=inValue.Cast< ::Array< int > >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool FFT_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"TWO_PI") ) { TWO_PI=ioValue.Cast< Float >(); return true; }
	}
	return false;
}

void FFT_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("hamming",e9,c7,5f,b8));
	outFields->push(HX_("reversed",02,c5,b5,81));
	outFields->push(HX_("roots",11,70,61,ed));
	outFields->push(HX_("n",6e,00,00,00));
	outFields->push(HX_("logN",4a,9f,b7,47));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo FFT_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /* ::Array< Float > */ ,(int)offsetof(FFT_obj,hamming),HX_("hamming",e9,c7,5f,b8)},
	{::hx::fsObject /* ::Array< int > */ ,(int)offsetof(FFT_obj,reversed),HX_("reversed",02,c5,b5,81)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(FFT_obj,roots),HX_("roots",11,70,61,ed)},
	{::hx::fsInt,(int)offsetof(FFT_obj,n),HX_("n",6e,00,00,00)},
	{::hx::fsInt,(int)offsetof(FFT_obj,logN),HX_("logN",4a,9f,b7,47)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo FFT_obj_sStaticStorageInfo[] = {
	{::hx::fsFloat,(void *) &FFT_obj::TWO_PI,HX_("TWO_PI",2c,fe,56,e2)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String FFT_obj_sMemberFields[] = {
	HX_("hamming",e9,c7,5f,b8),
	HX_("reversed",02,c5,b5,81),
	HX_("roots",11,70,61,ed),
	HX_("n",6e,00,00,00),
	HX_("logN",4a,9f,b7,47),
	HX_("bitReverse",d5,0b,af,f4),
	HX_("generateTables",ba,fd,16,83),
	HX_("doFFT",69,0c,a6,dd),
	HX_("calcFreq",ed,4f,f6,3d),
	::String(null()) };

static void FFT_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(FFT_obj::TWO_PI,"TWO_PI");
};

#ifdef HXCPP_VISIT_ALLOCS
static void FFT_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(FFT_obj::TWO_PI,"TWO_PI");
};

#endif

::hx::Class FFT_obj::__mClass;

static ::String FFT_obj_sStaticFields[] = {
	HX_("clamp_Int",4b,16,10,c7),
	HX_("TWO_PI",2c,fe,56,e2),
	HX_("log",84,54,52,00),
	::String(null())
};

void FFT_obj::__register()
{
	FFT_obj _hx_dummy;
	FFT_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("grig.audio.FFT",97,dd,50,15);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &FFT_obj::__GetStatic;
	__mClass->mSetStaticField = &FFT_obj::__SetStatic;
	__mClass->mMarkFunc = FFT_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(FFT_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(FFT_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< FFT_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = FFT_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FFT_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FFT_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void FFT_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_260fd16454ed33ab_26_boot)
HXDLIN(  26)		TWO_PI = ((Float)6.2831853);
            	}
}

} // end namespace grig
} // end namespace audio
