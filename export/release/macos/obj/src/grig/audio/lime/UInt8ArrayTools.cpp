// Generated by Haxe 4.3.7
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_grig_audio_lime_UInt8ArrayTools
#include <grig/audio/lime/UInt8ArrayTools.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_lime_utils_ArrayBufferView
#include <lime/utils/ArrayBufferView.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_87e0094afb26cdf5_7_getInt16,"grig.audio.lime.UInt8ArrayTools","getInt16",0xa52ff148,"grig.audio.lime.UInt8ArrayTools.getInt16","grig/audio/lime/UInt8ArrayTools.hx",7,0x25b10579)
HX_LOCAL_STACK_FRAME(_hx_pos_87e0094afb26cdf5_14_getInt24,"grig.audio.lime.UInt8ArrayTools","getInt24",0xa52ff225,"grig.audio.lime.UInt8ArrayTools.getInt24","grig/audio/lime/UInt8ArrayTools.hx",14,0x25b10579)
HX_LOCAL_STACK_FRAME(_hx_pos_87e0094afb26cdf5_22_getInt32,"grig.audio.lime.UInt8ArrayTools","getInt32",0xa52ff302,"grig.audio.lime.UInt8ArrayTools.getInt32","grig/audio/lime/UInt8ArrayTools.hx",22,0x25b10579)
HX_LOCAL_STACK_FRAME(_hx_pos_87e0094afb26cdf5_25_toInterleaved,"grig.audio.lime.UInt8ArrayTools","toInterleaved",0x639cf584,"grig.audio.lime.UInt8ArrayTools.toInterleaved","grig/audio/lime/UInt8ArrayTools.hx",25,0x25b10579)
namespace grig{
namespace audio{
namespace lime{

void UInt8ArrayTools_obj::__construct() { }

Dynamic UInt8ArrayTools_obj::__CreateEmpty() { return new UInt8ArrayTools_obj; }

void *UInt8ArrayTools_obj::_hx_vtable = 0;

Dynamic UInt8ArrayTools_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< UInt8ArrayTools_obj > _hx_result = new UInt8ArrayTools_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool UInt8ArrayTools_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x049fa87e;
}

int UInt8ArrayTools_obj::getInt16( ::lime::utils::ArrayBufferView data,int pos){
            	HX_STACKFRAME(&_hx_pos_87e0094afb26cdf5_7_getInt16)
HXLINE(   8)		int a = ( (int)(( ::__hxcpp_memory_get_byte(data->buffer->b,(data->byteOffset + pos)) & 255)) );
HXDLIN(   8)		int val = (a | (( (int)(( ::__hxcpp_memory_get_byte(data->buffer->b,(data->byteOffset + (pos + 1))) & 255)) ) << 8));
HXLINE(   9)		if (((val & 32768) != 0)) {
HXLINE(  10)			return (val - 65536);
            		}
HXLINE(  11)		return val;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(UInt8ArrayTools_obj,getInt16,return )

int UInt8ArrayTools_obj::getInt24( ::lime::utils::ArrayBufferView data,int pos){
            	HX_STACKFRAME(&_hx_pos_87e0094afb26cdf5_14_getInt24)
HXLINE(  15)		int a = ( (int)(( ::__hxcpp_memory_get_byte(data->buffer->b,(data->byteOffset + pos)) & 255)) );
HXDLIN(  15)		int a1 = (a | (( (int)(( ::__hxcpp_memory_get_byte(data->buffer->b,(data->byteOffset + (pos + 1))) & 255)) ) << 8));
HXDLIN(  15)		int val = (a1 | (( (int)(( ::__hxcpp_memory_get_byte(data->buffer->b,(data->byteOffset + (pos + 2))) & 255)) ) << 16));
HXLINE(  16)		if (((val & 8388608) != 0)) {
HXLINE(  17)			return (val - 16777216);
            		}
HXLINE(  18)		return val;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(UInt8ArrayTools_obj,getInt24,return )

int UInt8ArrayTools_obj::getInt32( ::lime::utils::ArrayBufferView data,int pos){
            	HX_STACKFRAME(&_hx_pos_87e0094afb26cdf5_22_getInt32)
HXDLIN(  22)		int a = ( (int)(( ::__hxcpp_memory_get_byte(data->buffer->b,(data->byteOffset + pos)) & 255)) );
HXDLIN(  22)		int a1 = (a | (( (int)(( ::__hxcpp_memory_get_byte(data->buffer->b,(data->byteOffset + (pos + 1))) & 255)) ) << 8));
HXDLIN(  22)		int a2 = (a1 | (( (int)(( ::__hxcpp_memory_get_byte(data->buffer->b,(data->byteOffset + (pos + 2))) & 255)) ) << 16));
HXDLIN(  22)		return (a2 | (( (int)(( ::__hxcpp_memory_get_byte(data->buffer->b,(data->byteOffset + (pos + 3))) & 255)) ) << 24));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(UInt8ArrayTools_obj,getInt32,return )

::Array< Float > UInt8ArrayTools_obj::toInterleaved( ::lime::utils::ArrayBufferView data,int bitsPerSample){
            	HX_STACKFRAME(&_hx_pos_87e0094afb26cdf5_25_toInterleaved)
HXLINE(  26)		::Array< Float > newBuffer = ::Array_obj< Float >::__new();
HXLINE(  27)		if ((bitsPerSample == 8)) {
HXLINE(  28)			newBuffer->resize(data->length);
HXLINE(  29)			{
HXLINE(  29)				int _g = 0;
HXDLIN(  29)				int _g1 = data->length;
HXDLIN(  29)				while((_g < _g1)){
HXLINE(  29)					_g = (_g + 1);
HXDLIN(  29)					int i = (_g - 1);
HXLINE(  30)					int _hx_int = ( (int)(( ::__hxcpp_memory_get_byte(data->buffer->b,(data->byteOffset + i)) & 255)) );
HXDLIN(  30)					Float _hx_tmp;
HXDLIN(  30)					if ((_hx_int < 0)) {
HXLINE(  30)						_hx_tmp = (((Float)4294967296.0) + _hx_int);
            					}
            					else {
HXLINE(  30)						_hx_tmp = (_hx_int + ((Float)0.0));
            					}
HXDLIN(  30)					newBuffer[i] = (_hx_tmp / ((Float)128.0));
            				}
            			}
            		}
            		else {
HXLINE(  33)			if ((bitsPerSample == 16)) {
HXLINE(  34)				newBuffer->resize(::Std_obj::_hx_int((( (Float)(data->length) ) / ( (Float)(2) ))));
HXLINE(  35)				 ::haxe::io::Bytes bytes = data->buffer;
HXLINE(  36)				{
HXLINE(  36)					int _g2 = 0;
HXDLIN(  36)					int _g3 = newBuffer->length;
HXDLIN(  36)					while((_g2 < _g3)){
HXLINE(  36)						_g2 = (_g2 + 1);
HXDLIN(  36)						int i1 = (_g2 - 1);
HXLINE(  38)						int pos = (i1 * 2);
HXDLIN(  38)						int a = ( (int)(( ::__hxcpp_memory_get_byte(data->buffer->b,(data->byteOffset + pos)) & 255)) );
HXDLIN(  38)						int val = (a | (( (int)(( ::__hxcpp_memory_get_byte(data->buffer->b,(data->byteOffset + (pos + 1))) & 255)) ) << 8));
HXDLIN(  38)						int _hx_tmp1;
HXDLIN(  38)						if (((val & 32768) != 0)) {
HXLINE(  38)							_hx_tmp1 = (val - 65536);
            						}
            						else {
HXLINE(  38)							_hx_tmp1 = val;
            						}
HXDLIN(  38)						newBuffer[i1] = (( (Float)(_hx_tmp1) ) / ((Float)32767.0));
            					}
            				}
            			}
            			else {
HXLINE(  41)				if ((bitsPerSample == 24)) {
HXLINE(  42)					 ::haxe::io::Bytes bytes1 = data->buffer;
HXLINE(  43)					newBuffer->resize(::Std_obj::_hx_int((( (Float)(data->length) ) / ( (Float)(3) ))));
HXLINE(  44)					{
HXLINE(  44)						int _g4 = 0;
HXDLIN(  44)						int _g5 = newBuffer->length;
HXDLIN(  44)						while((_g4 < _g5)){
HXLINE(  44)							_g4 = (_g4 + 1);
HXDLIN(  44)							int i2 = (_g4 - 1);
HXLINE(  45)							int pos1 = (i2 * 3);
HXDLIN(  45)							int a1 = ( (int)(( ::__hxcpp_memory_get_byte(data->buffer->b,(data->byteOffset + pos1)) & 255)) );
HXDLIN(  45)							int a2 = (a1 | (( (int)(( ::__hxcpp_memory_get_byte(data->buffer->b,(data->byteOffset + (pos1 + 1))) & 255)) ) << 8));
HXDLIN(  45)							int val1 = (a2 | (( (int)(( ::__hxcpp_memory_get_byte(data->buffer->b,(data->byteOffset + (pos1 + 2))) & 255)) ) << 16));
HXDLIN(  45)							int _hx_tmp2;
HXDLIN(  45)							if (((val1 & 8388608) != 0)) {
HXLINE(  45)								_hx_tmp2 = (val1 - 16777216);
            							}
            							else {
HXLINE(  45)								_hx_tmp2 = val1;
            							}
HXDLIN(  45)							newBuffer[i2] = (( (Float)(_hx_tmp2) ) / ((Float)8388607.0));
            						}
            					}
            				}
            				else {
HXLINE(  48)					if ((bitsPerSample == 32)) {
HXLINE(  49)						newBuffer->resize(::Std_obj::_hx_int((( (Float)(data->length) ) / ( (Float)(4) ))));
HXLINE(  50)						{
HXLINE(  50)							int _g6 = 0;
HXDLIN(  50)							int _g7 = newBuffer->length;
HXDLIN(  50)							while((_g6 < _g7)){
HXLINE(  50)								_g6 = (_g6 + 1);
HXDLIN(  50)								int i3 = (_g6 - 1);
HXLINE(  51)								int pos2 = (i3 * 4);
HXDLIN(  51)								int a3 = ( (int)(( ::__hxcpp_memory_get_byte(data->buffer->b,(data->byteOffset + pos2)) & 255)) );
HXDLIN(  51)								int a4 = (a3 | (( (int)(( ::__hxcpp_memory_get_byte(data->buffer->b,(data->byteOffset + (pos2 + 1))) & 255)) ) << 8));
HXDLIN(  51)								int a5 = (a4 | (( (int)(( ::__hxcpp_memory_get_byte(data->buffer->b,(data->byteOffset + (pos2 + 2))) & 255)) ) << 16));
HXDLIN(  51)								newBuffer[i3] = (( (Float)((a5 | (( (int)(( ::__hxcpp_memory_get_byte(data->buffer->b,(data->byteOffset + (pos2 + 3))) & 255)) ) << 24))) ) / ((Float)2147483647.0));
            							}
            						}
            					}
            					else {
HXLINE(  55)						::haxe::Log_obj::trace(HX_("Unknown integer audio format",59,79,02,31),::hx::SourceInfo(HX_("grig/audio/lime/UInt8ArrayTools.hx",79,05,b1,25),55,HX_("grig.audio.lime.UInt8ArrayTools",84,bd,4e,27),HX_("toInterleaved",ee,1d,fa,bd)));
            					}
            				}
            			}
            		}
HXLINE(  57)		return newBuffer;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(UInt8ArrayTools_obj,toInterleaved,return )


UInt8ArrayTools_obj::UInt8ArrayTools_obj()
{
}

bool UInt8ArrayTools_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"getInt16") ) { outValue = getInt16_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"getInt24") ) { outValue = getInt24_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"getInt32") ) { outValue = getInt32_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"toInterleaved") ) { outValue = toInterleaved_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *UInt8ArrayTools_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *UInt8ArrayTools_obj_sStaticStorageInfo = 0;
#endif

::hx::Class UInt8ArrayTools_obj::__mClass;

static ::String UInt8ArrayTools_obj_sStaticFields[] = {
	HX_("getInt16",1e,a1,f7,1d),
	HX_("getInt24",fb,a1,f7,1d),
	HX_("getInt32",d8,a2,f7,1d),
	HX_("toInterleaved",ee,1d,fa,bd),
	::String(null())
};

void UInt8ArrayTools_obj::__register()
{
	UInt8ArrayTools_obj _hx_dummy;
	UInt8ArrayTools_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("grig.audio.lime.UInt8ArrayTools",84,bd,4e,27);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &UInt8ArrayTools_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(UInt8ArrayTools_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< UInt8ArrayTools_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = UInt8ArrayTools_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = UInt8ArrayTools_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace grig
} // end namespace audio
} // end namespace lime
