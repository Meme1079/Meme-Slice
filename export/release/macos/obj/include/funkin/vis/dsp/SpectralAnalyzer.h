// Generated by Haxe 4.3.7
#ifndef INCLUDED_funkin_vis_dsp_SpectralAnalyzer
#define INCLUDED_funkin_vis_dsp_SpectralAnalyzer

#ifndef HXCPP_H
#include <hxcpp.h>
#endif

HX_DECLARE_CLASS2(funkin,vis,AudioClip)
HX_DECLARE_CLASS3(funkin,vis,dsp,MathType)
HX_DECLARE_CLASS3(funkin,vis,dsp,RecentPeakFinder)
HX_DECLARE_CLASS3(funkin,vis,dsp,SpectralAnalyzer)
HX_DECLARE_CLASS2(grig,audio,FFT)
HX_DECLARE_CLASS2(grig,audio,FFTVisualization)
HX_DECLARE_CLASS2(lime,media,AudioSource)
HX_DECLARE_CLASS2(lime,utils,ArrayBufferView)

namespace funkin{
namespace vis{
namespace dsp{


class HXCPP_CLASS_ATTRIBUTES SpectralAnalyzer_obj : public ::hx::Object
{
	public:
		typedef ::hx::Object super;
		typedef SpectralAnalyzer_obj OBJ_;
		SpectralAnalyzer_obj();

	public:
		enum { _hx_ClassId = 0x5953d91c };

		void __construct( ::lime::media::AudioSource audioSource,int barCount,::hx::Null< Float >  __o_maxDelta,::hx::Null< int >  __o_peakHold);
		inline void *operator new(size_t inSize, bool inContainer=true,const char *inName="funkin.vis.dsp.SpectralAnalyzer")
			{ return ::hx::Object::operator new(inSize,inContainer,inName); }
		inline void *operator new(size_t inSize, int extra)
			{ return ::hx::Object::operator new(inSize+extra,true,"funkin.vis.dsp.SpectralAnalyzer"); }
		static ::hx::ObjectPtr< SpectralAnalyzer_obj > __new( ::lime::media::AudioSource audioSource,int barCount,::hx::Null< Float >  __o_maxDelta,::hx::Null< int >  __o_peakHold);
		static ::hx::ObjectPtr< SpectralAnalyzer_obj > __alloc(::hx::Ctx *_hx_ctx, ::lime::media::AudioSource audioSource,int barCount,::hx::Null< Float >  __o_maxDelta,::hx::Null< int >  __o_peakHold);
		static void * _hx_vtable;
		static Dynamic __CreateEmpty();
		static Dynamic __Create(::hx::DynamicArray inArgs);
		//~SpectralAnalyzer_obj();

		HX_DO_RTTI_ALL;
		::hx::Val __Field(const ::String &inString, ::hx::PropertyAccess inCallProp);
		static bool __GetStatic(const ::String &inString, Dynamic &outValue, ::hx::PropertyAccess inCallProp);
		::hx::Val __SetField(const ::String &inString,const ::hx::Val &inValue, ::hx::PropertyAccess inCallProp);
		void __GetFields(Array< ::String> &outFields);
		static void __register();
		void __Mark(HX_MARK_PARAMS);
		void __Visit(HX_VISIT_PARAMS);
		bool _hx_isInstanceOf(int inClassId);
		::String __ToString() const { return HX_("SpectralAnalyzer",8a,31,a3,3e); }

		static int min_Int(int x,int y);
		static ::Dynamic min_Int_dyn();

		static Float clamp_Float(Float val,Float min,Float max);
		static ::Dynamic clamp_Float_dyn();

		static Float calculateBlackmanWindow(int n,int fftN);
		static ::Dynamic calculateBlackmanWindow_dyn();

		Float minDb;
		Float maxDb;
		int fftN;
		Float minFreq;
		Float maxFreq;
		 ::lime::media::AudioSource audioSource;
		::Dynamic audioClip;
		int barCount;
		Float maxDelta;
		int peakHold;
		int fftN2;
		 ::grig::audio::FFT fft;
		 ::grig::audio::FFTVisualization vis;
		::Array< ::Dynamic> barHistories;
		::Array< Float > blackmanWindow;
		int freqToBin(Float freq, ::funkin::vis::dsp::MathType mathType);
		::Dynamic freqToBin_dyn();

		Float normalizedB(Float value);
		::Dynamic normalizedB_dyn();

		void calcBars(int barCount,int peakHold);
		::Dynamic calcBars_dyn();

		void resizeBlackmanWindow(int size);
		::Dynamic resizeBlackmanWindow_dyn();

		::Array< ::Dynamic> getLevels(::Array< ::Dynamic> levels);
		::Dynamic getLevels_dyn();

		::Array< Float > _buffer;
		::Array< Float > getSignal( ::lime::utils::ArrayBufferView data,int bitsPerSample);
		::Dynamic getSignal_dyn();

		Float set_minDb(Float value);
		::Dynamic set_minDb_dyn();

		Float set_maxDb(Float value);
		::Dynamic set_maxDb_dyn();

		int set_fftN(int value);
		::Dynamic set_fftN_dyn();

};

} // end namespace funkin
} // end namespace vis
} // end namespace dsp

#endif /* INCLUDED_funkin_vis_dsp_SpectralAnalyzer */ 
